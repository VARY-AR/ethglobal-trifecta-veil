{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":1505008870961362169,"abi":{"parameters":[{"name":"data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":512,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"boolean"},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5634341720269277520":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5675127253506927136":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6314603625877298116":{"error_kind":"string","string":"haystack length of size 0 not supported"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6543056410826478903":{"error_kind":"string","string":"incorrect value for claim"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7788270038095378938":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"15412340888643424233":{"error_kind":"string","string":"needle length of size 0 not supported"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"18261670735869299181":{"error_kind":"string","string":"data length is too long"}}},"bytecode":"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","debug_symbols":"7P3drixJkl4Jvktd88JVTf+MrzIYDDjT7AGBBjkYcq4IvvtYdUXsiKz0sG+fTsnt3zIVXlUVNg6XSEq6qoi4Lv+f//K//ef/5//v//3/+C//9X//b//9X/7j/+1//sv/8d/+X//pf/yX//Zfr//tf/5LL/3//D/+9//Pf/qv//q///f/8Z/+v//jX/5jrf0//Mt//q//27/8x2PM//Uf/uV//y//x3/+l/846v/6D3/3p2XW47e/LbPXP/74+F//9/9w/fvjn/zvz3/yv7/+yf/++e7fP2b7/d9f7f7fb/Wcv/1tO/723//7P55ff7vK+PrTcvT/k6W+jFiKEUs1Yjl+kmXV83eW9oalGbF0I5ZhxDJ/kqW083eY0lv7e5plRXM60RwvK5piRVOtaA4rmmZF061ohhWN1WfxYfVZfFh9Fjerz+Jm9VncrD6Lm9VncbP6LG4/+1ncR/uiWevvaYYVzbSiWVY0P/tZPMfvw5Syav0bmr//6/M4f//rs5Uu/rr0V399hfoaf98f9ddGsRbjWPur/h7rNXT7e/YKZj/A7A3M3p3Z+/piX/Xv2QeYfW70mbo2itX5XiA+C4bzOa/Ywef2AJ/bw/rcvv8MHtbntmB3PrdHKb+zjzr/nt353Fbszue2Ync+hxW787kq2OdG/fN0PoejYwWf2xPcb0/rc1uwW/fbgh3cb0/nc1uxg8/tCT63l/O5rdidz2HF7nyuKnbnc1WxO5+rit35XK3H7xfJs/bz79mdz1XF7nyuKvaN5tJro331CZ5jn+A59gnuh09wP3w6n9uitznB++cTPMc+wXPsE9wPn9x+eLy4/fB4cfvh8eL2w+PlfK7G3jvHy/kcjo6VO8ceL+s5tmC3nmMLdudzW7Fbf6/r9p46inU/LNjB53YBn9uFO8cexfkcVuzc73WNwu2HR+H2w6PsM8ceZZ859qjcOfao3Dn2qNw59qjcOfb4WVdO7D21cufYo4LP7Qo+tyt3jj0qeI59gOfYB7gfPsD98LHRHPuHbUmfjRU8xz7Ac+wDPMc+wHPsAzzHbuA5dgOf2w18bjfwHPuHTVmx7OA5dgP3ww3cDzfnc/XP3yVvbz7fnc9VwW7t91LszueqYnc+VxW787mq2J3PVcVOeef0jp3yzukdO+Wd0zt28Llq7dMS7NY+LcUOPletfVqKHXyuWvu0FDv4XLX2aSl27vvhYe3TUuwbfY9qI//WsPZvid0E2Kc1wD6tAfZpDW+f1v1OCOzTGtY+LTFnBvu0BtinNcA+rQH2aQ2wT2uAfVrD2qcVfO+09m9Fxwr+3pW1r0uxg793Ze3fEuzePq37e6q3T0uwg89ta5+WYnc+txU7+HtXYJ/WAPu0BtinNax9WrH3zmnt34qOlTvHnta+LsXOnWPPl/O5rdi5c+zp7dMS7Nxze1r7tBQ7d449rX1aip07x55gn9YE+7SmtU8r+N5p7d+KjpU7x57Wvi7Fzp1jT2v/lmD39mnd31O9fVqCHXxuW/u0FLvzua3YuXPsCfZpTbBPa4J9WtPap3X/Hf5p7dNS7Nx3TtPap6XYKe+c/v7txLT2Yyl263dO6+v+Xtfff0Za+64Uu/U7J8Fu/c5JsG+0H7b2Y0XHCt4PW/u0FDt4P2zt01Ls4P2wtU9LsYP7YWuflmIH74etfVqKHbwftvZpKXbwnNnapxV877T2b0XHCt4PW/u6FDt4P2zt6xLs1r4ucU+19nUpdvC5be3rUuzO57ZiB++HrX1dih3cD1v7uhT7RnPsjXxdE+zrmmBf1wT7uibY1zXBvq4J9nVNsK9rgn1dE+zrmmBf1wT7uibY1zXBvq65ka9rbuTrmmBf1wT7uibY1zXBvq4J9nVNsK9rgn1dE+zrmmBf1wT7uibY1zXBvq4J9nVNa1/X/ZuVZe3fUuzcd07L2qel2Lm/57Rezufq/TunZe3TUuzcd07L2qel2LnvnJa1T0uwW/u0YmdRy9q/FR0rdz+8rH1dit353Fbs1vthwc7dDy9vn5Zg5/bDy9qnJditfVqKnbsfXmCf1gL7tBbYp7WsfVrB905r/1Z0rNz98LL2dSl27n54Wfu6FDt3P7ysfV2KHXxuW/u6FDt3P7ysfV2KnbsfXta+LsUO7oc38m8ta/9WdKzgOTbY17XAvq7l7esS7OA5trWvS7GDz22wr2uBfV0L7OtaYF/XAvu6lrWvS7FvNMe29m9FxwqeY4N9XQvs61revi7BDp5jW/u6FDv43Ab7uhbY17XAvq4F9nUtsK9rWfu6BLu1f0u8WbH2aSl28Dsna5+WYnc+VxU7+J2TtU9LsYPfOVn7tBQ7+J2TtU9LsW+077X2b0XHCt4PW/u6FDt4Pwz2aS1vn9b97MrbpyXYwf2wtU9LsYP3w2Cf1gL7tBbYp7XAPq1l7dMKvnda+7eiYwXvh619Xffsp7WvS7FzfxfitPZ13d9TT2tfl2Lnntunta9LsXP3w6e1r0uxc/fDp7WvS7Bb+7oU+z5z7NPavxUdK3eOfYJ9XSfY13V6+7oEO3eOfVr7uhQ7+NwG+7pOsK/rBPu6TrCv6wT7uk5rX5di32eOfVr7t6Jj5c6xT7Cv6wT7uk5vX5dgB8+xrX1dih18boN9XSfY13WCfV0n2Nd1gn1dp7WvS7Fz3zmd1j4txc5953Ra+7QUO+Wd0zt27jun09qnpdi575xOa5+WYLf2aSl263NVsG+077X2b0XH6nxuixmKta9LsYP3w2Cf1unt07qfXXn7tO7ZrX1aoh+29mkpdvB+GOzTOsE+rRPs0zrBPq3T2qcVfO+09m9FxwreD1v7uhQ7eD9s7etS7OD9sLWvS7GDz21rX5diB++HrX1dih28H7b2dSl2cD+8kX/rtPZvRcdqfW7f35fAvq4T7Os6vX1dgh08x7b2dQl2sK/rBPu6TrCv6wT7uk6wr+sE+7pOa1+XYt9ojm3t34qOlTvHLi+wsOuC506yL3juKPuC586yL3jnw1vCc0/vC557fF/w3Hn2Bc8daF/w3Il2eYHVXRc8tze+4LmPni547qunC975hJXw3HdPFzzl4dNbeO7Lpwve+umTgue+fSova8mWhOe+frrgrU9YBb/PHvgK1vlEDg+Wuzm+4Lmr4wueuzu+4LmyrQueuz0uL2/dloIn98jWwi0Jz90gX/DOJ7KEJ0+hwdKtC548hbbWbkXfQq09XdHBWou91N3J2uwl4cl7ZGu3l4R3PsHVrdXa7iXhySe4td9LwpP3yNaGLwVvrfiS8OQe2VryJeF3mnJba7vCgyVPucGirwuePOX2Vn0pePKU21r2JeHJJzhY93XBk6fcYOHXBU+ecoOVXxc8uUfeSOJ1BbvTlBus/brgyVNusPjrgidPucHqrwuePOUGy78uePIJDtZ/XfDkKTdYAHbBk3tkawWYhCe/lrKWdEl48mspa02XhKe8lnoLT34tZW3qUvDWqi71Zsfa1SXhya+lrG1dEt75hI0eUln7vcKDJe+RrY1gEp68RyY7u4q3s+t+qFW8nV0KHtwjF2tnl4R3PsElPHiPXMjOrkJ2dhWys6tYO7uCb6HF2vEVHix4j1ysnWASHrxHLtZOMAkP3iMXayeYhCef4NZOMAkP3iMXayeYhAfvkYu1E0zCk3vknRxfxdrxFR4seMpdyE6wQnaCFW8nmIAnO8GKtRNMwpNPcLITrJCdYIXsBCtkJ1ghO8GKtRNMwu805bZ2fIUHS55yk51ghewEK95OMAVPnnJbO8EkPPkEJzvBCtkJVshOsEJ2ghWyE6xYO8EkvPMJK569FGtnl4QHv5Yq1s4uCU95LfUWHvxaqlg7uyQ8+LVUsXZ2SXjwa6li7eyS8Dvtha0dX+HBkvfI1k4wCU/eI5OdXcXb2SWGWt7OLgVP7pGtnV0SnrxHJju7CtnZVcjOrkJ2dhVrZ1f0LdTa8RUeLHmPbO0Ek/DOJ7iEB/8yRbF2gqlbq7UTTMKTT3BrJ5iCt3aCSXjyHtnaCSbhyT2ytRNMwu805bZ2fIUHS55yk51ghewEq95OMAUPnnJXayeYhAef4PUFPsEr2QlWyU6wSnaCVbITrFo7wRT8To6vau34Cg8WPOWuZCdYJTvBqrcTTMGDp9zV2gkm4cknONkJVslOsEp2glWyE6ySnWDV2gkm4cGvpaq1s0vCg19LVWtnl4SnvJZ6B2/t7BKvpaq1s0vCg19LVWtnl4R3PmElvPUJq+A32gtXa8dXeLDgPXK1doIpeGvHl4QHO7uqt7NLDLW8nV0K3vkEVz2ytbNLwpP3yGRnVyU7uyrZ2VXJzq5q7eyKvoVaO77CgyXvka2dYBKevEe2doJJePIe2doJJuHJJ7i1E0zCk/fI1k4wCU/eI1s7wSQ8uUfeyfFVrR1f4cGSp9xkJ1glO8GqtxNMwZOn3NZOMAlPPsHJTrBKdoJVshOskp1glewEq9ZOMAm/05Tb2vEVHix5yk12glWyE6x6O8EUPHnKbe0Ek/DkE5zsBKtkJ1glO8Eq2QlWyU6wau0Ek/Dk11LWzi4JT34tZe3sEvCHtbNLwoNfSx3Wzi4JD34tdbycT1gJD34tdVg7uyT8Rnvhw9rxFR4seI98WDvBJDx4j3yQnV2Ht7Prfqh1eDu7FDy4Rz6snV0SHrxHPsjOroPs7DrIzq6D7Ow6rJ1d0bdQa8dXeLDWJ7i4O1k7wSQ8eI98WDvBJDx4j3xYO8EUvLUTTB2C1k4wCQ/eIx/WTjAJ73zCSnhyj2ztBJPwO025rR1f4cGSp9xkJ9hBdoId3k4wBU+ecls7wSQ8+QQnO8EOshPsIDvBDrIT7CA7wQ5rJ5iE32nKbe34Cg/W+gQXdyeyE+wgO8EObyeYgidPua2dYAqe7AQ7yE6wg+wEO8hOsIPsBDvITrDD2gkm4cGvpQ5rZ5eEJ7+WsnZ2SXjKa6m38OTXUtbOLgnvfMKqNzvWzi4JT34tZe3skvA77YWtHV/RwVo7wdRoxdoJJuHJe2Sys+vwdnaJoZa3s0vBk3tka2eXhCfvkcnOroPs7DrIzq6D7Ow6rJ1d0bdQa8dXeLDkPbK1E0zCk/fI1k4wCQ/eIzdrJ5iEB5/gzdoJJuHBe+T2cj6RJTx4j9ysnWASHtwjt50cX83a8RUdLNkJ1shOsEZ2gjVvJ5iCdz7B1a3V2gkm4cknONkJ1shOsEZ2gjWyE6yRnWDN2gkm4Teacjdrx1d4sOApdyM7wRrZCda8nWAKnjzltnaCSXjyCU52gjWyE6yRnWCN7ARrZCdYs3aCSXjwa6lm7exS8NbOLgkPfi3VrJ1dEh78WqpZO7skPPi1VLN2dkl48GupZu3skvA77YWtHV/hwZL3yNZOMAlP3iOTnV3N29klhlrezi4FT+6RrZ1dEp68RyY7uxrZ2dXIzq5GdnY1a2dX9C3U2vEVHix5j2ztBJPw5D2ytRNMwVs7wdSt1doJJuHJJ7i1E0zCO5/gEp68R7Z2gkl4co9s7QST8DtNua0dX+HBkqfcZCdYIzvBmrcTTMGTp9zWTjAJTz7ByU6wRnaCNbITrJGdYI3sBGvWTjAJ73zCRt9CrR1f4cGSp9xkJ1gjO8GatxPsHr6TnWDd2gkm4cEneCc7wfrL+QSX8OApdyc7wTrZCdatnWASHvxaqls7uyQ8+LVUt3Z2SXjKa6m38M4nrHgt1a2dXRIe/FqqWzu7JDz4tVS3dnYpeGtnV/CQqls7vsKDBe+Ru7UTTMI7n+ASHuzs6t7OLjHU8nZ2KXhyj2zt7FLw1s4uCQ/eI3eys6uTnV2d7Ozq1s6u6FuoteMrPFjwHrlbO8EkPHmPbO0Ek/DkPbK1E0zCk09wayeYhCfvka2dYBKevEe2doJJeHKPvJPjq1s7vsKDJU+5yU6wTnaCdW8nmIInT7mtnWASnnyCk51gnewE62QnWCc7wTrZCdatnWASfqcpt7XjKzxY8pSb7ATrZCdY93aCKXjylNvaCSbhySc42QnWyU6wTnaCdbITrJOdYN3aCabgrR1f6tmLtbNLwpNfS1k7uyS88wkr4cmvpaydXRKe/FrK2tkl4cmvpaydXRJ+p72wteMrPFjyHtnaCSbhyXtksrOrezu7xFDL29ml4ME98rB2dkl48B55kJ1dg+zsGi/nE1bCg6fQw9rZFXwLHdaOr/BgwXvkYe0EU/DWTjAJD/5limHtBBO31mHtBJPw5BPc2gkm4cF75GHtBJPw4D3ysHaCKXhrJ5iE32jKPawdX+HBgqfcg+wEG2Qn2PB2gil48JR7WDvBJDz5BCc7wQbZCTbITrBBdoINshNsWDvBJPxOU25rx1d4sOQpN9kJNshOsOHtBFPw5Cm3tRNMwpNPcLITbJCdYIPsBBtkJ9ggO8GGtRNMwoNfSw1rZ5eEB7+WGtbOLvFmZ1g7uyQ8+YT9WWdXfa3ztz+u5d91sf+Gs7xwTiucnzVlaZwfPalqOf7AmeUNTvXCObxwmhdO98IZXjjTC2d54ZxWOD9rP9I4P9s/tPP8GjS39ganeuEcXjjNC6d74QwvnOmFs7xwTiucHzbmSByvT+Xl9am8vD6Vl9en8vL6VF5en8rL61N5eX0q/7CTpY/2hbPebGB/2LIicYoXTvXCcZ6HR38fxtpVEh4s+VvfZLfJ8HabKHjyd8as3Sbi+zPT2m0i4Td6tzWtXSjhwYLfbc1XI8ODT/Bp7U6R8OB3W9PbbaLgwd9Jm9ZuEwkPfrc1rd0mEh78bmtau02i70LWLpTwYMknuLU7RcKDe/Bp7U5R8NbuFHV3snanSHjyCW7tNpHwzie4hAe/25rWbhMJD363Na3dJhLe+jc47l9STGu3iYSnvNt6C095t/UWfqM99bR2oYQHS55yW7tTJDy5Rya7Taa320R0at5uEwVPnnJbu00kPLlHJrtNJtltMsluk0l2m0xrt0n0LdTahRIdrLU7Rd2drN0pEt7aTqbgyd8Es3anqFurtTtFwpNP8E4+wTt5yt3J3wQb5G+CDXKPPMg98thpyv2ztppPB0uecg/ylHuQp9yDPOUe5Cn3JE+5J/kEn+QTfJKn3D9sKgqGJ0+5J7lHnuQeee405Z47TbkXecq9yFPuRZ5yL/KU+4etVrG31kWeci/yCb7IJ/giT7kXecp9kqfcJ7lHPsk9srVzTPwGx7R2iEl4ym9wvIV3PmElvPMJK+GdT1gJT3kt9QZ+WTvBJDz4V66WteNLwoNP2PUCn7DL2tkl4cEn7LJ2dkl48Am7rJ1dCt7a2SXhwe+Rl7WzS8Jv9E2ttZPja1k7vsT8f5GdXYvs7FpkZ9fydnbdb14W2dm1rJ1dYpC7yM6uRXZ2LbKza5GdXYvs7FpkZ9eydnZF30KtHV/RwVo7wdTdydoJJuHB39Ra1k4wCe98gqtbq7ezS8GTT3BrZ5eEB39Ta1k7uxS8tbNLwpN7ZLKza1k7u6JvodaOr/BgyVNuayeYhCdPua2dYBKePOX2dnYpePIJbu3skvDkKbe1s0vCk6fcZGfXIju7lrWzK/oWau34ig7W2gmm7k7WTjAJT55yWzvBJLzzCa5urd7OLgVPPsGtnV0SnjzltnZ2KXhrZ5eEJ/fIZGfXsnZ2qScA1s4uCU9+LWXt7JLwlNdS7x5fWDu7JLz1a6n1dZ+v681HpbVTS8Jbv5ZS8NavpRT8TntkawdXeLDkPbK1s0vCk/fI1s4uCU/eI1s7uyQ8uUcmO7uWtbNLwjufyBKevEe2dnZJePIU2trZFX0LtXZ8BQd7WjvBxN3ptHaCSXjwHvm0doJJeOcTXNxaT2snmIQHn+CntRNMwoP3yKe1E0zBWzvBJDy4Rz6tnWASfqMp97mTE+wkO8FOshPsJDvBTrIT7CQ7wU6yE+wkO8FOshPsJDvBTrIT7CQ7wU6yE+wkO8HOnZxg505OsJPsBDvJTrCT7AQ7yU6wk+wEO8lOsJPsBDvJTrCT7AQ7yU6wk+wEO8lOsJPsBDutnWDi2ctp7fiS8ODXUqe1s0vCg39b6rR2donXUqe1s0vBWzu7xJud09rZJeHBr6VOa2eXhHc+YaOHVNaOr/BgyXtkayeYhCfvka0dXwre29klhlrezi4FT+6RrZ1dEt75BJfw5D0y2dl1kp1dJ9nZdVo7u6JvodaOr/BgyXtkayeYhCfvka2dYBKevEe2doJJePIJbu0Ek/DkPbK1E0zCk/fI1k4wCU/ukXdyfJ3Wjq/wYMlTbrIT7CQ7wU5vJ5iAJzvBTmsnmIQnn+BkJ9hJdoKdZCfYSXaCnWQn2GntBJPw+0y568va8RUeLHfKfcFzp9wXPHfKfcE7n+ASnjvlvuC5U+4LnnuCX/DcE/yC50656wvsBLvguVPuC57bI1/w3B75gnc+Ye+fvVzw3NdSFzz3tdQFz30tdcFTXku9hee+lqova2eXhOe+lrrgua+lLnjua6kL3vqEVfD77IWvYJ1P5PBguXvkC567R77guXvk+gI7uy547h75greeQit4co9s7eyS8Nw98gXP3SNf8OQpNNjZdcGTp9DWzq7oW6i14ys8WPIe2doJJuGdT3AJz/1liguevEe2doJJePIJbu0EU/DWTjAJT94jWzvBJDy5R7Z2gkn4nabc1o6v8GDJU26wE+yCJ0+5vZ1gCp485bZ2gkl48gkOdoJd8OQpN9gJdsGTp9xgJ9gFT+6RN3J8XcHuNOUGO8EuePKUG+wEu+DJU26wE+yCJ0+5wU6wC558goOdYBc8ecoNdoJd8OQe2doJJuHJr6WsnV0SnvxaytrZJeEpr6XewVs7u9RrKWtnl4Qnv5aydnZJeOcTVsJbn7AKfqe9sLXjKzxY8h7Z2gkm4Iu140vCg51dxdvZdT/UKt7OLgXvfIKLHrlYO7skPHiPXMjOrkJ2dhWys6uQnV3F2tkVfAst1o6v8GDBe+Ri7QST8OA9crF2gkl48B65WDvBJDz5BLd2gkl48B65WDvBJDx4j1ysnWASntwj7+T4KtaOr/BgwVPuQnaCFbITrHg7wRQ8ecpt7QST8OQTnOwEK2QnWCE7wQrZCVbITrBi7QST8DtNua0dX+HBkqfcZCdYITvBircTTMGTp9zWTjAJTz7ByU6wQnaCFbITrJCdYIXsBCvWTjAJD34tVaydXRIe/FqqWDu7FLy1s0vCg19LFWtnl4QHv5Yq1s4uCQ9+LVWsnV0Sfqe9sLXjKzxY8h7Z2gkm4cl7ZLKzq3g7u8RQy9vZpeDJPbK1s0vCk/fIZGdXITu7CtnZVcjOrmLt7Iq+hVo7vsKDtT7Bxd3J2gkm4cl7ZGsnmIQn75GtnWAK3toJpg5BayeYhCfvka2dYBLe+YSV8OQe2doJJuF3mnJbO77CgwVPuSvZCVbJTrDq7QRT8OApd305n+ASHnyCV7ITrJKdYJXsBKtkJ1glO8GqtRNMwm805a7Wjq/wYK1PcHF3IjvBKtkJVr2dYAoePOWu1k4wBU92glWyE6ySnWCV7ASrZCdYJTvBqrUTTMKDX0tVa2eXhAe/lqrWzi4JT3kt9RYe/FqqWju7JLzzCSve7FRrZ5eEB7+WqtbOLgm/0V64Wju+ooO1doKp0Yq1E0zCk/fIZGdX9XZ2iaGWt7NLwZN7ZGtnl4Qn75HJzq5KdnZVsrOrkp1d1drZFX0LtXZ8hQdL3iNbO8EkPHmPbO0Ek/DkPbK1E0zCk09wayeYhCfvka2dYBKevEe2doJJeHKPvJPjq1o7vqKDJTvBKtkJVslOsOrtBFPwzie4urVaO8EkPPkEJzvBKtkJVslOsEp2glWyE6xaO8Ek/E5TbmvHV3iw5Ck32QlWyU6w6u0EU/DkKbe1E0zCk09wshOskp1glewEq2QnWCU7waq1E0zCk19LWTu7BPxh7eyS8ODXUoe1s0vCg19LHS/nE1bCg19LHdbOLgkPfi11WDu7JPxGe+HD2vEVHix4j3xYO8EkPHiPfJCdXYe3s+t+qHV4O7sUPLhHPqydXRIevEc+yM6ug+zsOsjOroPs7DqsnV3Rt1Brx1d4sOA98mHtBJPw4D3yYe0EU/DWTjB1a7V2gkl48glu7QST8M4nuIQH75EPayeYhCf3yNZOMAm/05Tb2vEVHix5yk12gh1kJ9jh7QRT8OQpt7UTTMKTT3CyE+wgO8EOshPsIDvBDrIT7LB2gkl45xM2+hZq7fgKD5Y85SY7wQ6yE+zwdoIJeLIT7LB2gkl48glOdoIdZCfYQXaCHWQn2EF2gh3WTjAJT34tZe3skvDk11LWzi4JT3kt9Rbe+YRVr6WsnV0SnvxaytrZJeHJr6WsnV0K3trZFT2ksnZ8hQdL3iNbO8EkvPMJLuHBzq7D29klhlrezi4FT+6RrZ1dCt7a2SXhyXtksrPrIDu7DrKz67B2dkXfQq0dX+HBkvfI1k4wCQ/eIzdrJ5iEB++Rm7UTTMKDT/D2Ap/gzdoJJuHBe+Rm7QST8OAeuVk7wRT8To6vZu34Cg8WPOVuZCdYIzvBmrcTTMGDp9zN2gkm4cknONkJ1shOsEZ2gjWyE6yRnWDN2gkm4Teacjdrx1d4sOApdyM7wRrZCda8nWAKnjzltnaCSXjyCU52gjWyE6yRnWCN7ARrZCdYs3aCKXhrx5d49tKsnV0SHvxaqlk7uyS88wkr4cGvpZq1s0vCg19LNWtnl4QHv5Zq1s4uCb/TXtja8RUeLHmPbO0Ek/DkPTLZ2dW8nV1iqOXt7FLw5B7Z2tkl4cl7ZLKzq5GdXY3s7GpkZ1ezdnZF30KtHV/hwZL3yNZOMAVv7QST8OBfpmjWTjB1a7V2gkl48glu7QST8OQ9srUTTMKT98jWTjAFb+0Ek/A7TbmtHV/hwZKn3GQnWCM7wZq3E0zBk6fc1k4wCU8+wclOsEZ2gjWyE6yRnWCN7ARr1k4wCb/TlNva8RUeLHnKTXaCdbITrHs7wRQ8eMrdrZ1gEh58gneyE6yTnWCd7ATrZCdYJzvBurUTTMKDX0t1a2eXhAe/lurWzi4JT3kt9RYe/FqqWzu7JDz4tVS3dnYpeGtnl4S3PmEV/EZ74W7t+AoP1vkEV6MVayeYhAfvkTvZ2dW9nV1iqOXt7BLw1s4u1SNbO7skPHiP3MnOrk52dnWys6uTnV3d2tkVfQu1dnyFB0veI1s7wSQ8eY9s7QST8OQ9srUTTMKTT3BrJ5iEJ++RrZ1gEp68R7Z2gkl4co+8k+OrWzu+woO1PsHF3YnsBOtkJ1j3doIpePKU29oJpuDJTrBOdoJ1shOsk51gnewE62QnWLd2gkn4nabc1o6v8GDJU26yE6yTnWDd2wmm4MlTbmsnmIQnn+BkJ1gnO8E62QnWyU6wTnaCdWsnmIQnv5aydnZJeOcTVsKTX0tZO7skPPm1lLWzS8KTX0tZO7skPPm1lLWzS8LvtBe2dnyFB0veI1s7wSQ8eY9MdnZ1b2fX/VBreDu7FDy4Rx7Wzi4JD94jj5fziSzhwVPoQXZ2DbKza1g7u4JvocPa8RUdrLUTTNydhrUTTMKD98jD2gkm4Z1PcHVrtXaCSXjyCW7tBJPw4D3ysHaCKXhrJ5iEJ/fI1k4wCb/RlHtYO77CgwVPuQfZCTbITrDh7QRT8OQpt7UTTMKTT3CyE2yQnWCD7AQbZCfYIDvBhrUTTMLvNOW2dnxFB0t2gg2yE2yQnWDD2wmm4J1PcHVrtXaCSXjyCU52gg2yE2yQnWCD7AQbZCfYsHaCSXjwa6lh7eyS8ODXUsPa2SXhKa+l3sKDX0sNa2eXgrd2dok3O8Pa2SXhwa+lhrWzS8I7n7DRQyprx1d4sOQ9srUTTMKT98hkZ9fwdnaJoZa3s0vBk3tka2eXhHc+wSU8eY9MdnYNsrNrkJ1dw9rZFX0LtXZ8hQdL3iNbO8EkPHmPbO0Ek/DkPbK1E0zCk09wayeYhCfvka2dYBKevEe2doJJeHKPvJPja1g7vsKDJU+5yU6wQXaCDW8n2D38JDvBprUTTMKDT/BJdoLNl/MJLuHBU+5JdoJNshNsWjvBJPxGU+5p7fgKDxY85Z5kJ9gkO8GmtxNMwYOn3NPaCSbhySc42Qk2yU6wSXaCTbITbJKdYNPaCSbhnU9Y8exlWju7JDz4tdS0dnZJeMprqbfw4NdS09rZJeHBr6WmtbNLwoNfS01rZ5eE32gvPK0dX+HBgvfI09oJJuHJe2Sys2t6O7vEUMvb2aXgyT2ytbNLwpP3yGRn1yQ7uybZ2TXJzq5p7eyKvoVaO77CgyXvka2dYBLe+QSX8OBfppjWTjB1a7V2gkl48glu7QRT8NZOMAlP3iNbO8EkPLlHtnaCSfidptzWjq/wYMlTbrITbJKdYNPbCabgyVNuayeYhCef4GQn2CQ7wSbZCTbJTrBJdoJNayeYgt/J8TWtHV/hwZKn3GQn2CQ7waa3E0zBk6fc1k4wCU8+wclOsEl2gk2yE2ySnWCT7ASb1k4wCU9+LWXt7JLw5NdS1s4u9WbH2tkl4Je1s0t82ixrZ5eE/9ETtr7W+dsf1/LvWvB/wzm8cJoXTvfCGV440wvnR0+TWo4/cGZ5g3Na4fysE0rjFC+c6oVzeOE0L5zuhTO8cKYXjtencvH6VP5hL1A7f8cpvbU3OMULp3rhHF44zQune+EML5zphbO8cE4rnMPrU/nw+lQ+vD6VD69P5cPrU/nw+lQ+vD6VD69P5R92j/TRvnDWeoNzWuH8sB9E4hQvHOfNbfAXwZa18yM82GYcrPj60rJ2hEh48K85LWtHiIS3fp90/8WxZe0IUfA7OULWTo6QRXaELLIjZJEdIYvsCFlkR8giO0IW2RGyyI6QRXaELLIjZJEdIcvaERJ9F7J2ioQHSz7BrZ0iEp7cg5MdIcvbESLuTt6OEAVPPsGtHSESHvz+aZEdIYvsCFlkR8giO0KWtSNEPSGydoQoeGtHiIS3/rUoBb/Tntra+REerPMJrvoFsiNkeTtCFDy5R7Z2hKhOzdoRouDJjpBFdoQssiNkkR0hi+wIWdaOEAlP7pGtHSHRt1Brp0h4sGAT9mntIJHw1iZsBQ/+Jtj5sv4m2P2t9Xw5n+ASHnyCny/wCX6+wFPu8wX+Jtj5An8T7CzgHvks4B75LBtNuc+y0ZT7/FkXTvDdqYCn3GcBT7nPAp5ynwU85T4LeMp9VvIJXskneAVPuc8KnnKfP+w1CoYn98iV3CPXjabcZ91oyn1W8pT7IE+5D/KU+yBPuQ/ylPuHHVjB8OQT/CCf4Ad5yn2Qp9wHecrdyD1yI/fI1s4x8eMzp7VDTMI7n7ASHvxrUae1E0zCg38t6rR2gkl4ymupd/DWTjAJT3kt9RaefMJaO7skPPmEtXZ2SXjyCWvt7JLw5BPW2tml4K2dXeJJ72nt7JLwO31TayfH12nt+FLzf7Kz6yQ7u06ys+v0dnaJzQvZ2XVaO7vUIJfs7DrJzq6T7Ow6yc6uk+zsOsnOrtPa2RV9C7V2fIUHS/6mlrUTTMKTv6ll7QST8ORvank7uxQ8+QS3dnZJePI3taydXRKe/E0tsrPrJDu7TmtnV/Qt1NrxFR6s9Qku7k7WTjAJT55yWzvBJDx5yu3t7LqFP17Wzq77Q/CC557gFzx3yn3Bc6fcF7zzCSvhuT3yBc/tkS/4fabcV7D7TLmvYLlT7uNl7QST8Nwp9wXPnXJf8Nwp9wXvfIJLePIJbu3skvDcKfcFz51yX/DcKffxAju7Lnhyj2zt7Lp/AnDBc19LXfDOJ6yE576WuuApr6X+/vHFBU95LfUW3vq11Pq6z9f17qPS+rWUgLd2akl469dSCn6fPfIV7D575CtY5xNcTSesnV0SnrtHvuC5e+QLnrtHvuDJe2Sws+uCJ/fI1s4uCU/eI1s7uyQ8eQpt7eyS8Dvtka0dX+HBkvfI1k4wCU/eI1s7wSQ8eY9s7QST8OQT3NoJJuHJe2RrJ5iEJ++RrZ1gEp7cI2/kBLuC3WnKDXaCXfDkKTfYCXbBk6fcYCfYBU+ecoOdYBc8+QQHO8EuePKUG+wEu+DJPTLYCXbB7zTl3sgJdgVLnnKDnWAXPHnKDXaCXfDkKTfYCXbBk09wsBPsgidPucFOsAuePOUGO8EueHKPbO0EU89erB1fEt75hJXw5NdS1s4uCU9+LWXt7JLw4NdSxdrZJeHBr6WKtbNLwm+0Fy4v5xM5PFjwHrlYO8EkPHiPXKwdXxIevEcu3s4uBQ/ukYu1s0vCg/fIxdrZJeHBU+hCdnYVsrOrWDu7om+h1o6v6GCtnWDq7mTtBJPw4D1ysXaCSXjnE1zdWq2dYBKefIJbO8EkPHiPXKydYAre2gkm4ck9srUTTMLvNOW2dnyFB0uecpOdYIXsBCveTjAFT55yWzvBJDz5BCc7wQrZCVbITrBCdoIVshOsWDvBJPxOU25rx1d0sGQnWCE7wQrZCVa8nWAK3vkEV7dWayeYhCef4GQnWCE7wQrZCVbITrBCdoIVayeYhAe/lirWzi4JD34tVaydXRKe8lrqLTz4tVSxdnYpeGtnl3qzY+3skvDk11LWzi4J73zCRg+prB1f4cGS98jWTjAJT94jk51dxdvZJYZa3s4uBU/uka2dXRLe+QSX8OQ9MtnZVcjOrkJ2dhVrZ1f0LdTa8RUeLHmPbO0Ek/DkPbK1E0zCk/fI1k4wCU8+wa2dYBIevEeu1k4wCQ/eI1drJ5iEB/fI9eV8wgbfQqu14ys8WPCUu5KdYJXsBKveTjABT3aCVWsnmIQnn+BkJ1glO8Eq2QlWyU6wSnaCVWsnmITfaMpdrR1f4cGCp9yV7ASrZCdY9XaCKXjwlLtaO8EkPPkEJzvBKtkJVslOsEp2glWyE6xaO8EkvPMJK569VGtnl4QHv5aq1s4uCU95LfUWHvxaqlo7uyQ8+LVUtXZ2SXjwa6lq7eyS8Dvtha0dX+HBkvfI1k4wCU/eI5OdXdXb2SWGWt7OLgVP7pGtnV0SnrxHJju7KtnZVcnOrkp2dlVrZ1f0LdTa8RUeLHmPbO0Ek/DOJ7iEB/8yRbV2gqlbq7UTTMKTT3BrJ5iCt3aCSXjyHtnaCSbhyT2ytRNMwu805bZ2fIUHS55yk51glewEq95OMAVPnnJbO8EkPPkEJzvBKtkJVslOsEp2glWyE6xaO8EU/E6Or2rt+AoPljzlJjvBKtkJVr2dYAqePOW2doJJePIJTnaCHWQn2EF2gh1kJ9hBdoIdL+cTVsKDX0sd1s4uCQ9+LXVYO7skPOW11Dt4a2eXeC11WDu7JDz4tdRh7eyS8M4nrIS3PmEV/EZ74cPa8RUeLHiPfFg7wRS8teNLwoOdXYe3s+t+qHV4O7sUvPMJrnpka2eXhAfvkQ+ys+sgO7sOsrPrIDu7DmtnV/Qt1NrxFR4seI98WDvBJDx4j3xYO8EkPHiPfFg7wSQ8+QS3doJJePIe2doJJuHJe2RrJ5iEJ/fIOzm+DmvHV3iw5Ck32Ql2kJ1gh7cTTMGTp9zWTjAJTz7ByU6wg+wEO8hOsIPsBDvITrDD2gkm4Xeacls7vsKDJU+5yU6wg+wEO7ydYAqePOW2doJJePIJTnaCHWQn2EF2gh1kJ9hBdoId1k4wCU9+LWXt7JLw5NdS1s4uBW/t7JLw5NdS1s4uCU9+LWXt7JLw5NdS1s4uCb/TXtja8RUeLHmPbO0Ek/DkPTLZ2XV4O7vEUMvb2aXgyT2ytbNLwpP3yGRn10F2djWys6uRnV3N2tkVfAtt1o6v8GCtT/D7u1OzdoJJePAeuVk7wSQ8eI/crJ1gCt7aCaYOQWsnmIQH75GbtRNMwjufsBIe3CM3ayeYhN9oyt2sHV/hwYKn3I3sBGtkJ1jzdoIpePCUu1k7wSQ8+QQnO8Ea2QnWyE6wRnaCNbITrFk7wST8TlNua8dXeLDWJ7i4O5GdYI3sBGveTjAFT55yWzvBFDzZCdbITrBGdoI1shOskZ1gjewEa9ZOMAkPfi3VrJ1dEh78WqpZO7skPOW11Ft48GupZu3skvDOJ6x4s9OsnV0SHvxaqlk7uyT8Tntha8dXdLDWTjA1WrF2gkl48h6Z7Oxq3s4uMdTydnYpeHKPbO3skvDkPTLZ2dXIzq5GdnY1srOrWTu7om+h1o6v8GDJe2RrJ5iEJ++RrZ1gEp68R7Z2gkl48glu7QST8OQ9srUTTMKT98jWTjAJT+6Rd3J8NWvHV3SwZCdYIzvBGtkJ1rydYAre+QRXt1ZrJ5iEJ5/gZCdYIzvBGtkJ1slOsE52gnVrJ5iE32jK3V/OJ3J4sOApdyc7wTrZCda9nWAKHjzl7tZOMAlPPsHJTrBOdoJ1shOsk51gnewE69ZOMAkPfi3VrZ1dCt7a2SXhwa+lurWzS8KDX0t1a2eXhAe/lurWzi4JD34t1a2dXRJ+o71wt3Z8hQcL3iN3ayeYhAfvkTvZ2dW9nV1iqOXt7FLw5B7Z2tkl4cl7ZLKzq5OdXZ3s7OpkZ1e3dnZF30KtHV/hwZL3yNZOMAlP3iNbO8EUvLUTTN1arZ1gEp58gls7wSS88wku4cl7ZGsnmIQn98jWTjAJv9OU29rxFR4secpNdoJ1shOsezvBFDx5ym3tBJPw5BOc7ATrZCdYJzvBOtkJ1slOsG7tBJPwzids9C3U2vEVHix5yk12gnWyE6x7O8EEPNkJ1q2dYBKefIKTnWCd7ATrZCdYJzvBOtkJ1q2dYBKe/FrK2tkl4cmvpaydXRKe8lrqLbzzCateS1k7uyQ8+bWUtbNLwpNfS1k7uwT8sHZ2BQ+phrXjKzxY8B55WDvBJLzzCS7hwc6u4e3suh9qDW9nl4IH98jD2tml4K2dXRIevEceZGfXIDu7BtnZNaydXdG3UGvHV3iw4D3ysHaCSXjwHnlYO8EkPHiPPKydYBKefIJbO8EkPHiPPKydYBIevEce1k4wCU/ukXdyfA1rx1d4sOQpN9kJNshOsOHtBFPw5Cm3tRNMwpNPcLITbJCdYIPsBBtkJ9ggO8GGtRNMwu805bZ2fIUHS55yk51gg+wEG95OMAVPnnJbO8EkPPkEJzvBBtkJNshOsEF2gg2yE2xYO8EUvLXjSzx7GdbOLgkPfi01rJ1dEt75hJXw4NdSw9rZJeHBr6WGtbNLwpNfS1k7uyT8Tntha8dXeLDkPbK1E0zCk/fIZGfX8HZ2iaGWt7NLwZN7ZGtnl4Qn75HJzq5BdnYNsrNrkJ1dw9rZFX0LtXZ8hQdL3iNbO8EUvLUTTMKDf5liWDvB1K3V2gkm4cknuLUTTMKT98jWTjAJT94jWzvBBPy0doJJ+I2m3NPa8RUeLHjKPV/OJ7iEB0+5p7cTTMGDp9zT2gkm4cknONkJNslOsEl2gk2yE2ySnWDT2gkm4Teack9rx1d4sOAp9yQ7wSbZCTa9nWAKHjzlntZOMAlPPsHJTrBJdoJNshNskp1gk+wEm9ZOMAkPfi01rZ1dEh78WmpaO7skPOW11Ft48Gupae3skvDg11LT2tml4K2dXRLe+oRV8Dvtha0dX+HBOp/garRi7QST8OQ9MtnZNb2dXWKo5e3sEvDWzi7VI1s7uyQ8eY9MdnZNsrNrkp1dk+zsmtbOruhbqLXjKzxY8h7Z2gkm4cl7ZGsnmIQn75GtnWASnnyCWzvBJDx5j2ztBJPw5D2ytRNMwpN75J0cX9Pa8RUerPUJLu5OZCfYJDvBprcTTMGTp9zWTjAFT3aCTbITbJKdYJPsBJtkJ9gkO8GmtRNMwu805bZ2fIUHS55yk51gk+wEm95OMAVPnnJbO8EkPPkEJzvBJtkJNslOsEl2gi2yE2xZO8EkPPi11LJ2dkl45xNWwoNfSy1rZ5eEB7+WWtbOLgkPfi21rJ1dEh78WmpZO7sk/EZ74WXt+AoPFrxHXtZOMAkP3iMvsrNreTu77oday9vZpeDJPbK1s0vCg/fIi+zsWmRn1yI7uxbZ2bWsnV3Rt1Brx1d0sNZOMHV3snaCSXjwHnlZO8EkvPMJrm6t1k4wCU8+wa2dYBIevEde1k4wBW/tBJPw5B7Z2gkm4Xeacls7vsKDJU+5yU6wRXaCLW8nmIInT7mtnWASnnyCk51gi+wEW2Qn2CI7wRbZCbasnWASfqcpt7XjKzpYshNskZ1gi+wEW95OMAXvfIKrW6u1E0zCk09wshNskZ1gi+wEW2Qn2CI7wZa1E0zCk19LWTu7JDz5tZS1s0vCU15LvYUnv5aydnYpeGtnl3qzY+3skvDk11LWzi4J73zCRg+prB1f4cGS98jWTjAJT94jk51dy9vZJYZa3s4uBU/uka2dXRLe+QSX8OQ9MtnZtcjOrkV2di1rZ1fwLfS0dnyFBwveI5/WTjAJD94jny/nE1zCg/fIp7UTTMKDT/DT2gkm4cF75NPaCSbhwXvk09oJJuHBPfK5k+PrtHZ8hQcLnnKfZCfYSXaCnd5OMAFPdoKd1k4wCU8+wclOsJPsBDvJTrCT7AQ7yU6w09oJJuF3mnJbO77CgyVPuclOsJPsBDu9nWAKnjzltnaCSXjyCU52gp1kJ9hJdoKdZCfYSXaCndZOMAnvfMKKZy+ntbNLwoNfS53Wzi7xZue0dnZJePIJa+3skvA/esLW1zp/++Na/l0L/m841Qvn8MJpXjjdC2d44fzoaVLL8QfOLG9wlhfOaYXzs9YmjVO8cKoXzuGF07xwuhfO8MLx+lT+YYtQO3/HKb21NzinFc4Pm34kTvHCqV44hxdO88LpXjjDC2d64Xh9Kk+vT+Xl9am8vD6Vl9en8vL6VF5en8rL61P5h00lfbQvnPVm1//D7hGJs7xwTisca+NH9DevrA0h4cGSv6llbRSR8I0MD/7tp9PaKKK+qWVtFJHwG/0yxbmRgaS9rA0k9x8IFzz3u9YXPPcEv+C5J/gFb32C334UX/Dc71pf8NzXUhc897vWFzz3u9YXPPebYO0FNopc8Pv01FewzidyeLDkE9zaWCLhuT34Bc81ilzw3B78grc2iih48glubRSR8NzXUhc897XUBc99LXXBO5+wEp5rFLngKa+l/v7NzgXPfS11wXNfS13w3N+Waq+NDCFXsDv11GCjyAVP7pHBRpELntwjg40iFzy5RwYbRS54co8MNopc8OQeGWwUueDJPbK1UUTC7+PBvoJ1PpHDg+V6sy94rjf7gud6s9vL2lgi4bne7AveukdW8OQT/GfdKdHw5Cl3J38TrJO/CdbJPXIn98hjpyn32GnKPchT7kGecv+sZycanjzlHuQp9yBPuQf5BB/kE3ySp9yTPOWe5Cn3JPfIP+xMCobfaco9d5pyT/KUe5Kn3JM85V7kKfciT7kXecq9yCf4D/u1guHJU+5FnnIv8pR7kXvkRe6RrZ1j97/2csE7n7AS3vmElfDOJ6yEdz5hJTz3t6UueO5vS13wlNdSb+Epr6XewlNeS72BL9bOLgkPPmGLtbNLwoNP2PICn7DF2tkl4cEnbLF2dkl48HvkYu3sUvDWzq7gTUrZyfFVrB1fYv5fyM6uQnZ2FbKzq3g7u+43L4Xs7CrWzi4xyC1kZ1chO7sK2dlVyM6uQnZ2FbKzq1g7u6JvodaOr/Bgwd/UKtZOMAkP/qZWsXaCSXjwN7WKt7NLwZNPcGtnl4QHf1OrWDu7JDz4m1qF7OwqZGdXsXZ2Rd9CrR1f4cGSp9zWTjAJ73yCS3jylNva8aVurd7OLgVPPsGtnV0K3trZJeHJU25rZ5eEJ/fIZGdXsXZ2Rd9CrR1f4cGSp9zWTjAJT55yWzvBJDx5yu3t7FLw5BPc2tkl4clTbmtnl4QnT7nJzq5CdnYVa2eXegJg7eyS8OTXUtbOLgnvfMKqxxfWzi4Jb/1aan3d5+t691Fp/VpKwVu/llLw1q+lBLy1Uyt6zmPt4AoPlrxHtnZ2SXjnE1zCk/fI1s4uNReydnZJeHKPTHZ2FWtnl4Qn75GtnV0SnjyFtnZ2Sfid9sjWjq/wYMl7ZGsnmIQH75GrtRNMwoP3yNXaCSbhwSd4fYFP8GrtBJPw4D1ytXaCSXhwj1ytnWAKficnWN3JCVbJTrBKdoJVshOskp1glewEq2QnWCU7wSrZCVbJTrBKdoJVshOskp1glewEqzs5wepOTrBKdoJVshOskp1glewEq2QnWCU7wSrZCVbJTrBKdoJVshOskp1glewEq2QnWLV2golnL9Xa8SXhwa+lqrWzS8I7n7ASHvxaqlo7uyQ8+LVUtXZ2SXjwa6lq7eyS8Dvtha0dX+HBkvfI1k4wCU/eI1s7viQ8eY/s7exS8OQe2drZJeHJe2RrZ5eEJ0+hyc6uSnZ2VWtnV/Qt1NrxFR4seY9s7QRT8NZOMAlvvUdW8OQ9srUTTMKTT3BrJ5iEJ++RrZ1gEp68R7Z2gil4ayeYhN9pym3t+AoPljzlJjvBKtkJVr2dYAqePOW2doJJePIJTnaCVbITrJKdYJXsBKtkJ1i1doJJ+J2m3NaOr/BgyVNushPsIDvBDm8nmIIHT7kPayeYhAef4AfZCXaQnWAH2Ql2kJ1gB9kJdlg7wSQ8+LXUYe3skvDg11KHtbNLwlNeS72FB7+WOqydXRIe/FrqsHZ2KXhrZ5eEtz5hFfxGe+HD2vEVHqzzCa5GK9ZOMAkP3iMfZGfX4e3sEkMtb2eXgLd2dqke2drZJeHBe+SD7Ow6yM6ug+zsOsjOrsPa2RV9C7V2fIUHS94jWzvBJDx5j2ztBJPw5D2ytRNMwpNPcGsnmIQn75GtnWASnrxHtnaCSXhyj7yT4+uwdnyFB2t9gou7E9kJdpCdYIe3E0zBk6fc1k4wBU92gh1kJ9hBdoIdZCfYQXaCHWQn2GHtBJPwO025rR1f4cGSp9xkJ9hBdoId3k4wBU+ecls7wSQ8+QQnO8EOshPsIDvBDrIT7CA7wQ5rJ5iEJ7+WsnZ2SXjnE1bCk19LWTu7JDz5tZS1s0vCk19LWTu7JDz5tZS1s0vC77QXtnZ8hQdL3iNbO8EkPHmPTHZ2Hd7OrvuhVvN2dil4cI/crJ1dEh68R24v5xNZwoOn0I3s7GpkZ1ezdnYF30KbteMrOlhrJ5i4OzVrJ5iEB++Rm7UTTMI7n+Dq1mrtBJPw5BPc2gkm4cF75GbtBFPw1k4wCU/uka2dYBJ+oyl3s3Z8hQcLnnI3shOskZ1gzdsJpuDJU25rJ5iEJ5/gZCdYIzvBGtkJ1shOsEZ2gjVrJ5iE32nKbe34ig6W7ARrZCdYIzvBmrcTTME7n+Dq1mrtBJPw5BOc7ARrZCdYIzvBGtkJ1shOsGbtBJPw4NdSzdrZJeHBr6WatbNLwlNeS72FB7+WatbOLgVv7ewSb3aatbNLwoNfSzVrZ5eEdz5ho4dU1o6v8GDJe2RrJ5iEJ++Ryc6u5u3sEkMtb2eXgif3yNbOLgnvfIJLePIemezsamRnVyM7u5q1syv6Fmrt+AoPlrxHtnaCSXjyHtnaCSbhyXtkayeYhCef4NZOMAlP3iNbO8EkPHmPbO0Ek/DkHnknx1ezdnyFB0uecpOdYI3sBGveTrB7+E52gnVrJ5iEB5/gnewE6y/nE1zCg6fcnewE62QnWLd2gkn4jabc3drxFR4seMrdyU6wTnaCdW8nmIIHT7m7tRNMwpNPcLITrJOdYJ3sBOtkJ1gnO8G6tRNMwjufsOLZS7d2dkl48Gupbu3skvCU11Jv4cGvpbq1s0vCg19LdWtnl4QHv5bq1s4uCb/RXrhbO77CgwXvkbu1E0zCk/fIZGdX93Z2iaGWt7NLwZN7ZGtnl4Qn75HJzq5OdnZ1srOrk51d3drZFX0LtXZ8hQdL3iNbO8EkvPMJLuHBv0zRrZ1g6tZq7QST8OQT3NoJpuCtnWASnrxHtnaCSXhyj2ztBJPwO025rR1f4cGSp9xkJ1gnO8G6txNMwZOn3NZOMAlPPsHJTrBOdoJ1shOsk51gnewE69ZOMAW/k+OrWzu+woMlT7nJTrBOdoJ1byeYgidPua2dYBKefIKTnWCd7ATrZCdYJzvBOtkJ1q2dYBKe/FrK2tkl4cmvpaydXRKe8lrqDfywdnaJ11LD2tkl4cGvpYa1s0vCO5+wEt76hFXwG+2Fh7XjKzxY8B55WDvBFLy140vCg51dw9vZdT/UGt7OLgXvfIKLHnlYO7skPHiPPMjOrkF2dg2ys2uQnV3D2tkVfQu1dnyFBwveIw9rJ5iEB++Rh7UTTMKD98jD2gkm4cknuLUTTMKD98jD2gkm4cF75GHtBJPw5B55J8fXsHZ8hQdLnnKTnWCD7AQb3k4wBU+ecls7wSQ8+QQnO8EG2Qk2yE6wQXaCDbITbFg7wST8TlNua8dXeLDkKTfZCTbITrDh7QRT8OQpt7UTTMKTT3CyE2yQnWCD7AQbZCfYIDvBhrUTTMKDX0sNa2eXhAe/lhrWzi4Fb+3skvDk11LWzi4JT34tZe3skvDk11LWzi4Jv9Ne2NrxFR4seY9s7QST8OQ9MtnZNbydXWKo5e3sUvDkHtna2SXhyXtksrNrkJ1dg+zsGmRn17B2dkXfQq0dX+HBWp/g4u5k7QST8OQ9srUTTMKT98jWTjABP62dYOIQnNZOMAkP3iNPayeYhHc+YSU8uEee1k4wCb/RlHtaO77CgwVPuSfZCTbJTrDp7QRT8OAp97R2gkl48glOdoJNshNskp1gk+wEm2Qn2LR2gkn4jabc09rxFR6s9Qku7k5kJ9gkO8GmtxNMwYOn3NPaCabgyU6wSXaCTbITbJKdYJPsBJtkJ9i0doJJePBrqWnt7JLw4NdS09rZJeEpr6XewoNfS01rZ5eEdz5hxZudae3skvDg11LT2tkl4XfaC1s7vqKDtXaCqdGKtRNMwpP3yGRn1/R2domhlrezS8GTe2RrZ5eEJ++Ryc6uSXZ2TbKza5KdXdPa2RV9C7V2fIUHS94jWzvBJDx5j2ztBJPw5D2ytRNMwpNPcGsnmIQn75GtnWASnrxHtnaCSXhyj7yT42taO76igyU7wSbZCTbJTrDp7QRT8M4nuLq1WjvBJDz5BCc7wSbZCTbJTrBJdoJNshNsWjvBJPxOU25rx1d4sOQpN9kJNslOsOntBFPw4Cn3snaCSXjwCb7ITrBFdoKtl/OJLOHBU+5FdoItayeYhAe/llrWzi4Fb+3skvDg11LL2tkl4cGvpZa1s0vCg19LLWtnl4QHv5Za1s4uCb/RXnhZO77CgwXvkZe1E0zCg/fIi+zsWt7OLjHU8nZ2KXhyj2zt7JLw4D3yIju7FtnZtcjOrkV2di1rZ1f0LdTa8RUeLHiPvKydYBIevEde1k4wBW/tBFO3VmsnmIQnn+DWTjAJ73yCS3jyHtnaCSbhyT2ytRNMwu805bZ2fIUHS55yk51gi+wEW95OMAVPnnJbO8EkPPkEJzvBFtkJtshOsEV2gi2yE2xZO8EkvPMJG30LtXZ8hQdLnnKTnWCL7ARb3k4wAU92gi1rJ5iEJ5/gZCfYIjvBFtkJtshOsEV2gi1rJ5iEJ7+WsnZ2SXjyaylrZ5eEp7yWegvvfMKq11LWzi4JT34tZe3skvDk11LWzi4Fb+3sih5SWTu+woMl75GtnWAS3vkEl/BgZ9fydnaJoZa3s0vBk3tka2eXgD+tnV0SHrxHPsnOrpPs7DpfzieshN9oL3xaO77CgwXvkU9rJ5iEB++RT2snmIQH75FPayeYhCef4NZOMAkP3iOf1k4wCQ/eI5/WTjAJT+6Rd3J8ndaOr/BgwVPuk+wEO8lOsNPbCabgwVPu09oJJuHJJzjZCXaSnWAn2Ql2kp1gJ9kJdlo7wST8TlNua8dXeLDkKTfZCXaSnWCntxNMwZOn3NZOMAlPPsHJTrCT7AQ7yU6wk+wEO8lOsNPaCabgrR1f4tnLae3skvDg11KntbNLwjufsBIe/FrqtHZ2SXjwa6nT2tkl4cGvpU5rZ5eE32kvbO34Cg+WvEe2doJJePIemezsOr2dXWKo5e3sUvDkHtna2SXhyXtksrPrJDu7TrKz6yQ7u05rZ1f0LdTa8RUeLHmPbO0EU/DWTjAJD/5litPaCaZurdZOMAlPPsGtnWASnrxHtnaCSXjyHtnaCabgrZ1gEn6nKbe14ys8WPKUm+wEO8lOsNPbCabgyVNuayeYhOee4P0FdoJd8Nwp9wXPnXJf8Nwp9wXvfMJKeG6PfMHvM+W+gt1nyn0Fy51yX/DcKXd/gZ1gFzx3yn3Bc6fcFzx3yn3Bk09wsBPsgudOuS947pT7gudOuS94co9s7QST8NzXUhc897XUBc99LXXBO5+wEp7yWuotPPe11AVv/VpKwXNfS13w3NdS/WXt7JLw1iesgt9nL3wF63wihwfrfIKr0Yq1E0zCc/fIFzzX2XXBc/fIF7z1FFrAWzu7VI9s7eyS8OQ9MtjZdcE7n7ASnjyFBju7Lvid9sLWjq/wYMl7ZGsnmIQn75GtnWASnrxHtnaCSXjyCW7tBJPw5D2ytRNMwpP3yNZOMAlP7pE3cnxd/7edptxgJ9gFT55yg51gFzx5yg12gl3w5Ck32Al2wZNPcLAT7IInT7nBTrALntwjWzvBJPxOU25rx1d4sOQpN9gJdsGTp9zeTjAFT55yWzvBJDz5BAc7wS548pQb7AS74MlTbrAT7IIn98jWji/17MXa2SXhnU9YCc/9bakLnvxaytrZJT9tyCfszzq76nWi//bHtfy7FvxfccrPWrg0TvHCqV44hxdO88L50dOkluMPnFne4AwvnOmFs7xwTiucnzUraZzihVO9cA4vnOaF4/Wp/MMWoXb+jlN6a29wphfO8sI5rXB+2MYjcYoXTvXCObxwmhdO98Lx+lSuXp/K1etTuXp9Kh9en8qH16fy4fWpfHh9Kv+wqaSP9oWz1huc7oUzvHCmF85G37wq1oaQ6GCtjSLi+0LF2igi4cHf1CrWRhEJ35zh77+pVayNIhJ+o1+mKDsZSIq1gUR+IIC/a13IRpFCNooUb6OI+CgmG0WKtVFEfCumkI0ihWwUKWSjSCEbRYq1UST6LmRtIAkPlnyCWxtLJDy5BycbRYq3UUTcnbyNIgqefIJbG0UkPPi1VCEbRQrZKFLIRpFCNooUa6OIeLNTrI0iEh78WqpYG0Uk/E57amtDSHSwZKNIIRtFCtkoUryNIgre+QRXnZq1UUTCk6fcZKNIIRtFCtkoUshGkUI2ihRro4iE38iDXawNJOHBgr3ZxdpYIuHB3uxibSyR8GBvdn1Z98gKHnyC1xf4BK8v8JS7vpxPZAkP/iZYfYF75PoC98j1tdGUu742mnLXAp5y1wKectcCnnLXAp5y1591+ATfWgt4yl0L+QQv5BO8gKfctYCn3LWCp9y1knvkSu6R60ZT7vrD/qYPBwuectcKnnLXCp5y1wqectdKnnIf5Cn3QT7BD/IJfpCn3D/s7gqGJ0+5D3KPfJB7ZGvnmPi1l2rtEFPw1k4wCe98wkp48G9LVWsnmIR3PmElPOW11Ft4ymupt/CU11Jv4cknrLWzS8FbO7skPPmEtXZ2SXjyCWvt7JLw5BPW2tklnvRWa2eXhN/pm1o7Ob6qteNLzf/Jzq5KdnZVsrOreju7xOaF7Oyq1s4uNcglO7sq2dlVyc6uSnZ2VbKzq5KdXdXa2RV9C7V2fIUHS/6mlrUTTMKTv6ll7QST8ORvank7uxQ8+QS3dnZJePI3taydXRKe/E0tsrOrkp1d1drZFX0LtXZ8RQdr7QRTdydrJ5iEJ0+5rZ1gEt75BFe3Vm9nl4Inn+DWzi4JT55yWzu7BPxh7eyS8OAe+SA7uw5rZ1fwLfR4OZ/I4cGCp9yHtRNMwoOn3Ie1E0zCg6fch7ezS8GTT3BrZ5eEB0+5D2tnl4QHT7kPsrPrIDu7Dmtnl3gCcFg7uxS8tbNLwoNfSx3Wzi7x+OKwdnZJeOcTtq6v+/y1uXwDb/1aSsFbv5ZS8NavpRT8Rnvkw9rBFR2st7NLTCesnV0SHrxHPqydXRLe+QRXcyFrZ5eEJ/fIZGfXYe3skvDkPbK1s0vCk6fQ1s4uCb/THtna8RUeLHmPbO0Ek/DkPbK1E0zCk/fI1k4wCU8+wa2dYBKevEe2doJJePIe2doJJuHJPfJOTrBjJyfYQXaCHWQn2EF2gh1kJ9hBdoIdZCfYQXaCHWQn2EF2gh1kJ9hBdoIdZCfYQXaCHTs5wY6dnGAH2Ql2kJ1gB9kJdpCdYAfZCXaQnWAH2Ql2kJ1gB9kJdpCdYAfZCXaQnWAH2Ql2WDvB1LMXa8eXgrd2dkl48mspa2eXhCe/lrJ2dkl48mspa2eXhCe/lrJ2dkn4jfbCzdrxFR4seI/crJ1gEh68R24v5xNcwoP3yM3b2aXgwT1ys3Z2SXjwHrlZO7skPHgK3cjOrkZ2djVrZ1f0LdTa8RUeLHiP3KydYBIevEdu1k4wBW/tBFO3VmsnmIQnn+DWTjAJ73yCS3jwHrlZO8EkPLlHtnaCSfidptzWjq/wYMlTbrITrJGdYM3bCabgyVNuayeYhCef4GQnWCM7wRrZCdbITrBGdoI1ayeYhHc+YaNvodaOr/BgyVNushOskZ1gzdsJJuDJTrBm7QST8OQTnOwEa2QnWCM7wRrZCdbITrBm7QST8ODXUs3a2SXhwa+lmrWzS8JTXku9hXc+YcVrqWbt7JLw4NdSzdrZJeHBr6WatbNLwVs7u6KHVNaOr/BgyXtkayeYhHc+wSU82NnVvJ1dYqjl7exS8OQe2drZpeCtnV0SnrxHJju7GtnZ1cjOrmbt7Iq+hVo7vsKDJe+RrZ1gEp68R7Z2gkl48h7Z2gkm4cknuLUTTMKT98jWTjAJT94jWzvBJDy4R+47Ob66teMrPFjwlLuTnWD95XyCS3jwlLuTnWDd2gkm4cEneCc7wTrZCdbJTrBOdoJ1shOsWzvBJPxGU+5u7fgKDxY85e5kJ1gnO8G6txNMwYOn3N3aCSbhySc42QnWyU6wTnaCdbITrJOdYN3aCabgrR1f4tlLt3Z2SXjwa6lu7eyS8M4nrIQHv5bq1s4uCQ9+LdWtnV0SHvxaqls7uyT8Tntha8dXeLDkPbK1E0zCk/fIZGdX93Z2iaGWt7NLwZN7ZGtnl4Qn75HJzq5OdnZ1srOrk51d3drZFX0LtXZ8hQdL3iNbO8EUvLUTTMKDf5miWzvB1K3V2gkm4cknuLUTTMKT98jWTjAJT94jWzvBFLy1E0zC7zTltnZ8hQdLnnKTnWCd7ATr3k4wBU+ecls7wSQ8+QQnO8E62QnWyU6wTnaCdbITrFs7wST8TlNua8dXeLDkKTfZCdbJTrDu7QRT8OQpt7UTTMKTT3CyE6yTnWCd7ATrZCdYJzvBhrUTTMKDX0sNa2eXhAe/lhov5xNWwlNeS72FB7+WGtbOLgkPfi01rJ1dCt7a2SXhrU9YBb/RXnhYO77Cg3U+wcVoZVg7wSQ8eI88yM6u4e3suh9qDW9nl4C3dnapHtna2SXhwXvkQXZ2DbKza5CdXYPs7BrWzq7oW6i14ys8WPAeeVg7wSQ8eI88rJ1gEh68Rx7WTjAJTz7BrZ1gEh68Rx7WTjAJT94jWzvBJDy5R97J8TWsHV/hwVqf4OLuRHaCDbITbHg7wRQ8ecpt7QRT8GQn2CA7wQbZCTbITrBBdoINshNsWDvBJPxOU25rx1d4sOQpN9kJNshOsOHtBFPw5Cm3tRNMwpNPcLITbJCdYIPsBBtkJ9ggO8GGtRNMwpNfS1k7uyS88wkr4cmvpaydXRKe/FrK2tkl4cmvpaydXRKe/FrK2tkl4XfaC1s7vsKDJe+RrZ1gEp68RyY7u4a3s0sMtbydXQqe3CNbO7skPHmPTHZ2DbKza5CdXYPs7BrWzq7oW6i14ys42GntBBN3p2ntBJPw4D3ytHaCSXjnE1zcWqe1E0zCg0/wae0Ek/DgPfK0doIpeGsnmIQH98jT2gkm4Teack9rx1d4sOAp9yQ7wSbZCTa9nWAKHjzlntZOMAlPPsHJTrBJdoJNshNskp1gk+wEm9ZOMAm/0ZR7Wju+ooMlO8Em2Qk2yU6w6e0EU/DOJ7i6tVo7wSQ8+QQnO8Em2Qk2yU6wSXaCTbITbFo7wSQ8+LXUtHZ2SXjwa6lp7eyS8JTXUm/hwa+lprWzS8FbO7vEm51p7eyS8ODXUtPa2SXhnU/Y6CGVteMrPFjyHtnaCSbhyXtksrNreju7xFDL29ml4Mk9srWzS8I7n+ASnrxHJju7JtnZNcnOrmnt7Iq+hVo7vsKDJe+RrZ1gEp68R7Z2gkl48h7Z2gkm4cknuLUTTMKT98jWTjAJT94jWzvBJDy5R97J8TWtHV/hwZKn3GQn2CQ7waa3E0zAk51g09oJJuHJJzjZCTbJTrBJdoJNshNskp1g09oJJuE3mnIva8dXeLDgKfciO8EW2Qm2Xs4nuIQHT7mXtRNMwoNP8EV2gi2yE2yRnWCL7ARbZCfYsnaCSXjnE1Y8e1nWzi4JD34ttaydXRKe8lrqLTz4tdSydnZJePBrqWXt7JLw4NdSy9rZJeE32gsva8dXeLDgPfKydoJJePAeeZGdXcvb2SWGWt7OLgVP7pGtnV0SHrxHXmRn1yI7uxbZ2bXIzq5l7eyKvoVaO77CgyXvka2dYBLe+QSX8OBfpljWTjB1a7V2gkl48glu7QRT8NZOMAlP3iNbO8EkPLlHtnaCSfidptzWjq/wYMlTbrITbJGdYMvbCabgyVNuayeYhCef4GQn2CI7wRbZCbbITrBFdoItayeYgt/J8bWsHV/hwZKn3GQn2CI7wZa3E0zBk6fc1k4wCU8+wclOsEV2gi2yE2yRnWCL7ARb1k4wCU9+LWXt7JLw5NdS1s4uCU95LfUO3trZpV5LWTu7JDz5tZS1s0vCO5+wEt76hFXwO+2FrR1f4cGS98jWTjABf1o7viQ82Nl1eju77odap7ezS8E7n+CiRz6tnV0SHrxHPsnOrpPs7DrJzq6T7Ow6rZ1dwbfQ09rxFR4seI98WjvBJDx4j3xaO8EkPHiPfFo7wSQ8+QS3doJJePAe+bR2gkl48B75tHaCSXhyj7yT4+u0dnyFBwuecp9kJ9hJdoKd3k4wBU+ecls7wSQ8+QQnO8FOshPsJDvBTrIT7CQ7wU5rJ5iE32nKbe34Cg+WPOUmO8FOshPs9HaCKXjylNvaCSbhySc42Ql2kp1gJ9kJdpKdYCfZCXZaO8EkPPi11Gnt7JLw4NdSp7WzS8FbO7skPPi11Gnt7JLw4NdSp7WzS8KDX0ud1s4uCb/TXtja8RUeLHmPbO0Ek/DkPTLZ2XV6O7vEUMvb2aXgyT2ytbNLwpP3yGRn10l2dp1kZ9dJdnad1s6u6FuoteMrPFjrE1zcnaydYBKevEe2doJJePIe2doJpuCtnWDqELR2gkl48h7Z2gkm4Z1PWAlP7pGtnWASfqcpt7XjKzxY7pR7vMBOsAueO+W+4LlT7gueO+W+4J1PcAnPPcEveO4JfsFzp9wXPHfKfcFzp9zjBXaCXfDcHvmC32fKfQW7z5T7Ctb6BBd3J7AT7ILnTrkveO6U+4LnTrkveO6Ue7zATrALnnyCg51gFzx3yn3BO5+wEp7cI1s7wSQ897XUBc99LXXBc19LjZe1s0vCU15LvYXnvpa64K1fSyl45xP2/s3OBc99LXXBc19LXfDWJ6yC32cvfAXrfCJHB2vtBFOjFWsnmIQn75HBzq4L3vkEV0Mtb2eXgif3yNbOLglP3iODnV3jBXZ2XfDkKTTY2XXB77QXtnZ8hQdL3iNbO8EkPHmPbO0Ek/DkPbK1E0zCk09wayeYhCfvka2dYBKevEe2doJJeHKPvJHj6wp2pyk32Al2wZOn3GAn2AVPnnKDnWAXPHnKDXaCXfDkExzsBLvgyVNusBPsgif3yNZOMAm/05Tb2vEVHix5yg12gl3w5Cm3txNMwZOn3NZOMAlPPsHBTrALnjzlBjvBLnjylBvsBLvgyT2yteNLPXuxdnYJ+GLt7JLw4NdSxdrZJeHBr6XKy/mElfDg11LF2tkl4cGvpYq1s0vCb7QXLtaOr/BgwXvkYu0Ek/DgPXIhO7uKt7PrfqhVvJ1dCh7cIxdrZ5eEB++RC9nZVcjOrkJ2dhWys6tYO7uib6HWjq/wYMF75GLtBJPw4D1ysXaCKXhrJ5i6tVo7wSQ8+QS3doJJeOcTXMKD98jF2gkm4ck9srUTTMLvNOW2dnyFB0uecpOdYIXsBCveTjAFT55yWzvBJDz5BCc7wQrZCVbITrBCdoIVshOsWDvBJLzzCRt9C7V2fIUHS55yk51ghewEK95OMAFPdoIVayeYhCef4GQnWCE7wQrZCVbITrBCdoIVayeYhCe/lrJ2dkl48mspa2eXhKe8lnoL73zCqtdS1s4uCU9+LWXt7JLw5NdS1s4uBW/t7IoeUlk7vsKDJe+RrZ1gEt75BJfwYGdX8XZ2iaGWt7NLwZN7ZGtnl4K3dnZJePIemezsKmRnVyE7u4q1syv6Fmrt+AoPlrxHtnaCSXjwHrlaO8EkPHiPXK2dYBIefILXF/gEr9ZOMAkP3iNXayeYhAf3yNXaCabgd3J8VWvHV3iw4Cl3JTvBKtkJVr2dYAoePOWu1k4wCU8+wclOsEp2glWyE6ySnWCV7ASr1k4wCb/RlLtaO77CgwVPuSvZCVbJTrDq7QRT8OQpt7UTTMKTT3CyE6ySnWCV7ASrZCdYJTvBqrUTTMFbO77Es5dq7eyS8ODXUtXa2SXe7FRrZ5eEJ5+w1s4uCf+jJ+y1+T1/++NrO9ff4CwvnNMK52dNWRqneOFUL5wfPU2uFeofOLO8wWleON0LZ3jhTC+c5YVzWuH8rP1I4xQvnOqF4/Wp/MMWoXb+jlN6a29wuhfO8MKZXjjLC+e0wvlhY47EKV441Qvn8MLx+lSeXp/K0+tTeXp9Kk+vT+Xp9am8vD6Vl9en8g+bSvpoXzjrza7/h90jEqd54XQvnJ2+eWVtCAkPlvxNLWujiIK3NopIePBvP1Vro4j6ppa1UUTCt40+WncykFRrA4n8QCB/15psFKlko8jhbRS5/yg+yEaRw9ooIr4Vc5CNIsfL+QSX8OBvgh1ko8hhbRQJvgsd1gaS8GDJJ7i1sUTCg3vwg2wUObyNIuLu5G0UUfDkE9zaKCLhwa+lDrJR5CAbRQ6yUeQgG0UOa6OIeLNzWBtFJLzzCSvhwb8tdexkCDmsDSHhwYKn3AfZKHKQjSKHt1FEwYP31Ie1UUTCO5/g6uJHNoocZKPIQTaKHGSjyEE2ihzWRhEJv5EH+7A2kIQHC/ZmH9bGEgkP9mYf1sYSCQ/2Zh/NukdW8OQTvJNP8E6ecnfyN8E6+ZtgP+t8iYYn98h9pyl332nK3clT7k6ecg/ylHuQp9yDPOUe5Cn3D/uBYg/BQT7BB3nKPchT7kGecg9yjzzJPfLcaco9d5pyT/KU+4ddUsHw5Cn3JE+5J3nKPclT7kk+wRf5BF/kKfciT7kXecr9w16wYHhyj2ztHBO/9nJYO8QkvPMJK+GdT1gFb+0Ek/Dg35Y6rJ1gEp7yWuotvPMJK+Epr6XewpNPWGtnl4Qnn7DWzi4B36ydXRIefMI2a2eXhAefsO1FOWHfPOlt1s4uCb/RN7XaTo6vZu34EvP/RnZ2NbKzq5GdXc3b2XW/eWlkZ1ezdnaJQW4jO7sa2dnVyM6uRnZ2NbKzq5GdXc3a2RV9C7V2fIUHC/6mVrN2gkl48De1mrUTTMKDv6nVvJ1dCp58gls7uyQ8+JtazdrZJeHB39RqZGdXIzu7mrWzK/oWau34Cg+WPOW2doIpeGsnmIQnT7mtHV/q1urt7FLw5BPc2tkl4clTbmtnl4QnT7nJzq5GdnY1a2dX9C3U2vEVHix5ym3tBJPw5Cm3tRNMwpOn3N7OLgVPPsGtnV0SnjzltnZ2SXjylJvs7GpkZ1ezdnapJwDWzi4JD34t1aydXQre2tmlHl9YO7skvPVrqfV1n6/rzUeltVNLwjufsBLe+rWUgt9pj2zt4AoPlrxHtnZ2KXhrZ5eEJ++RrZ1dai5k7eyS8M4nuGozyc6uZu3skvDkPbK1s0vCk6fQ1s4uCb/THtna8RUeLHmPbO0Ek/DkPbK1E0zCk/fI1k4wCQ8+wbu1E0zCg/fI3doJJuHBe+T+cj5hJTy4R+47OcH6Tk6wTnaCdbITrJOdYJ3sBOtkJ1gnO8E62QnWyU6wTnaCdbITrJOdYJ3sBOtkJ1jfyQnWd3KCdbITrJOdYJ3sBOtkJ1gnO8E62QnWyU6wTnaCdbITrJOdYJ3sBOtkJ1gnO8G6tRNMPHvp1o4vCQ9+LdWtnV0K3trZJeHBr6W6tbNLwoNfS3VrZ5eEB7+W6tbOLgm/017Y2vEVHix5j2ztBJPw5D2yteNLwpP3yN7OLgVP7pGtnV0SnrxHtnZ2SXjyFJrs7OpkZ1e3dnZF30KtHV/hwVqf4OLuZO0Ek/DkPbK1E0zCk/fI1k4wBW/tBFOHoLUTTMKT98jWTjAJ73zCSnhyj2ztBJPwO025rR1f4cGSp9xkJ1gnO8G6txNMwZOn3NZOMAlPPsHJTrBOdoJ1shOsk51gnewE69ZOMAm/05Tb2vEVHqz1CS7uTmQnWCc7wbq3E0zBk6fc1k4wAT/ITrBBdoINshNskJ1g4+V8wkp4cI88rJ1gEh78WmpYO7skPPi11LB2dkl4ymupt/Dg11LD2tkl4Z1PWPFmZ1g7uyQ8+LXUsHZ2SfiN9sLD2vEVHay1E0yMVoa1E0zCg/fIg+zsGt7OLjHU8nZ2KXhyj2zt7JLw4D3yIDu7BtnZNcjOrkF2dg1rZ1f0LdTa8RUeLHiPPKydYBIevEce1k4wCU/eI1s7wSQ8+QS3doJJePIe2doJJuHJe2RrJ5iEJ/fIOzm+hrXjKzpYshNskJ1gg+wEG95OMAXvfIKrW6u1E0zCk09wshNskJ1gg+wEG2Qn2CA7wYa1E0zC7zTltnZ8hQdLnnKTnWCD7AQb3k4wBU+ecls7wSQ8+QQnO8EG2Qk2yE6wQXaCDbITbFg7wSQ8+bWUtbNLwVs7uyQ8+bWUtbNLwpNfS1k7uyQ8+bWUtbNLwpNfS1k7uyT8Tntha8dXeLDkPbK1E0zCk/fIZGfX8HZ2iaGWt7NLwZN7ZGtnl4QH75En2dk1yc6uSXZ2TbKza76cT9jgW+i0dnyFBwveI09rJ5iEB++Rp7UTTMFbO8HErXVaO8EkPPkEt3aCSXjnE1zCg/fI09oJJuHBPfK0doJJ+I2m3NPa8RUeLHjKPclOsEl2gk1vJ5iCB0+5p7UTTMKTT3CyE2ySnWCT7ASbZCfYJDvBprUTTMI7n7DRt1Brx1d4sOQpN9kJNslOsOntBBPwZCfYtHaCSXjyCU52gk2yE2ySnWCT7ASbZCfYtHaCSXjwa6lp7eyS8ODXUtPa2SXhKa+l3sI7n7DitdS0dnZJePBrqWnt7JLw4NdS09rZpeCtnV3RQyprx1d4sOQ9srUTTMI7n+ASHuzsmt7OLjHU8nZ2KXhyj2zt7FLw1s4uCU/eI5OdXZPs7JpkZ9e0dnZF30KtHV/hwZL3yNZOMAlP3iNbO8EkPHmPbO0Ek/DkE9zaCSbhyXtkayeYhCfvka2dYBKe3CPv5Pia1o6v8GDJU26yE2ySnWDT2wmm4MlTbmsnmIQnn+BkJ9giO8EW2Qm2yE6wRXaCrZfzCSvhN5pyL2vHV3iw4Cn3IjvBFtkJtrydYAoePOVe1k4wCU8+wclOsEV2gi2yE2yRnWCL7ARb1k4wBW/t+BLPXpa1s0vCg19LLWtnl4R3PmElPPi11LJ2dkl48GupZe3skvDg11LL2tkl4TfaCy9rx1d4sOA98rJ2gkl48B55kZ1dy9vZJYZa3s4uBU/uka2dXRKevEcmO7sW2dm1yM6uRXZ2LWtnV/Qt1NrxFR4seY9s7QRT8NZOMAkP/mWKZe0EU7dWayeYhCef4NZOMAlP3iNbO8EkPHmPbO0EU/DWTjAJv9OU29rxFR4secpNdoItshNseTvBFDx5ym3tBJPw5BOc7ARbZCfYIjvBFtkJtshOsGXtBJPwO025rR1f4cGSp9xkJ9giO8GWtxNMwZOn3NZOMAlPPsHJTrBFdoItshNskZ1gi+wEW9ZOMAlPfi1l7eyS8OTXUtbOLglPeS31Fp78Wsra2SXhya+lrJ1dAv60dnZJeOsTVsFvtBc+rR1f4cE6n+BitHJaO8EkPHiPfJKdXae3s+t+qHV6O7sEvLWzS/TIp7WzS8KD98gn2dl1kp1dJ9nZdZKdXae1syv6Fmrt+AoPFrxHPq2dYBIevEc+rZ1gEh68Rz6tnWASnnyCWzvBJDx4j3xaO8EkPHiPfFo7wSQ8uUfeyfF1Wju+woO1PsHF3YnsBDvJTrDT2wmm4MlTbmsnmIInO8FOshPsJDvBTrIT7CQ7wU6yE+y0doJJ+J2m3NaOr/BgyVNushPsJDvBTm8nmIInT7mtnWASnnyCk51gJ9kJdpKdYCfZCXaSnWCntRNMwoNfS53Wzi4J73zCSnjwa6nT2tkl4cGvpU5rZ5eEJ7+WsnZ2SXjyaylrZ5eE32kvbO34Cg+WvEe2doJJePIemezsOr2dXWKo5e3sUvDkHtna2SXhyXtksrPrJDu7TrKz6yQ7u05rZ1f0LdTa8RUdrLUTTN2drJ1gEp68R7Z2gkl45xNc3VqtnWASnnyCWzvBJDx5j2ztBLuHny9rJ5iE5/bIFzy3R77g95lyX8E6n8jhwXKn3Bc8d8p9wXOn3Bc8d8p9wXOn3PNl7QST8OQTHOwEu+C5U+4L3vlElvDcKfcFz+2RL3huj3zB7zPlvoLdZ8o9X2An2AXPnXJf8Nwp9wXPnXJf8M4nuLq1WjvBJDz5BAc7wS547pT7gidPucFOsAue3CNbO8EkPPe11AXvfMJKeO5rqQue+1rqgqe8lnoLz30tdcFbv5YS8NbOrvs3Oxc897XUBc99LXXBW5+wCt75hI0eUlk7vsKDJe+RrZ1gEp68RwY7u+bL29klhlrezi4FT+6RrZ1dEt75BJfw5D0y2Nl1wZOn0GBn1wW/017Y2vEVHix5j2ztBJPw5D2ytRNMwpP3yNZOMAlPPsGtnWASnrxHtnaCSXjyHtnaCSbhyT3yRo6vK9idptxgJ9gFT55yg51gFzx5yg12gl3w5Ck32Al2wZNPcLAT7IInT7nBTrALntwjWzvBJPxOU25rx1d4sOQpN9gJdsGTp9zeTjAFT55yWzvBJDz5BAc7wS548JS7kJ1ghewEK2QnWLF2gkl45xNWPHsp1s4uCQ9+LVWsnV0SnvJa6i08+LVUsXZ2SXjwa6li7eyS8ODXUsXa2SXhN9oLF2vHV3iw4D1ysXaCSXjwHrmQnV3F29l1P9Qq3s4uBU/uka2dXRIevEcuZGdXITu7CtnZVcjOrmLt7Iq+hVo7vsKDBe+Ri7UTTMI7n+ASHvzLFMXaCaZurdZOMAlPPsGtnWAK3toJJuHJe2RrJ5iEJ/fI1k4wCb/TlNva8RUeLHnKTXaCFbITrHg7wRQ8ecpt7QST8OQTnOwEK2QnWCE7wQrZCVbITrBi7QRT8Ds5voq14ys8WPKUm+wEK2QnWPF2gil48pTb2gkm4cknONkJVshOsEJ2ghWyE6yQnWDF2gkm4cmvpaydXRKe/FrK2tkl4Smvpd7BWzu71Gspa2eXhCe/lrJ2dkl45xNWwlufsAp+p72wteMrPFjyHtnaCabgrR1fEh7s7Crezi4x1PJ2dil45xNc9cjWzi4JT94jk51dhezsKmRnVyU7u6q1syv4FlqtHV/hwYL3yPXlfIJLePAeuVo7wSQ8eI9crZ1gEp58gls7wSQ8eI9crZ1gEh68R67WTjAJD+6R606Or2rt+AoPFjzlrmQnWCU7waq3E0zBg6fc1doJJuHJJzjZCVbJTrBKdoJVshOskp1g1doJJuF3mnJbO77CgyVPuclOsEp2glVvJ5iCJ0+5rZ1gEp58gpOdYJXsBKtkJ1glO8Eq2QlWrZ1gEh78WqpaO7skPPi1VLV2dil4a2eXhAe/lqrWzi4JD34tVa2dXRIe/FqqWju7JPxOe2Frx1d4sOQ9srUTTMKT98hkZ1f1dnaJoZa3s0vBk3tka2eXhCfvkcnOrkp2dlWys6uSnV3V2tkVfQu1dnyFB2t9gou7k7UTTMKT98jWTjAJT94jWzvBFLy1E0wdgtZOMAlP3iNbO8EkvPMJK+HJPbK1E0zC7zTltnZ8hQdLnnKTnWCV7ASr3k4wBU+ecls7wSQ8+QQnO8Eq2QlWyU6wSnaCHWQn2GHtBJPwG025D2vHV3iw1if4/d3pIDvBDrIT7PB2gil48JT7sHaCKXiyE+wgO8EOshPsIDvBDrIT7CA7wQ5rJ5iEB7+WOqydXRIe/FrqsHZ2SXjKa6m38ODXUoe1s0vCO5+w4s3OYe3skvDg11KHtbNLwm+0Fz6sHV/RwVo7wdRoxdoJJuHBe+SD7Ow6vJ1dYqjl7exS8OQe2drZJeHBe+SD7Ow6yM6ug+zsOsjOrsPa2RV9C7V2fIUHS94jWzvBJDx5j2ztBJPw5D2ytRNMwpNPcGsnmIQn75GtnWASnrxHtnaCSXhyj7yT4+uwdnxFB0t2gh1kJ9hBdoId3k4wBe98gqtbq7UTTMKTT3CyE+wgO8EOshPsIDvBDrIT7LB2gkn4nabc1o6v8GDJU26yE+wgO8EObyeYgidPua2dYBKefIKTnWAH2Ql2kJ1gB9kJdpCdYIe1E0zCk19LWTu7FLy1s0vCg39b6rB2dkl48glr7eyS8D96wtbXOn/741r+XQv+bzjDC2d64SwvnNMJp/2szUrj/OhpUsvxB84sb3CqF87hhdO8cLoXzvDCmV44ywvntML5WUORxvH6VP5hi1A7f8cpvbU3OIcXTvPC6V44wwtneuEsL5zTCueHrTYSp3jheH0qV69P5er1qVy9PpWr16dy9fpUrl6fytXrU/mHTSV9tC+ctd7gFC+c6oVzeOH87KfyR7951awNIeHBgr+p1ayNIhIe/E2tZm0UUfDWRhHxTa1mbRSR8Bv9MkXbyUDSrA0k8gMB/F3rRjaKNLJRpHkbRdRHMfi71s3aKCK+FdPIRpFGNoo0slGkkY0izdooEn0XsjaQhAdLPsGtjSUSntyDk40izdsoIu5O3kYRBU8+wa2NIhIe/FqqkY0ijWwUaWSjSCMbRZq1UUS82WnWRhEJD34t1ayNIhLe+YSN7rysDSHhwZKn3GSjSCMbRZq3UUTAk40izdooIuHJU26yUaSRjSKNbBRpZKNIIxtFmrVRRMJv5MFu1gaS8GDB3uxmbSyR8GBvdrM2lkh4sDe7ndY9soInn+An+QQ/wVPu/gJ/E6y/wN8E6y9wj9xf4B65v5xP2OBbaH9tNOXuL/CUu7/AU+7+Ak+5+ws85e4FPOXuBTzl7oV8ghfyCf7D7qFgePCUuxfwlLsXcI/cC7hH7mWjKXevG025ewVPuXsFT7l7BU+5+w97qoLhwVPuXsFT7l7JJ3gln+CVPOU+yFPugzzlPsg98kHuka2dY+LXXrq1Q0zCO5+wEt75hJXw4N+W6tZOMAVv7QST8JTXUm/hKa+l3sJTXku9hSefsNbOLglPPmGtnV0SnnzCWju7FLy1s0vCk09Ya2eXeNLbrZ1dEt75hI3epOzk+OrWji81/yc7uzrZ2dXJzq7u7ewSmxeys6tbO7vUIJfs7OpkZ1cnO7s62dnVyc6uTnZ2dWtnV/Qt1NrxFR4s+Zta1k4wCU/+ppa1E0zCk7+p5e3sUvDkE9za2SXhyd/UsnZ2SXjyN7XIzq5OdnZ1a2dX9C3U2vEVHix5ym3tBJPw5Cm3tRNMwVs7vtSt1dvZpeDJJ7i1s0vCO5/gEp485bZ2dkl4co9MdnZ1a2dX8C10WDu+woMFT7mHtRNMwoOn3OPlfIJLePCUe3g7uxQ8+AQf1s4uCQ+ecg9rZ5eEB0+5B9nZNcjOrmHt7BJPAIa1s0vCg19LDWtnl4SnvJZ68/hiWDu7FLy1g6uur/t8XW8+Kq2dWhLe+rWUgrd+LaXgnU/Y6DmPtYMrPFjwHnlYO7skPHiPPKydXQre2tml5kLWzi4JT+6Ryc6uYe3skvDgPfKwdnZJePIU2trZJeF32iNbO77CgyXvka2dYBKevEe2doJJePIe2doJJuHJJ7i1E0zCk/fI1k4wCU/eI1s7wSQ8uUfeyQk2dnKCDbITbJCdYIPsBBtkJ9ggO8EG2Qk2yE6wQXaCDbITbJCdYIPsBBtkJ9ggO8HGTk6wsZMTbJCdYIPsBBtkJ9ggO8EG2Qk2yE6wQXaCDbITbJCdYIPsBBtkJ9ggO8EG2Qk2rJ1g6tmLteNLwpNfS1k7uyQ8+LelhrWzS72WsnZ2SXjyaylrZ5eEJ7+WsnZ2Sfid9sLWjq/wYMl7ZGsnmIQH75GnteNLwoP3yNPb2aXgwT3yfDmf4BIevEee1s4uCQ+eQk+ys2uSnV3T2tkVfAud1o6v8GDBe+Rp7QST8M4nuIS33iMrePAeeVo7wSQ8+QS3doIpeGsnmIQH75GntRNMwpN7ZGsnmITfaMo9rR1f4cGCp9yT7ASbZCfY9HaCKXjylNvaCSbhySc42Qk2yU6wSXaCTbITbJKdYNPaCabgd3J8TWvHV3iw5Ck32Qk2yU6w6e0EU/DkKbe1E0zCk09wshNskp1gk+wEm2Qn2CQ7waa1E0zCg19LTWtnl4QHv5aa1s4uCU95LfUO3trZJV5LTWtnl4QHv5aa1s4uCe98wkp46xNWwe+0F7Z2fIUHS94jWzvBFLy140vCg51d09vZJYZa3s4uBe98gqse2drZJeHJe2Sys2uSnV2T7OyaZGfXtHZ2Rd9CrR1f4cGS98jWTjAJT94jWzvBJDx5j2ztBJPw5BPc2gkm4cl7ZGsnmIQn75GtnWASntwj7+T4mtaOr/BgyVNushNskZ1gy9sJpuDBU+5l7QST8OATfJGdYIvsBFtkJ9giO8EW2Qm2rJ1gEn6jKfeydnyFBwueci+yE2yRnWDL2wmm4MFT7mXtBJPw5BOc7ARbZCfYIjvBFtkJtshOsGXtBJPw4NdSy9rZJeHBr6WWtbNLwVs7uyQ8+LXUsnZ2SXjwa6ll7eyS8ODXUsva2SXhN9oLL2vHV3iw5D2ytRNMwpP3yGRn1/J2domhlrezS8GTe2RrZ5eEJ++Ryc6uRXZ2LbKza5GdXcva2RV9C7V2fIUHa32Ci7uTtRNMwpP3yNZOMAlP3iNbO8EUvLUTTB2C1k4wCU/eI1s7wSS88wkr4ck9srUTTMLvNOW2dnyFB0uecpOdYIvsBFveTjAFT55yWzvBJDz5BCc7wRbZCbbITrBFdoItshNsWTvBJPxOU25rx1d4sNYnuLg7kZ1gi+wEW95OMAVPnnJbO8EUPNkJtshOsEV2gi2yE2yRnWCL7ARb1k4wCU9+LWXt7JLw4NdSp7WzS8JTXku9hQe/ljqtnV0S3vmEFW92Tmtnl4QHv5Y6rZ1dEn6jvfBp7fiKDtbaCSZGK6e1E0zCg/fIJ9nZdXo7u+6HWqe3s0vBg3vk09rZJeHBe+ST7Ow6yc6uk+zsOsnOrtPa2RV9C7V2fIUHC94jn9ZOMAkP3iOf1k4wCQ/eI5/WTjAJTz7BrZ1gEh68Rz6tnWASHrxHPq2dYBKe3CPv5Pg6rR1f0cGSnWAn2Ql2kp1gp7cTTME7n+Dq1mrtBJPw5BOc7AQ7yU6wk+wEO8lOsJPsBDutnWASfqcpt7XjKzxY8pSb7AQ7yU6w09sJpuDJU25rJ5iEJ5/gZCfYSXaCnWQn2El2gp1kJ9hp7QST8ODXUqe1s0vBWzu7JDz5tZS1s0vCk19LWTu7JDz5tZS1s0vCk19LWTu7JPxOe2Frx1d4sOQ9srUTTMKT98hkZ9fp7ewSQy1vZ5eCJ/fI1s4uCU/eI5OdXSfZ2XWSnV0n2dl1Wju7om+h1o6v8GDJe2RrJ5iEJ++RrZ1g9/DrZe0Eu7+1XvDWPbKC557gFzz3BL/gnU9wCc/dI1/w3D3yBc/tkS94bo98we8z5V4va8dXeLDcKfcFz51yX/DcKfcF73yCS3julPuC5065L3jyCQ52gl3w3Cn3eoGdYBc8d8p9wZN7ZGsnmIR3PmGjb6HWjq/wYLlT7gueO+W+4LlT7guePOUGO8EuePKUG+wEu+DJJzjYCXbBk6fcYCfYBU/uka2dYBKe+1pqvaydXRKe+1rqgue+lrrgKa+l3sI7n7D3r6UueOvXUgqe+1rqgue+lrrgua+lLnjrE1bAWzu7oodU1o6v8GDJe2RrJ5iEdz7BJTzX2XXBk/fI3s4uBU/uka2dXQre2tkl4cl7ZLCz64InT6HBzq4Lfqe9sLXjKzxY8h7Z2gkm4cl7ZGsnmIQn75GtnWASnnyCWzvBJDx5j2ztBJPw5D2ytRNMwpN75I0cX1ewO025wU6wC5485QY7wS548pQb7AS74MlTbrAT7IInn+BgJ9gFT55yg51gFzy5R7Z2gkn4nabc1o6v8GDJU26wE+yCB0+5i7cTTMGDp9zF2gkm4cEneHmBT/BCdoIVshOskJ1ghewEK9ZOMAVv7fgSz16KtbNLwoNfSxVrZ5eEdz5hJTz4tVSxdnZJePBrqWLt7JLw4NdSxdrZJeE32gsXa8dXeLDgPXKxdoJJePAeuZCdXcXb2SWGWt7OLgVP7pGtnV0SHrxHLmRnVyE7uwrZ2VXIzq5i7eyKvoVaO77CgwXvkYu1E0zBWzvBJDz4lymKtRNM3VqtnWASnnyCWzvBJDx5j2ztBJPw5D2ytRNMwVs7wST8TlNua8dXeLDkKTfZCVbITrDi7QRT8OQpt7UTTMKTT3CyE6yQnWCF7AQrZCdYITvBirUTTMLvNOW2dnyFB0uecpOdYIXsBCveTjAFT55yWzvBJDz5BCc7wQrZCVbITrBCdoIVshOsWDvBJDz5tZS1s0vCk19LWTu7JDzltdRbePJrKWtnl4Qnv5aydnYpeGtnl4S3PmEV/E57YWvHV3iwzie4Gq1YO8EkPHmPTHZ2FW9nlxhqeTu77uGrtbNL9MjV2tkl4cF75Ep2dtWX8wkr4cFT6Ep2dlVrZ1fwLbRaO77CgwXvkau1E0zCg/fI1doJJuHBe+Rq7QST8OQT3NoJJuHBe+Rq7QST8OA9crV2gkl4co+8k+OrWju+woO1PsHF3YnsBKtkJ1j1doIpePCUu1o7wRQ82QlWyU6wSnaCVbITrJKdYJXsBKvWTjAJv9OU29rxFR4secpNdoJVshOsejvBFDx5ym3tBJPw5BOc7ASrZCdYJTvBKtkJVslOsGrtBJPw4NdS1drZJeGdT1gJD34tVa2dXRIe/FqqWju7JDz4tVS1dnZJePBrqWrt7JLwO+2FrR1f4cGS98jWTjAJT94jk51d1dvZJYZa3s4uBU/uka2dXRKevEcmO7sq2dlVyc6uSnZ2VWtnV/Qt1NrxFR2stRNM3Z2snWASnrxHtnaCSXjnE1zdWq2dYBKefIJbO8EkPHmPbO0EU/DWTjAJT+6RrZ1gEn6nKbe14ys8WPKUm+wEq2QnWPV2gil48JT7sHaCSXjwCX6QnWAH2Ql2vJxPZAkPnnIfZCfYYe0Ek/AbTbkPa8dXdLBkJ9hBdoIdZCfY4e0EU/DOJ7i6tVo7wSQ8+QQnO8EOshPsIDvBDrIT7CA7wQ5rJ5iEB7+WOqydXRIe/FrqsHZ2SXjKa6m38ODXUoe1s0vBWzu7xJudw9rZJeHBr6UOa2eXhHc+YaOHVNaOr/BgwXvkw9oJJuHBe+SD7Ow6vJ1dYqjl7exS8OQe2drZJeGdT3AJT94jk51dB9nZdZCdXYe1syv6Fmrt+AoPlrxHtnaCSXjyHtnaCSbhyXtkayeYhCef4NZOMAlP3iNbO8EkPHmPbO0Ek/DkHnknx9dh7fgKD5Y85SY7wQ6yE+zwdoIJeLIT7LB2gkl48glOdoIdZCfYQXaCHWQn2EF2gh3WTjAJv9OU29rxFR4secpNdoIdZCfY4e0EU/DkKbe1E0zCk09wshPsIDvBDrIT7CA7wQ6yE+ywdoJJeOcTVj17sXZ2SXjyaylrZ5eEp7yWegsPfi3VrJ1dEh78WqpZO7skPPi1VHtZn7AKfqO9cLN2fIUHC94jN2snmIQH75Eb2dnVvJ1d90Ot5u3sUvDgHrlZO7skPHiP3MjOrkZ2djWys6uRnV3N2tkVfQu1dnyFBwveIzdrJ5iEdz7BJTz4lymatRNM3VqtnWASnnyCWzvBFLy1E0zCg/fIzdoJJuHJPbK1E0zC7zTltnZ8hQdLnnKTnWCN7ARr3k4wBU+ecls7wSQ8+QQnO8Ea2QnWyE6wRnaCNbITrFk7wRT8To6vZu34Cg+WPOUmO8Ea2QnWvJ1gCp485bZ2gkl48glOdoI1shOskZ1gjewEa2QnWLN2gkl48GupZu3skvDg11LN2tkl4Smvpd7BWzu71Gspa2eXhCe/lrJ2dkl45xNWwlufsAp+p72wteMrPFjyHtnaCabgrR1fEh7s7Grezi4x1PJ2dil45xNc9cjWzi4JT94jk51djezsamRnVyM7u5q1syv6Fmrt+AoPlrxHtnaCSXjyHtnaCSbhyXtkayeYhAef4N3aCSbhwXvkbu0Ek/DgPXJ/OZ+wEh7cI/edHF/d2vEVHix4yt3JTrBOdoJ1byeYggdPubu1E0zCk09wshOsk51gnewE62QnWCc7wbq1E0zCbzTl7taOr/BgwVPuTnaCdbITrHs7wRQ8eMrdrZ1gEp58gpOdYJ3sBOtkJ1gnO8E62QnWrZ1gEh78WqpbO7skPPi1VLd2dok3O93a2SXhySestbNLwv/oCVtf6/ztj2v5dy34v+E0L5zuhTO8cKYXzvLC+dHTpJbjD5xZ/h7nZ41TGqd44VQvnMMLp3nhdC+c4YUzvXCWF47Xp/IPW4Ta+TtOua5ab3CKF071wjm8cJoXTvfCGV440wtneeGcVjjT61N5en0qT69P5en1qTy9PpWn16fy9PpUnl6fyj9sKrluEF84682u/4fdIwrnh20iEqd44ez0zStrQ0h4sM04WPV9IWujiIQnf1PL2igi4cnf1LI2iih4a6NI9EfrTgaSbm0gUR8IZKNIJxtFOtko0r2NIuqjmPxda2ujiPpWDNkoMshGkUE2igyyUWRYG0WC70Lj5XwihwcLPsGHtbFEwoN78EE2igxvo8j93Wl4G0UUPPkEtzaKSHjwa6lBNooMslFkkI0ig2wUGdZGEfFmZ1gbRRS8tVFEwoN/W2rsZAgZ1oaQ8GCdT3DVL5CNIoNsFBneRhEFD95TD2ujiIInG0UG2SgyyEaRQTaKDLJRZJCNIsPaKCLhN/JgD2sDSXiwYG/2sDaWSHiwN3tYG0skPNibPX7WbxINTz7BG/kEb+QpdwN/E2w08jfBOrlH7uQeue805e47Tbl/1oUTfHfq5Cl3J0+5O3nK3clT7k6ecg/yCT7IJ/ggT7kHecr9w16jYHhyjzzIPfLYaco9dppyD/KUe5Kn3JM85Z7kKfckT7l/2IEVDE8+wSf5BJ/kKfckT7knecq9yD3yIvfI1s4x8Wsvw9ohJuGdT1gJ73zCSnjwb0sNayeYhAf/ttSwdoIpeGsnmISnvJZ6C08+Ya2dXRKefMJaO7skPPmEtXZ2SXjyCWvt7BLw09rZJZ70Tmtnl4Tf6JtacyfH13w5n+Bi/j/Jzq5JdnZNsrNreju77jcvk+zsmtbOLjHInWRn1yQ7uybZ2TXJzq5JdnZNsrNrWju7om+h1o6v8GDB39Sa1k4wCQ/+pta0doJJePA3taa3s0vBk09wa2eXhAd/U2taO7skPPibWpPs7JpkZ9e0dnZF30KtHV/hwVqf4OLuZO0Ek/DkKbe1E0zCk6fc3s4uAW/t7FKHoLWzS8KTp9zWzi4J73zCSnhyj0x2dk1rZ1f0LdTa8RUeLHnKbe0Ek/DkKbe1E0zCk6fc3s4uBU8+wa2dXRKePOW2dnZJePKUm+zsmmRn17R2dqknANbOLgnvfMJKePBrqWnt7FKPL6ydXRLe+rXU+rrP1/Xuo9L6tZSAt3ZqSXjr11IKfqc9srWDKzxY5xNcTSesnV0SnrxHtnZ2SXjyHtna2aXgyc6uSXZ2TWtnl4Qn75GtnV0SnjyFtnZ2Sfid9sjWjq/wYMl7ZGsnmIQn75GtnWASnrxHtnaCSXjyCW7tBJPw5D2ytRNMwoP3yMvaCSbhwT3y2skJtnZygq2X9Ql+f3daZCfYIjvBFtkJtshOsEV2gi2yE2yRnWCL7ARbZCfYIjvBFtkJtshOsLWTE2zt5ARbZCfYIjvBFtkJtshOsEV2gi2yE2yRnWCL7ARbZCfYIjvBFtkJtshOsEV2gi1rJ5h49rKsHV8S3vmElfDg11LL2tkl4cGvpZa1s0vCg19LLWtnl4QHv5Za1s4uCb/TXtja8RUeLHmPbO0Ek/DkPbK140vCk/fI3s4uBU/uka2dXRKevEe2dnZJePIUmuzsWmRn17J2dkXfQq0dX9HBWjvB1N3J2gkm4cl7ZGsnmIR3PsHVrdXaCSbhySe4tRNMwpP3yNZOMAVv7QST8OQe2doJJuF3mnJbO77CgyVPuclOsEV2gi1vJ5iCJ0+5rZ1gEp58gpOdYIvsBFtkJ9giO8EW2Qm2rJ1gEn6nKbe14ys6WLITbJGdYIvsBFveTjAF73yCq1urtRNMwpNPcLITbJGdYIvsBDvJTrCT7AQ7rZ1gEh78Wup8OZ+wEh78Wuq0dnZJeMprqbfw4NdSp7WzS8FbO7vEm53T2tkl4cGvpU5rZ5eEdz5hg4dUp7XjKzxY8B75tHaCSXjwHvkkO7tOb2fX/VDr9HZ2KXhyj2zt7JLwzie4hAfvkU+ys+skO7tOsrPrtHZ2Rd9CrR1f4cGC98intRNMwoP3yKe1E0zCg/fIp7UTTMKTT3BrJ5iEJ++RrZ1gEp68R7Z2gkl4co+8k+PrtHZ8hQdLnnKTnWAn2Ql2ejvBBDzZCXZaO8EkPPkEJzvBTrIT7CQ7wU6yE+wkO8FOayeYhN9pym3t+AoPljzlJjvBTrIT7PR2gil48pTb2gkm4cknONkJdpKdYCfZCXaSnWAn2Ql2WjvBJLzzCauevVg7uyQ8+bWUtbNLwlNeS72FJ7+WsnZ2SXjyaylrZ5eEJ7+WsnZ2Sfid9sLWjq/wYMl7ZGsnmIQn75HJzq7T29klhlrezi4FT+6RrZ1dEp68RyY7u06ys+skO7tOsLPrfFk7u2JvoVewzidyeLDcPfIFz90jX/DOJ7iE5/4yxQXP3SNf8NY9soLnnuAXPPkEt3aCSXjuHvmC5+6RL3huj3zBO5+wEn6fKfcV7D5T7itY7pT7gudOuS947pT7fHk7wRQ8d8p9wXOn3Bc8+QQHO8EueO6U+4LnTrkveO6U+4In98jWTjAFv5Hj6wp2pyk32Al2wZOn3GAn2AVPnnKDnWAXPHnKDXaCXfDkExzsBLvgyVNusBPsgif3yNZOMAnPfS11wXNfS13w3NdSFzz3tdQFT3kt9Q7e2tl1/1rqgrd+LaXgua+lLnjua6kL3vmElfDWJ6yC32kvbO34Cg+WvEe2doIpeGvHl4TnOrsuePIe2dvZpeCdT3DVI1s7uyQ8eY8MdnZd8OQpNNjZdb7Azq4Lfqe9sLXjKzxY8h7Z2gkm4cl7ZGsnmIQn75GtnWASnnyCWzvBJDx5j2ztBJPw5D2ytRNMwpN75I0cX1ewO025wU6wC5485QY7wS548pQb7AS74MlTbrAT7IInn+BgJ9gFT55yg51gFzy4Ry7WTjAJv9GUu1g7vsKDBU+5y8v5BJfw4Cl38XaCKXjwlLtYO8EkPPkEJzvBCtkJVshOsEJ2ghWyE6xYO8EkPPi1VLF2dkl48GupYu3sUvDWzi4JD34tVaydXRIe/FqqWDu7JDz4tVSxdnZJ+I32wsXa8RUeLHiPXKydYBIevEcuZGdX8XZ2iaGWt7NLwZN7ZGtnl4QH75EL2dlVyM6uQnZ2FbKzq1g7u6JvodaOr/BgrU9wcXeydoJJePIe2doJJuHJe2RrJ5iCt3aCqUPQ2gkm4cl7ZGsnmIR3PmElPLlHtnaCSfidptzWjq/wYMlTbrITrJCdYMXbCabgyVNuayeYhCef4GQnWCE7wQrZCVbITrBCdoIVayeYhN9pym3t+AoP1voEF3cnshOskJ1gxdsJpuDJU25rJ5iCJzvBCtkJVshOsEJ2ghWyE6yQnWDF2gkm4cmvpaydXRKe/FrK2tkl4Smvpd7Ck19LWTu7JLzzCave7Fg7uyQ8+bWUtbNLwu+0F7Z2fAUHW62dYGK0Uq2dYBIevEeuZGdXfTmf4GKoVb2dXQoe3CNXa2eXhAfvkSvZ2VXJzq5KdnZVsrOrWju7om+h1o6v8GDBe+Rq7QST8OA9crV2gkl48B65WjvBJDz5BLd2gkl48B65WjvBJDx4j1ytnWASntwj7+T4qtaOr+hgyU6wSnaCVbITrHo7wRS88wmubq3WTjAJTz7ByU6wSnaCVbITrJKdYJXsBKvWTjAJv9OU29rxFR4secpNdoJVshOsejvBFDx5ym3tBJPw5BOc7ASrZCdYJTvBKtkJVslOsGrtBJPw4NdS1drZpeCtnV0SHvxaqlo7uyQ8+LVUtXZ2SXjwa6lq7eyS8ODXUtXa2SXhd9oLWzu+woMl75GtnWASnrxHJju7qrezSwy1vJ1dCp7cI1s7uyQ8eY9MdnZVsrOrkp1dlezsqtbOruhbqLXjKzxY8h7Z2gkm4cl7ZGsnmIK3doKpW6u1E0zCk09wayeYhHc+wSU8eY9s7QST8OQe2doJJuE3mnIf1o6v8GDBU+6D7AQ7yE6w4+V8gkt48JT7sHaCSXjwCX6QnWAH2Ql2kJ1gB9kJdpCdYIe1E0zCO5+w0bdQa8dXeLDgKfdBdoIdZCfY4e0EE/BkJ9hh7QST8OQTnOwEO8hOsIPsBDvITrCD7AQ7rJ1gEh78WuqwdnZJePBrqcPa2SXhKa+l3sI7n7DitdRh7eyS8ODXUoe1s0vCg19LHdbOLgVv7eyKHlJZO77CgyXvka2dYBLe+QSX8GBn1+Ht7BJDLW9nl4In98jWzi4Fb+3skvDkPTLZ2XWQnV0H2dl1WDu7om+h1o6v8GDJe2RrJ5iEJ++RrZ1gEp68R7Z2gkl48glu7QST8OQ9srUTTMKT98jWTjAJT+6Rd3J8HdaOr/BgyVNushPsIDvBDm8nmIInT7mtnWASnnyCk51gB9kJdpCdYAfZCXaQnWCHtRNMwu805bZ2fIUHS55yk51gB9kJdng7wRQ8ecpt7QST8OQTnOwEO8hOsIPsBDvITrCD7AQ7rJ1gAr5ZO77Es5dm7eyS8ODXUs3a2SXhnU9YCQ9+LdWsnV0SHvxaqlk7uyQ8+LVUs3Z2SfiN9sLN2vEVHix4j9ysnWASHrxHbmRnV/N2dt0PtZq3s0vBk3tka2eXhAfvkRvZ2dXIzq5GdnY1srOrWTu7om+h1o6v8GDBe+Rm7QRT8NZOMAkP/mWKZu0EU7dWayeYhCef4NZOMAkP3iM3ayeYhAfvkZu1E0zBWzvBJPxOU25rx1d4sOQpN9kJ1shOsObtBFPw5Cm3tRNMwpNPcLITrJGdYI3sBGtkJ1gjO8GatRNMwu805bZ2fIUHS55yk51gjewEa95OMAVPnnJbO8EkPPkEJzvBGtkJ1shOsEZ2gjWyE6xZO8EkPPm1lLWzS8KTX0tZO7skPOW11Ft48mspa2eXhCe/lrJ2dil4a2eXhLc+YRX8Tntha8dXeLDOJ7garVg7wSQ8eY9MdnY1b2eXGGp5O7sEvLWzS/XI1s4uCU/eI5OdXY3s7GpkZ1cjO7uatbMr+hZq7fgKDxa8R+7WTjAJD94jd2snmIQH75H7y/kEl/DgE7xbO8EkPHiP3K2dYBIevEfu1k4wCQ/ukftOjq9u7fgKD9b6BBd3J7ITrJOdYN3bCabgwVPubu0EU/BkJ1gnO8E62QnWyU6wTnaCdbITrFs7wST8RlPubu34Cg+WPOUmO8E62QnWvZ1gCp485bZ2gkl48glOdoJ1shOsk51gnewE62QnWLd2gkl48Gupbu3skvDOJ6yEB7+W6tbOLgkPfi3VrZ1dEh78WqpbO7skPPi1VLd2dkn4nfbC1o6v8GDJe2RrJ5iEJ++Ryc6u7u3sEkMtb2eXgif3yNbOLglP3iOTnV2d7OzqZGdXJzu7urWzK/oWau34ig7W2gmm7k7WTjAJT94jWzvBJLzzCa5urdZOMAlPPsGtnWASnrxHtnaCKXhrJ5iEJ/fI1k4wCb/TlNva8RUeLHnKTXaCdbITrHs7wRQ8ecpt7QST8OQTnOwE62QnWCc7wTrZCdbJTrBu7QST8DtNua0dX8HBDrITbJCdYIPsBBveTjAF73yCi1vrsHaCSXjwCT7ITrBBdoINshNskJ1gg+wEG9ZOMAkPfi01rJ1dEh78WmpYO7skPOW11Ft48GupYe3sUvDWzi7xZmdYO7skPPi11LB2dkl45xM2ekhl7fgKDxa8Rx7WTjAJD94jD7Kza3g7u8RQy9vZpeDJPbK1s0vCO5/gEh68Rx5kZ9cgO7sG2dk1rJ1d0bdQa8dXeLDkPbK1E0zCk/fI1k4wCU/eI1s7wSQ8+QS3doJJePIe2doJJuHJe2RrJ5iEJ/fIOzm+hrXjKzxY8pSb7AQbZCfY8HaCCXiyE2xYO8EkPPkEJzvBBtkJNshOsEF2gg2yE2xYO8Ek/E5TbmvHV3iw5Ck32Qk2yE6w4e0EU/DkKbe1E0zCk09wshNskJ1gg+wEG2Qn2CA7wYa1E0zCO5+w6tmLtbNLwpNfS1k7u9SbHWtnl4Qnn7DWzi4J/6MnbH2t87c/ruXfteD/hlO9cA4vnOaF071whhfOj54mtRx/4MzyBmd54ZxOOPNnrU0ap3jhVC+cwwuneeF0L5zhhWP1qTx/1iJ01NfXP1xf/Q3OaYXzs6af6w/G7/9wb+cbnOKFU71wDi+cH/1UPsbr+P0fHuUdTv/Z7Mz1hdNUk1iuf/r3j6lyvF71Df5g4082/mLjn9b4Y93j1xcbvxjjH69e/sAf7/ArG/9g4zc2vvOpe7y+rjD/in/I/6rP9hVunaOov+9jfv19H+tdepxPdYP0ON8aDNLjfCv5p6fnuhZ8pWceb1r76nzr+Xx6DudblUF6vG9t/+z0tPFHet4d7If3rfDj6fG+dX48PS3Tc5eerW/NOj1b35p1era+Nev07H1rXn80FfN8l569b80qPW3vW7NMz963ZpmerW/N6zW/0rNqe5OerW/NOj0t03OXnq1vzTo9W9+adXq2vjXr9Gx9a17t+CM9/V16tr41y/T0rW/NOj1b35p1eva+NY/zj/Ss8SY9e9+aZXpapucuPXvfmmV69r41y/TsfWuW6dn71izTs/etWfVcY+9bs0xPfkPj91nzuz3XyG9o3KbnZ2/N6nnKz1pFNc6zboXH8afiOWXxKPHgHM+6FYan51m3wvD0POtWGJ6eZ90KfzE9pfyxQy717wWQcz7rVhienmfdCsPT86xb4a+mZ/4xai7n6016njVLDU9Py/TcpWfrW7P+7Mlb892952f9wrIF/FljsMbxvhWu9lU8RUoBSyuvr9FoK63/fbjL+5YXHq73re1Xwx1/Cne9eVy2vG9h4eF636rCw217het96/nVcP9QGlzh6r+/tlhff3++W3It71vPx9PjPSv8eHq8Z4X/3PT0V21/3JmPd/eGZ90Ko9NzPusWGZ6eZ906fzU9q/+RnvPNZ8/5rFtqeHqedasNT0/L9NylZ+dbcy/tjy/3lP5mVnjufGv+Rnp2vjV/Iz1b35pVetbL+uS6dgd/pKe/3uBbnywa/4c/+fvv85srkv4G52c/acf4I5urvcGZXjg/+0myyvnHPzze4JxWOD/sh5c4xQvnZ/un9fW7VMc65xucwwuneeF0L5zhhTO9cJYXzmmF88O+dIlTvHC8PpWr16dy9fpUrl6fytXrU7l6fSpXr0/l6vWpfHh9Kh9en8qH16fy4fWpfHh9Kh9en8qH16fy4fWpfHh9Kh9en8rN61O5eX0qN69P5eb1qdy8PpWb16dy8/pUbl6fys3rU7l5fSp3r0/l7vWp3L0+lX/WP9Ze4/dtaCv1eIPTvHC6F87wwpleOMsL57TC+VkfkcYpXjjVC8frU3l4fSoPr0/l4fWpPLw+lYfXp/Lw+lSeXp/KP+vfaOX4/dV2qy+pBZt/UhLO83ipv3/N/vXI+zXnm+94/KxP4/PhHnuF2/YKtz8p3PXH85/XNf55E+7YK9y5V7hrr3DPR4Xbxx/hjjfh/qwf4/PhPupWpcN91K1qnV/mn9f5ehfuo25VOtz2pHDPo/wRbitvwn3UrUqH+6hblQ73Ubeq849nq6/zfPNaaD3qVqXDfdStSoZ7PupWpcN90jXjXw/e3//++n/1TbhPumZ8I9z23HDPN+E+6ZrxjXCfdM34RrhPumZ8I9wnXTO+Ee6Trhky3PP1pGvGN8J90vDmG+E++Fb1LtwH36rehdv2CnerW9X52upWdb62ulWdr61uVedrr1tV2etWVZ57q6r9TbiPulX9SWlWypsN4FkedavS4bYnhVv7lwKt1PmumB91q9LhPupWpcN91K1Kh/uoW5UO91G3KhlufdSt6nh9fTejHGW9CfdRtyr9n+6jblU63EfdqnS4ba9wH3Wr0h9Ve92q6l63qrrXrarudas69rpVHXvdqo69blXHXreqn5XRfT7cvW5Vx163qmOvW9Wx163q2OtW1fa6VbW9blVtr1tV2+tW9bMyyc+Hu9etqu11q2p73araXreqttetqu91q+p73ar6Xreqvtet6odlsB8Pd69bVd/rVtX3ulX1vW5Vfa9b1djrVjX2ulWNvW5VY69b1Q/LnD8e7l63qrHXrWrsdasae92qxl63qrnXrepRsvFv/Ke7163qUbLxb4Tb9gp3r1vVo2Tj3/hPd69b1aNk498Id69b1aNk4/qj6lGy8W/8p7vXrepRsvFvhNv2CnevW5W3bPzi+x1/vcah/r6+Xl+akPp6J4Hxlo3Hh2t9q/rVcMvx9fNLtfT2JlzrW1V4uN6y8fhwrW9V8eFa36p+Ndz6x9/X45jq749evtJz9NbU3/fZvn4Rp89R36TT+tbGS2fLdEam0/rWyUvno261n0/no27Nn0/no27ln0/no279/+x0rtf8Sueqf3fvLK+X948LAPP5qL7FIJ/ZGMXmMzuj2Hy2zGdoPrM3+pV8/rEh6GuNd/nM5ig2n9kdxeYz26PYfGZ/FJpP758JAebzWf1R+7rP1Nrnu3if1b/oeJ/VX+h422bxbn0/b/OPz8N2vv182/q+/Y38bH1//kZ+tr4PfyM/W99v23iJ/Hj/AItBfraez38jP1vP27+Rn73n50f5Uz94vMtPy/zc5mfv+bbOz97zap2fnD//wjxqzK989rHqu3zm/Dk2nzl/Ds2n90//2H19rH7d3/o8yrt85vdzYvOZ38+JzWd+Pyc2ny3z+Qv5XH+cR/N8ex7l93Ni85nfz4nNZ/ZHsfnM/ugX8rna19/31d99v9H7N7Z4+fT+ES9gPrM/is1n9ke/kk/5/THv3znjfd/e+4fUgPnM/uhX7p/3zz3/NZ/ZH8Xmcycn0r/G+6j+5Rvxbt1fjPL198c43tW/98/TGeRn6/v/N/Kz9X3+G/l51P38mH98H/44330fw/sn8/4J8T7qfvuNeB91//xGvM+an5ev/WCt2qDar+vB1/35Nd7NH7x/Zs8gP8+6f4bnx/uH/Azys9n7UO+f/vsnxLvZ+1DvH//7J8Sb70N/64/evx/x/rlAg/zk+9D7/OT70Pv87P0+VObH+ycPDfKT70Pv85PvQ+/zs/X3E76Rn5b5uc1Pvg/9LT/v3z96/zCkQX72/v6zzs/e32fW+cnvJ3/lJ+L9pvePYQLzmd9Pjs1nfj/5F/Kp3xt6/14oMJ8t8xmaz/x+cmw+8/vJv5JP+d7wWb/ZapDPfL8Zm8/sj0Lz+ayftf38e8Nn/W6uQT6zP4rNZ/ZHsflsmc9fyKd8X5y/zftL+ZTvYfPHeYPzmf3Rr9w/5XvY/Hne4Hw+qj+S723Ls34/9xvx5vvQ3/778vb9Y9n792q/kZ+t7//fyE/L/Nzm51n38/Wn95itvYv3WfdnHe+z7rc63mfdP3W8z5qfy3gf9vuhOt5H3Q/le/nyrN/3/Ea8e/k9yrN+3/Mb8T7rfhX9Pr087Pc94/OT/pD7/KQ/5D4/6Q+5zc/Dft9T+QTKw36vU8e7lw+kPOz3NHW8Ld9f/9t87+37x7L372N+Iz/pD7nPT/pD7vOT/pD7/KQ/5DY/e/8epXy/X/b+fclv5Cf9Iff5SX/IfX5avt//t/y8fb9fNv99Rp2f9Ifc5yf9Iff5ye+LfuUnwD9Q8vcQY/OZv4cYnM98T/cL+ZTv5Uv+HmJwPvM9XWw+W+YzNJ/5nu5X8qney5f8PcTgfOZ7uth8Zn8Um8/sj34hn/K9fNn79x//CfnM/ig2n9kfxeYz+6NfyafyY5Rn/d7lx30O5Vm/p2mQz+yPfuX+qXwO5WG/B/r5fO71e/TlWb8HquN92O97hr/ff9jve8bnJ/0h9/lJf8h9ftpe780f9nujOt7NfCAP+z1QHe9mPpCH/V6njPdZv7+pfQLP+j3Nb8S7mQ/kWb93+Y14W75P/7f5xvv36Q/7/cr4/KQ/5D4/6Q+5z0/6Q+7z86z7pPQJPOz3JXW8m/lAHvb7jDrevd8/yvfXe/8e4jfyk/6Q+/ykP+Q+P3v7Q+T7671/T/Ab+dnbHyLzs/fv/X0jP3t/n1a+v9789/h0fvb+vqvOT8v83OYnv4/6lZ+I9+P5+3fB+czvo8bmM9/r/UI+9XvnZ/3+3cfzWZ/1+3oG+cz3erH5zPd6v5JP9d657v37gP+EfLbMZ2g+sz+KzWf2R7+QT/neuT7s9xM/n8/sj2Lzmf1RaD4f9vuSn/Yb1Gf9fuXH3+PXZ/0+pkE+sz/6lfuneo9fn/X7ngb5fFR/JN/712f9Hug34t26v5Dvr+vDft8zPj9b3/91fh72+57x+XnW/Vy9F64P+z1QHe+z7rc63rZZvHv5OurDfq9Tx/uo+2E7/oi3zde7eB913/tGvI+6v/Vav+Ltx3oT77N+7/Ib8T7qfvWNeB91v/pGvI+6X/U/+Tr6+e7z6lm/F9nHoeJ91P3qG/X8qPvVN+J91P3qG/E+6n71jXifdb+Sn8/P+r1C/fn8rN8T1PX8rN/7+0a8z7pf6XjbZvE+636lP5+fdb/Sn8+b3a+e9Xtt34h3s/nVs37v7BvxPut+JT+fn/V7Yfrz+Vm/5/WNem6bxbvZ/OpZv1f1jXifdb/Sn8/Pul/pz+fN7lfP+r2nb8S72fzqWb/H9I14N9sPPuv3kvTn87N+L+kb9bzZ/epZv5f0jXg3m1896/eS9Ofzs34vSX8+P+v3knQ9P+v3kr4R72bzq2f9XtI34t1sP/is3zP6xufzZverZ/3e0Dfi3Wx+9azfD/pGvJvtB5/1+0H68/lZvx/0jXpum8W72fzqWb/X8414N9sPPuv3dL7x+bzZ/epZv3fzjXg3m1896/dovhHvZvvBZ/1ejP58ftbvv3yjnje7Xz3r91O+Ee9m86tn/f6I/Hw+nvX7IPLz+XjW73fIej6e9fsa34h3r/nV8WqbxbvXfvB41u87fOPzea/71fGs30f4Rrx7za+OZ/2+wDfi3Ws/eDzLz68/n639+at+cZR1XY3e8Tc4v/P9Zx3Hn/jn8Y7f+T7zHX7n+8k6zv7F38rbz2fn+8Z3+J3vD6v9qX5af/P7OMcP+8lrqV/8rUr+Wf7I/+zlHX+B81c4/wHnb3D+DucfcP4J519w/tOZf7U/zt8rAPH34/z6uZ5xlj/9usb55o9X/fq3V/3zTzedv2XmsD7ZP5oZ6zvDRzNjfRv5aGas7zkfzUzLzPxFZqzvZh/NjPWt76OZsb5PfjQz1jfVj2Ym78B/kZmWd+C/ykzegf8qM3kH/qvM5B34rzLTMjN/kZm8A/9VZvIO/FeZyTvwX2Um78B/lZm8A/9FZnregf8qM3kH/qvM5B34rzKTd+C/ykzLzPxFZvIO/FeZyTvwX2Um78B/lZm8A/9VZvIO/BeZGXkH/qvM5B34rzKTd+C/ykzegf8qMy0z8xeZyTvwX2Um78B/lZm8A/9VZvIO/FeZyTvwX2Rm5h34rzKTd+C/ykzegf8qM3kH/qvMtMzMX2Qm78B/lZm8A/9VZv7hO/Acv/9tW8d5n5lS5teDq3L+ib283mbmT4mZ55/++l2odazfs17n608uh7J+j3U9JtZVfy/Hunr/m1j//q/7/N1y0c/zTQmcz0nLV6T1/PPz9f8rafnHf+nCJi1nPb/SMvub/2b8479ywfkU+Md/4eKRnwL/+A9hPPNToG30KdA3+hQY+Snwrtyfcx0M/RR4zs1Rfwo85zooPwXO59zxIj8FzudcByM/Bc7n3Bzlp8D5nOug/hRo+Snwrtyfcx0M/RR4zs1RfwpsNB08czr4ttxzOvgmLe21z3SwvfaZDrZXTgfflntOB9+mpW30KbDPdLC9cjr4ttxzOvg2LftMB9trn+lgKzkdfFfuJaeDb9Oyz3SwlX2mg+0f/wWVZ34K5HTwbVr2mQ62ss90sJWcDr4t95wOvktL3Wg6WDeaDtacDr4t95wOvk1L2+hTYKPpYM3p4Ntyz+ng27RsNB2sG00Hj5wOviv3I6eDb9Oy0XTw2Gg6+I//OtEzPwVyOvg2LRtNB4+NpoNHTgfflntOB9+lpW00HWwbTQdbTgfflntOB9+mpW30KbDRdLDldPBtued08G1aNpoOtp+9Dtb5O085XkPEWl/j6z/U11jir1f//UNgzfU3efm3SPtrm0jLUyI9X+u3P/4bq9YfkdZtIj22ibRtE2l/TKRfh9L5N3eSr0jHNpHObSJd20T6mDvSecyvSMebSMdj7kgy0sfckdRtcDzmjiQjfcwd6U+RrrfV27aJ9Dl3JHEbHM+5I6lIn3NHUpE+546kIn3OHUncBudz7kgq0ufMkVSkz5kjqUifM0cSN/x//DcpMJE+5o6kbvjzMXckGelj7kjqhj8fc0eSkT7njiRug+s5dyQV6Ta7trXNrm09544kboM//EsKn4x0m13b2mbXtp4zRxI3/PWcOZKKdJvvI53bfB/pfOKu7e0N/3ziru19pNt8H+mHf4ngk5Fus2s7t9m1ndt8H+nc5vtI5y67tv7aZdfWX8+ZI93f8PvrOXMkFekTv4/07obfX22bSJ+4a1tvq/eJu7b3ke7yfaT+2uX7SP21y66tl112bb3s8n2kXnb5PlIvu+za+g876z8Z6XPmSOKGX54zR1KRPvH7SG9v+OWJ30d6H+kTd21vb/j1ibu295Hu8n2kXnf5PlKvu+za+g/b2T8Z6S7fR+p1l+8j9brLrq3XXXZtve7y9r8fu7z978cub//7scvb/37s8va//7Dd/JOR7vJ9pH7s8n2kfmyzazu22bUd23wfqW3zfaS2za6tbbNra7u8/e8/7PH+ZKS7vP3vbZe3/73t8va/t13e/vfneLbVbfA5nm0Z6Ta7tm082/1Bnm1xG3yQZ1tFus2ubRvPdn+QZ1vc8B/k2VaR7vL2vz/Hsy0j3eXtf3+kZ/t9pNt8H+k5nm0Z6Ta7tm082/1Bnm1xG3yQZ1tFus2ubRvPdn+QZ1vc8B/k2VaRbvP2/zmebRnpNm//H+nZfh/pNt9Heo5nW0a6za5tG892f5BnW9wGH+TZVpFus2vbxrPdH+TZFjf8B3m2VaTbvP1/jmdbRrrN2/9HerbfR7rN95Ge49mWkW6za9vGs90f5NkWt8EHebZVpNvs2rbxbPcHebbvb/jjQZ5tFekub//HczzbMtJd3v6PV9sm0l2+jzSe49mWke6yaxvbeLbHgzzb97fB8SDPtop0l13b2MazPR7k2RY3/Ad5tlWku7z9H8/xbMtId3n7Px7p2X4f6S7fRxrP8WzLSHfZtY1tPNvjQZ5tcRt8kGdbRbrLrm1s49keD/Jsixv+gzzbKtJd3v6P53i2ZaS7vP0fj/Rsv490l+8jjed4tmWk2+zatvFsjwd5tsVt8EGebRXpNru2bTzb40GebXHDf5BnW0W6y9v/8RzPtox0l7f/45Ge7feRbvN9pOd4tmWk2+zatvFsjwd5tsVt8EGebRXpNru2bTzb40GebXHDf5BnW0W6y9v/8RzPtox0l7f/45Ge7feRbvN9pOd4tmWk2+zatvFsjwd5tsVt8EGebRXpNru2bTzb40GebXHDf5BnW0W6zdv/53i2ZaTbvP1/pGf7faTbfB/pOZ5tGek2u7ZtPNvjQZ5tcRt8kGdbRbrNrm0bz/Z4kGdb3PAf5NlWkW7z9v85nm0Z6TZv/x/p2X4f6TbfR3qOZ1tGus2ubRvP9niQZ1vcBh/k2VaRbrNr28azPR7k2RY3/Ad5tlWku7z9n8/xbMtId3n7Px/p2X4f6S7fR5qvtk2ku+za5jae7fkgz/b9bXA+yLOtIt1l1za38WzPB3m272/480GebRXpLm//53M82zLSXd7+z0d6tt9Husv3keZzPNsy0l12bXMbz/Z8kGdb3AYf5NlWke6ya5vbeLbngzzb4ob/IM+2inSXt//zOZ5tGekub//nIz3b7yPd5ftI8zmebRnpNru2bTzb80GebXEbfJBnW0W6za5tG8/2fJBnW9zwH+TZVpHu8vZ/PsezLSPd5e3/fKRn+32k23wf6TmebRnpNru2bTzb80GebXEbfJBnW0W6za5tG8/2fJBnW9zwH+TZVpHu8vZ/PsezLSPd5e3/fKRn+32k23wf6TmebRnpNru2bTzb80GebXEbfJBnW0W6za5tG8/2fJBnW9zwH+TZVpFu8/b/OZ5tGek2b/8f6dl+H+k230d6jmdbRrrNrm0bz/Z8kGdb3AYf5NlWkW6za9vGsz0f5NkWN/wHebZVpNu8/X+OZ1tGus3b/0d6tt9Hus33kZ7j2ZaRbrNr28azPR/k2Ra3wQd5tlWk2+zatvFszwd5tsUN/0GebRXpNm//n+PZlpHu8vZ/PdKz/T7SXb6PtJ7j2ZaR7rJrW6+2TaS7fB9pPcizrSLdZde2tvFsrwd5tu9v+OtBnm0V6S5v/9dzPNsy0l3e/q9HerbfR7rL95HWczzbMtJddm1rG8/2epBnW9wGH+TZVpHusmtb23i214M82+KG/yDPtop0l7f/6zmebRnpLm//1yM92+8j3eX7SOs5nm0Z6Ta7tm082+tBnm1xG3yQZ1tFus2ubRvP9nqQZ1vc8B/k2VaR7vL2fz3Hsy0j3eXt/3qkZ/t9pNt8H+k5nm0Z6Ta7tm082+tBnm1xG3yQZ1tFus2ubRvP9nqQZ1vc8B/k2VaR7vL2fz3Hsy0j3eXt/3qkZ/t9pNt8H+k5nm0Z6Ta7tm082+tBnm1xG3yQZ1tFus2ubRvP9nqQZ1vc8B/k2VaR7vL2fz3Hsy0j3ebt/yM92+8j3eb7SM/xbMtIt9m1bePZXg/ybIvb4IM82yrSbXZt23i214M82+KG/yDPtop0m7f/z/Fsy0i3efv/SM/2+0i3+T7SczzbMtJtdm3beLbXgzzb4jb4IM+2inSbXds2nu31IM+2uOE/yLOtIt3m7f9zPNsy0m3e/j/Ss/0+0l2+j3Q+x7MtI91l13Zu49k+H+TZvr8Nnq+2TaS77NrObTzb54M82/c3/PNBnm0V6S5v/8/neLZlpLu8/T8f6dl+H+ku30c6n+PZlpHusms7t/Fsnw/ybIvb4IM82yrSXXZt5zae7fNBnm1xw3+QZ1tFusvb//M5nm0Z6S5v/89HerbfR7rL95HO53i2ZaTb7Nq28WyfD/Jsi9vggzzbKtJtdm3beLbPB3m2xQ3/QZ5tFekub//P53i2ZaS7vP0/H+nZfh/pNt9Heo5nW0a6za5tG8/2+SDPtrgNPsizrSLdZte2jWf7fJBnW9zwH+TZVpH+w3ek678Av0d6niLSWvv4nb2OP9XY8Y699Nfqvyeml+PP/OXd319X+9fvf79W+VNuXsfv8dYnxbvm76VQzte/Evwp3nd11svvcV41N9qf/r79np9j5/ycX3FeBLX/TX7e5rN/8dS+1L/fv2j6nxLzx38VW6b+U6nvmfpPpX5k6j+V+pmp/1TqV6b+U6k/M/UfSv0/rubP1P9fTf2j+jxW6rduOT+b+uxmP5b6lqn/VOqzm/1Y6rOb/Vjqs5v9WOqzm/1Y6rOb/VTqZ3azv5D68YV//c9r/YOp37mbHef6SuV81SJSr1K5c3c6S/2q4ln6+Q+mcuduMziVLVMZlcqdu8HgVO7c3QWncuduLTiVO3dfwancuZuKTeXauTsKTuXO3U5wKrPbCUtldjthqWyZyqhUZrcTlsrsdsJSmd1OWCqz2wlLZXY7Uak8s9sJS2V2O2GpzG4nLJXZ7YSlsmUqo1KZ3U5YKrPbCUtldjthqcxuJyyV2e3EpLK8XtnthKUyu52wVGa3E5bK7HbCUtkylVGp3LnbWa1+SaJW+9fw/pTK3/Kzcwuz2qxf+bn+P/sHS23nFuY7pbZzXxJcajv3Jd8otbJzsxFbamXnZuM7pbZzBxFcajt3EN8ptZalFlVq2Rbcl1q2BWGllm3BfallWxBWatkW3JZazbYgqtRqtgX3pZZtQVipZVtwX2otSy2q1LItuC+1bAvCSi3bgvtSy7YgrNSyLbgttSPbgqhSO7ItuC+1bAvCSi3bgvtSa1lqUaWWbcF9qWVbEFZq2Rbcl1q2BWGllm3Bbam1bAuiSq1lW3BfatkWhJVatgX3pday1KJKLduC+1LLtiCs1LItuC+1bAvCSi3bgttS69kWRJVaz7bgvtSyLQgrtWwL7kutZalFlVq2Bfellm1BWKllW3BfatkWhJVatgW3pbb179THltrWvzv/nVLLtiCs1LItuC+1lqUWVWrZFtyXWrYFYaWWbcF9qWVbEFZq2RbcltrWP/gdW2pb/4D3d0ot24KwUtu6LZh9faVyrvmu1NqP5uf4+s+2tlcJz89cr694V1l/k5/f4u1PivcX66H28iVkrXO0d/Uwds7P+RXnRVC7+Oi58tm/eGpf6t9XH1UzU/+p1K9M/adSf2bqP5T6H/6R7kz9n1JfMvWfSn3N1H8q9Uem/lOpb5n6T6V+65bzs6nPbvZjqc9u9mOpz272Y6nPbvZTqT+zm/1Y6rOb/Vjqs5v9WOqzm/2F1I+vzej1P6/1D6a+bZz6ca6vVM5XLSL1KpU7d6exv1B57txtBqdy5+4xOJU7d4PBqdy5uwtNZXnt3K0Fp3Ln7is4lTt3U8Gp3Lk7Ck5ly1RGpTK7nbBUZrcTlsrsdsJSmd1OWCqz24lKZcluJyyV2e2EpTK7nbBUZrcTlsqWqYxKZXY7YanMbicsldnthKUyu52wVGa3E5XKmt1OWCqz2wlLZXY7YanMbicslS1TGZXK7HbCUpndTlgqs9sJS+XO3Y7WhpW6cwsTqg27YshSuyu1Y+e+JLjUdu5LvlNqOzcbwaXWstRuS23nDiK41HbuIL5Taju3BcGllm3BfallWxBVai3bgttSa9kWhJVatgX3pZZtQViptSy121LLtiCs1LItuC+1bAvCSi3bgvtSy7YgqtR6tgW3pdazLQgrtWwL7kst24KwUmtZarellm1BWKllW3BfatkWhJVatgX3pZZtQVSpjWwLbkttZFsQVmrZFtyXWrYFYaXWstRuSy3bgrBSy7bgvtSyLQgrtWwL7kst24KoUpvZFtyW2sy2IKzUsi24L7VsC8JKrWWp3ZZatgVhpZZtwX2pZVsQVmrZFtyXWrYFUaW2si24LbWVbUFYqWVbcF9q2RaElVrLUrsttWwLwkot24L7Usu2IKzUsi24L7VsC6JKbeufNf9GqW392+PBpZZtwX2pZVsQVmotS+221LItCCu1rduC2ddXKuea70rtZ9uCdoyv/Iwenp+5Xl/xrrL+Jj+/xbueFO8v1kPt5UvIWudo7+rh3Dk/51ecF0Ht4qPnymf/4ql9qX///qOq/vCPYmfq/5T6kqn/VOprpv5TqT8y9Z9KfcvUfyr1PVP/qdSPTP2nUv+oPo+V+q1bzs+mPrvZT6W+ZDf7sdRnN/ux1Gc3+7HUZzf7sdS3TP2nUp/d7MdSn93sL6R+9PGV+rHWP5j6nbvZca6vVM5XLSL1KpU7d6ehv1BZy87dZmwq687dY3Aqd+4Gg1O5c3cXnMqdu7XgVLZMZVQqd+6mglO5c3cUnMqdu53gVGa3E5bK7HaiUnlktxOWyux2wlKZ3U5YKrPbCUtly1RGpTK7nbBUZrcTlsrsdsJSmd1OWCqz24lKZctuJyyV2e2EpTK7nbBUZrcTlsqWqYxKZXY7YanMbicsldnthKUyu52wVGa3E5XKnt1OWCp37na0Nqz2nVuYUG1Y7Tu3MN8ptZalFlVqO/cl3ym1nZuN4FLbudn4Tqnt3EEEl9rOHcQ3Sm3s3BbEltrItuC+1LItCCu1bAvuS61lqUWVWrYF96WWbUFYqWVbcF9q2RaElVq2BbelNrMtiCq1mW3BfallWxBWatkW3Jday1KLKrVsC+5LLduCsFLLtuC+1LItCCu1bAtuS21lWxBVaivbgvtSy7YgrNSyLbgvtZalFlVq2Rbcl1q2BWGllm3BfallWxBWatkW3JbamW1BVKmd2Rbcl1q2BWGllm3Bfam1LLWoUsu24L7Usi0IK7VsC+5LLduCsFLLtuCu1I5XtgVBpXa8si24L7VsC8JKLduC+1JrWWpRpZZtwX2pZVsQVmrZFtyXWrYFYaWWbcFtqW39i+yxpbb1L6x/p9SyLQgrtWwL7kutZalFlVq2Bfellm1BWKllW3BfatkWhJXa1m3B7OsrlXPNN6X2wz+13V+v3/PT6xmen7leX/Gusv4mP7/FW54U7y/WQ+3lS8ha52jv6qHunJ/zK85/XW508dHzr/bGL57al/r3xUfVD/8odqb+T6lvmfpPpb5n6j+V+pGp/1TqZ6b+U6lfmfpPpf7M1H8o9cej+jxW6rduOT+b+uxmP5b67GY/lvqWqf9U6rOb/Vjqs5v9WOqzm/1Y6rOb/Vjqs5v9hdSPPr5SP9b6x1Lfdu5mx7m+UjlftYjUq1Tu3J2G/kLl0XbuNoNTuXP3GJzKlqmMSuXO3V1wKnfu1oJTuXP3FZzKnbup4FTu3B3FprLv3O0EpzK7nbBUZrcTlsrsdsJS2TKVUanMbicsldnthKUyu52wVGa3E5bK7HaiUjmy2wlLZXY7YanMbicsldnthKWyZSqjUpndTlgqs9sJS2V2O2GpzG4nLJXZ7USlcma3E5bK7HbCUpndTlgqs9sJS2XbOJXf0IbNnVuYWG3Y3LmF+U6p7dyXBJfazn3Jd0pt52YjttTWzs3GN0pt7dxBBJfazh3Ed0pt57YguNRaltptqWVbEFZq2Rbcl1q2BWGllm3BfallWxBVame2BbeldmZbEFZq2Rbcl1q2BWGl1rLUbkst24KwUsu24L7Usi0IK7VsC+5LLduCoFJrr2wL7kqtvbItCCu1bAvuSy3bgrBSa1lqt6WWbUFYqWVbcF9q2RaElVq2Bfellm1BVKmVbAtuS61kWxBWatkW3JdatgVhpday1G5LLduCsFLLtuC+1LItCCu1bAvuSy3bgqhSq9kW3JZazbYgrNSyLbgvtWwLwkqtZandllq2BWGllm3BfallWxBWatkW3JdatgVRpbb1785/o9S2/nH44FLLtuC+1LItCCu1lqV2W2rZFoSVWrYF96WWbUFYqWVbcF9q2RZEldrWP+D9jVLb+le5g0tt67Zg9vWVyrnmu1L74bZg9K/8nC08P3O9vuJdZf1Nfn6Ltz0p3l+sh9rLl5C1ztHe1UPfOT/nV5wXQe3io+fKZ//iqX2pf199VI1M/adSPzP1n0r9ytR/KvVnpv5Dqf/pH/XO1P+R+pKp/1Tqa6b+U6l/VJ/HSn3L1H8q9dnNfiz12c1+LPXZzX4s9dnNfiz12c1+KvUju9mPpT672Y+lPrvZX0j96OMr9WOtfzD1O3ez41xfqZyvWkTqVSrbxqkM/YXKNnbuNoNTuXP3GJzKnbvB4FTu3N0Fp3Lnbi02lXPn7is4lTt3U8Gp3Lk7Ck7lzt1OcCpbpjIqldnthKUyu52wVGa3E5bK7HbCUpndTlQqV3Y7YanMbicsldnthKUyu52wVLZMZVQqs9sJS2V2O2GpzG4nLJXZ7YSlMrudqFSe2e2EpTK7nbBUZrcTlsrsdsJS2TKVUanMbicsldnthKVy527nG9qwc+cWJlYbdu7cwuhS66+d+5LQUuuvnfuS75Tazs1GcKnt3Gx8p9RallpUqe3cQXyn1HZuC4JLLduC+1LLtiCs1LItuC21km1BVKmVbAvuSy3bgrBSy7bgvtRallpUqWVbcF9q2RaElVq2Bfellm1BWKllW3BbajXbgqhSq9kW3JdatgVhpZZtwX2ptSy1qFLLtuC+1LItCCu1bAvuSy3bgrBSy7bgttSObAuiSu3ItuC+1LItCCu1bAvuS61lqUWVWrYF96WWbUFYqWVbcF9q2RaElVq2Bbel1rItiCq1lm3BfallWxBWatkW3Jday1KLKrVsC+5LLduCsFLLtuC+1LItCCu1bAtuS61nWxBVaj3bgvtSy7YgrNSyLbgvtZalFlVq2Rbcl1q2BWGllm3BfallWxBWatkW3Jba1r89HltqW/+W+HdKLduCsFLLtuC+1FqWWlSpbd0WzL6+UjnXfFdqP9sWjOP1e37Gn4WgQfmZ6/UV7yrrb/LzW7zzSfH+Yj3UXr6ErHWO9q4e1s75Ob/ivAhqFx89Vz77F0/tS/376qPqzNR/KPU//CPamfo/pb5k6j+V+pqp/1Tqj0z9p1LfMvWfSn3P1H8q9Y/q81ip37rl/Gzqs5v9WOqzm/1U6ld2sx9LfXazH0t9drMfS312sx9LfcvUfyr12c3+QupHH1+pH2v9g6nfuZsd5/pK5XzVIlKvUrlzdxr6C5V97dxtBqdy5+4xNpXnzt1gcCp37u6CU7lztxacyp27r+BUtkxlVCp37o6CU7lztxOcyux2wlKZ3U5YKrPbCUrleGW3E5bK7HbCUpndTlgqs9sJS2XLVEalMrudsFRmtxOWyux2wlKZ3U5YKrPbiUplyW4nLJXZ7YSlMrudsFRmtxOWypapjEpldjthqcxuJyyV2e2EpTK7nbBUZrcTlcq6c7ejtWGj7tzChGrDRt25hflOqe3clwSXWstSuy21nZuN4FLbudn4Tqnt3EEEl9rOHcR3Sm3ntiC21I5sC25L7ci2IKzUsi24L7VsC8JKrWWp3ZZatgVhpZZtwX2pZVsQVmrZFtyXWrYFUaXWsi24LbWWbUFYqWVbcF9q2RaElVrLUrsttWwLwkot24L7Usu2IKzUsi24L7VsC6JKrWdbcFtqPduCsFLLtuC+1LItCCu1lqV2W2rZFoSVWrYF96WWbUFYqWVbcF9q2RZEldrItuC21Ea2BWGllm3BfallWxBWai1L7bbUsi0IK7VsC+5LLduCsFLLtuC+1LItiCq1mW3BbanNbAvCSi3bgvtSy7YgrNRaltptqWVbEFZq2Rbcl1q2BWGllm3BfallWxBValv/wvo3Sm3rn0EPLrVsC+5LLduCsFJrWWq3pZZtQVipZVtwX2rZFoSV2tZtwezrK5VzzXel9sNtwfl7wHXWFp6fuV5f8a6y/iY//xbvT/8e9j833l+sh9rLl5C1ztHe1MNP/8i1V37OrzgvgtrFR8+Vz/7FU/tS/774qPrpH8XO1P+R+iNT/6nUt0z9p1LfM/WfSv3I1H8q9TNT/6nUr0z9p1L/qD6PlPr52rrl/Gzqs5v9WOqzm/1Y6rOb/VjqW6b+U6nPbvZjqc9u9mOpz272Y6nPbvYXUj/6+Er9tZX9B1O/czd7jVG+Unlds4tIvUhl2bk7Df2Fyll27jaDU7lz9xicyp27weBUtkxlVCp37taCU7lz9xWcyp27qeBU7twdBady524nNpU1u52wVGa3E5bK7HbCUpndTlgqW6YyKpXZ7YSlMrudsFRmtxOWyux2wlKZ3U5UKo/sdsJSmd1OWCqz2wlLZXY7YalsmcqoVGa3E5bK7HbCUpndTlgqs9sJS2V2O1GpbNnthKUyu52wVGa3E5bKnbsdrQ2brW2dn0Bt2Gw7tzDfKbWd+5LgUtu5L/lOqe3cbASX2s7NxjdKre/cQcSWWt+5g/hOqe3cFgSXWrYF96XWstSiSi3bgvtSy7YgrNSyLbgvtWwLwkot24LbUhvZFkSV2si24L7Usi0IK7VsC+5LrWWpRZVatgX3pZZtQVipZVtwX2rZFoSVWrYFt6U2sy2IKrWZbcF9qWVbEFZq2Rbcl1rLUosqtWwL7kst24KwUsu24L7Usi0IK7VsC25LbWVbEFVqK9uC+1LLtiCs1LItuC+1lqUWVWrZFtyXWrYFYaWWbcF9qWVbEFZq2RbcltqZbUFUqZ3ZFtyXWrYFYaWWbcF9qbUstahSy7bgvtSyLQgrtWwL7kst24KwUsu24K7U1tY/Dh9aamvrH3v/TqllWxBWatkW3Jday1KLKrVsC+5LLduCsFLLtuC+1LItCCu1bAtuS23rX+WOLbWtf5V7zb6+Unmtg9+V2s+2BXOUr/ycr/D8zPX6ineV9Tf5+S3e40nx/mI91F6+hKwXWntXD23n/JxfcV4EtYuPniuf/Yun9qX+ffVR1TP1n0r9yNR/KvUzU/+p1K9M/adSf2bqP5T6H/4R8Ez9n1JfMvWfSv2j+jxW6rduOT+b+pap/1Tqs5v9WOqzm/1Y6rOb/Vjqs5v9WOqzm/1U6o/sZj+W+uxmfyH1o4+v1I+1/sHU79zNjnN9pXK+ahGpV6ncuTsN/YXK9cM/Iv/oVO7cPQancuduMDiVO3d3wancuVsLTuXO3VdsKtvO3VRwKnfujoJTuXO3E5zK7HbCUtkylVGpzG4nLJXZ7YSlMrudsFRmtxOWyux2olLZs9sJS2V2O2GpzG4nLJXZ7YSlsmUqo1KZ3U5YKrPbCUtldjthqcxuJyyV2e1EpXJktxOWyux2wlKZ3U5YKrPbCUtly1RGpTK7nbBU7tztfEMbNnZuYWK1YWPnFuY7pbZzXxJbanPnvuQbpTZ3bjaCS23nZuM7pbZzBxFcai1L7bbUdm4Lgkst24L7Usu2IKzUsi24L7VsC6JKbWVbcFtqK9uCsFLLtuC+1LItCCu1lqV2W2rZFoSVWrYF96WWbUFYqWVbcF9q2RZEldqZbcFtqZ3ZFoSVWrYF96WWbUFYqbUstdtSy7YgrNSyLbgvtWwLwkot24L7Usu2IKjUzle2BXeldr6yLQgrtWwL7kst24KwUmtZarellm1BWKllW3BfatkWhJVatgX3pZZtQVSplWwLbkutZFsQVmrZFtyXWrYFYaXWstRuSy3bgrBSy7bgvtSyLQgrtWwL7kst24KoUqvZFtyW2ta/Ux9catkW3JdatgVhpday1G5LLduCsFLLtuC+1LItCCu1bAvuSy3bgqhS2/q3xL9Ralv/4HdwqWVbcF9q2RaElVrbOZWzr69UzjXfldrPtgWrzt/zs/oIz89cr694V1l/k5/f4h1PivcX66H28iVkvUq1vauHuXN+zq84L4LaxUfPlc/+xVP7Uv+++qhamfpPpf7M1H8o9T/8o9uZ+j+lvmTqP5X6mqn/VOqPTP2nUt8y9Z9K/aP6PFbqt245P5v67GY/lvrsZj+W+uxmP5X6nt3sx1Kf3ezHUp/d7MdSn93sx1LfMvXfT/3o4yv1Y61/MPU7d7PjXF+pnK9aROpVKnfuTkN/ofLsO3ebwancuXsMTuXO3WBsKsfO3V1wKnfu1oJTuXP3FZzKnbup4FS2TGVUKnfudoJTmd1OWCqz2wlLZXY7YanMbicqlTO7nbBUZrcTlsrsdsJSmd1OWCpbpjIqldnthKUyu52wVGa3E5bK7HbCUpndTlQqV3Y7YanMbicsldnthKUyu52wVLZMZVQqs9sJS2V2O2GpzG4nLJXZ7YSlcudu5xvasHPnFiZWG3bu3MJ8p9R27kuCS23nvuQ7pday1KJKbedm4zultnMHEVxqO3cQ3ym1nduC4FLLtuCm1OrrlW1BTKldqcy24L7Usi0IK7VsC+5LrWWpRZVatgX3pZZtQVipZVtwX2rZFoSVWrYFt6VWsi2IKrWSbcF9qWVbEFZq2Rbcl1rLUosqtWwL7kst24KwUsu24L7Usi0IK7VsC25LrWZbEFVqNduC+1LLtiCs1LItuC+1lqUWVWrZFtyXWrYFYaWWbcF9qWVbEFZq2RbcltqRbUFUqR3ZFtyXWrYFYaWWbcF9qbUstahSy7bgvtSyLQgrtWwL7kst24KwUsu24LbUWrYFUaXWsi24L7VsC8JKLduC+1JrWWpRpZZtwX2pZVsQVmrZFtyXWrYFYaWWbcFtqW39M+ixpbb1z5p/p9SyLQgrtWwL7kutZalFlVq2Bfellm1BWKlt3RbMvr5SOdd8V2o/3BacvwdQz1rD8zPX6yveVdbf5Oe3eM8nxfuL9VB7+RKy1jnam3r46R+59srP+RXnRVC7+Oi58tm/eGpf6t8XH1U//aPYmfo/Ul8z9Z9K/ZGp/1TqW6b+U6nvmfpPpX5k6j+V+pmp/1TqH9XnsVK/dcv50dTP7GY/lvrsZj+W+uxmP5b67GY/lvqWqf9U6rOb/Vjqs5v9WOqzm/2F1I8+vlI/1voHU79zNzvO9ZXK+apFpF6lcufuNPIXKutr7dxtBqdy5+4xOJU7d4PBqdy5uwtOZctURqVy5+4rOJU7d1PBqdy5OwpO5c7dTnAqs9uJSuWZ3U5YKrPbCUtldjthqcxuJyyVLVMZlcrsdsJSmd1OWCqz2wlLZXY7YanMbicoleWV3U5YKrPbCUtldjthqcxuJyyVLVMZlcrsdsJSmd1OWCqz2wlLZXY7YanMbicqlSW7nbBUZrcTlsqdux2tDStl5xYmVBtWSstSuy21nfuS4FLbuS/5Tqnt3GwEl9rOzcZ3Sm3nDiK21OrOHcQ3Sq3u3BYEl1q2Bfellm1BWKm1LLXbUsu2IKzUsi24L7VsC8JKLduC+1LLtiCq1I5sC25L7ci2IKzUsi24L7VsC8JKrWWp3ZZatgVhpZZtwX2pZVsQVmrZFtyXWrYFUaXWsi24LbWWbUFYqWVbcF9q2RaElVrLUrsttWwLwkot24L7Usu2IKzUsi24L7VsC6JKrWdbcFtqPduCsFLLtuC+1LItCCu1lqV2W2rZFoSVWrYF96WWbUFYqWVbcF9q2RZEldrItuC21Ea2BWGllm3BfallWxBWai1L7bbUsi0IK7VsC+5LLduCsFLLtuC+1LItiCq1rX/s/RultvUvsgeXWrYF96WWbUFYqbUstdtSy7YgrNSyLbgvtWwLwkot24L7Usu2IKrUtv5V7jX7+krlXPNNqf3wT22f4/WVn3WG52eu11e8q6y/yc9v8dYnxfuL9VB7+RKy1jnau3o4ds7P+RXnRVC7+Oi58tm/eGpf6t9XH1UtU/+p1PdM/adSPzL1n0r9zNR/KvUrU/+p1J+Z+g+l/od/NDxT/6fUP6rPY6V+65bzs6nPbvZjqW+Z+k+lPrvZj6U+u9mPpT672Y+lPrvZj6U+u9kPpb6+spv9hdSPPr5SP9b6B1O/czc7zvWVyvmqRaRepXLn7jT0Fyrra+duMziVLVMZlcqdu8HgVO7c3QWncuduLTiVO3dfwancuZuKTWXZuTsKTuXO3U5wKrPbCUtldjthqWyZyqhUZrcTlsrsdsJSmd1OWCqz2wlLZXY7Uams2e2EpTK7nbBUZrcTlsrsdsJS2TKVUanMbicsldnthKUyu52wVGa3E5bK7HaiUnlktxOWyux2wlKZ3U5YKrPbCUtly1RGpXLnbkdrw+qxcwsTqg2rx84tzHdKbee+JLjUdu5LvlFqbedmI7bU2s7NxndKbecOIrjUdu4gvlNqLUstqtSyLbgvtWwLwkot24L7Usu2IKzUsi24LbWebUFUqfVsC+5LLduCsFLLtuC+1FqWWlSpZVtwX2rZFoSVWrYF96WWbUFYqWVbcFtqI9uCqFIb2Rbcl1q2BWGllm3Bfam1LLWoUsu24L7Usi0IK7VsC+5LLduCsFLLtuC21Ga2BVGlNrMtuC+1bAvCSi3bgvtSa1lqUaWWbcF9qWVbEFZq2Rbcl1q2BWGllm3BbamtbAuiSm1lW3BfatkWhJVatgX3pday1KJKLduC+1LLtiCs1LItuC+1bAvCSi3bgttS2/p36mNLbevfnf9OqWVbEFZq2Rbcl1rLUosqtWwL7kst24KwUsu24L7Usi0IK7VsC+5K7dj6B79DS+3Y+ge8v1Nq2RaEldrWbcHs6yuVc813pdZ+Mj9XZc/f/+FXH+H5mev1Fe8q62/y81u8/Unx/mI91F6+hKx1jvauHsbO+Tm/4rwIahcfPVc++xdP7Uv9++qjambqP5X6lan/VOrPTP2HUv+zP9Kdqf9z6kum/lOpr5n6T6X+yNR/KvUtU/+p1G/dcn429dnNfiz12c1+LPXZzX4s9dnNfir1NbvZj6U+u9mPpT672Y+lPrvZX0j96OMr9WOtfzD1bePUj3N9pXK+ahGpV6ncuTsN/YXKo+7cbQancufuMTiVO3eDwancubuLTeWxc7cWnMqdu6/gVO7cTQWncufuKDiVLVMZlcrsdsJSmd1OWCqz2wlLZXY7YanMbicqlS27nbBUZrcTlsrsdsJSmd1OWCpbpjIqldnthKUyu52wVGa3E5bK7HbCUpndTlQqe3Y7YanMbicsldnthKUyu52wVLZMZVQqs9sJS2V2O2GpzG4nLJU7dzvf0Ib1nVuYWG3Y2LmF+UapjZ37kuBS27kv+U6p7dxsBJday1K7LbWdO4jgUtu5g/hOqe3cFgSXWrYF96WWbUFUqc1sC25LbWZbEFZq2Rbcl1q2BWGl1rLUbkst24KwUsu24L7Usi0IK7VsC+5LLduCqFJb2RbcltrKtiCs1LItuC+1bAvCSq1lqd2WWrYFYaWWbcF9qWVbEFZq2Rbcl1q2BVGldmZbcFtqZ7YFYaWWbcF9qWVbEFZqLUvtttSyLQgrtWwL7kst24KwUsu24L7Usi0IKrX2yrbgrtTaK9uCsFLLtuC+1LItCCu1lqV2W2rZFoSVWrYF96WWbUFYqWVbcF9q2RZElVrJtuC21Eq2BWGllm3BfallWxBWai1L7bbUsi0IK7VsC+5LLduCsFLLtuC+1LItiCq1rX/W/BultvVvjweXWrYF96WWbcH/n723y3VdSZIupySSHn/zn1ir0PfsuoWmy08ivWNTbuvtQ2MjoVi0KJmpz11Mi5oRtY9RYxakRU16Fow2f1COOe6itnkWrJ//4eO80vmM+fo57zzm/+Hzz3lnpfP+h3k42/EjZD1Ht7s8LGU+6+ec709wtuD/9Lx5tp/Pc7YZ/e8H/6dq90uxQf+/6A/Q/xb6E/S/hf4C/W+hN9D/FvoG+t9C30H/W+hL7bzvQi89OX8XPWv2t9Aba/bX0LNmfw09a/bX0LNmfw29gf630LNmfw09a/Y/QN9b/0Hf5/wv0Suv2b7mD8rxOo8AfYRSeZ2mvqHSTHlt5qJsyusxGaXyGkxGqbzuklEqr7VklAbKLJTKayoZpfI6SkapvHaSUbJ20lCydrJQdtZOGkrWThpK1k4aStZOGkoDZRZK1k4aStZOGkrWThpK1k4aStZOFsrB2klDydpJQ8naSUPJ2klDaaDMQsnaSUPJ2klDydpJQ8naSUPJ2slCOVk7aSiV185faMOm8oTJ1YZN5QnzN1EzopYVNeVd8jdRUx4byVFTHht/EzXlBZEcNeUF8RdRW8qzIDdqi1nwOWrMgrSoMQs+R82IWlbUmAWfo8YsSIsas+Bz1JgFaVFjFnyKWnsxC5Ki1l7Mgs9RYxakRY1Z8DlqRtSyosYs+Bw1ZkFa1JgFn6PGLEiLGrPgY9QOZkFW1A5mweeoMQvSosYs+Bw1I2pZUWMWfI4asyAtasyCz1FjFqRFjVnwMWonsyAraiez4HPUmAVpUWMWfI6aEbWsqDELPkeNWZAWNWbB56gxC9Kixiz4GLWLWZAVtYtZ8DlqzIK0qDELPkfNiFpW1JgFn6PGLEiLGrPgc9SYBWlRYxZ8jJr0G9lzoyb9hvW/iRqzIC1qzILPUTOilhU1ZsHnqDEL0qLGLPgcNWZBWtSkZ8Fo8wflmOMmaptftX3044fPeqXzGfP1c955zP/D55/zHpXO+x/m4X/+0fWfvz9Ht7s8nMp81s8535/gbMH/6fkfXD+f52wz+t8P/k/V5pdig/5f6A30v4W+gf630HfQ/xb6AfrfQj9B/1voF+h/CX0vtfO+C7305Pxd9KzZX0PPmv019Ab630LPmv019KzZX0PPmv019KzZX0PPmv0P0PfWf9D3Of879EN5zfY1f1CO13kE6COUyus09Q2VbSivzWSUyusxGaWBMgul8rpLRqm81pJRKq+vZJTKayoZpfI6ykU5lddOMkrWThpK1k4aStZOGkoDZRZK1k4aStZOGkrWThpK1k4aStZOFsrF2klDydpJQ8naSUPJ2klDaaDMQsnaSUPJ2klDydpJQ8naSUPJ2klC2V+snTSUrJ00lKydNJSsnTSUJowy1ob1l/KESdWG9ZfyhPmbqCnvkuSoKe+Sv4ma8tjIjdqhPDb+ImqH8oJIjprygvibqCnPguSoGVH7GDVmQVrUmAWfo8YsSIsas+Bz1JgFWVE7mQUfo3YyC9Kixiz4HDVmQVrUjKh9jBqzIC1qzILPUWMWpEWNWfA5asyCrKhdzIKPUbuYBWlRYxZ8jhqzIC1qRtQ+Ro1ZkBY1ZsHnqDEL0qLGLPgcNWZBVtSMWfAxasYsSIsas+Bz1JgFaVEzovYxasyCtKgxCz5HjVmQFjVmweeoMQuyotaYBR+j1pgFaVFjFnyOGrMgLWpG1D5GjVmQFjVmweeoMQvSosYs+Bw1ZkFW1KTfO/8XUZN+OXxy1JgFn6PGLEiLmhG1j1FjFqRFjVnwOWrMgrSoMQs+R41ZkBU16Rd4/0XUpN/KnRw16Vkw2vxBOea4i9reWXD+ZP8620znM+br57zzmP+Hzz/ntUrn/Q/zcLbjR8h6jm53eWjKfNbPOd+f4GzB/+l582w/n+d/3uMY/O9H/6eqg/630A/Q/xb6CfrfQr9A/0voN7/UG/T/Qn+A/rfQn6D/LfSldt53oTfQ/xZ61uyvoWfN/hp61uyvoWfN/hp61uxvoV+s2V9Dz5r9NfSs2f8AfW/9B/37a/K/RK+8ZvuaPyjH6zwC9BFKE0aZ+4bKpbw2k1Eqr8dklMprMBml8rpLRqm81lJRjpfy+kpGqbymklEqr6NklMprJxmlgTILJWsnDSVrJw0laycNJWsnDSVrJwvlwdpJQ8naSUPJ2klDydpJQ2mgzELJ2klDydpJQ8naSUPJ2klDydrJQnmydtJQsnbSULJ20lCydtJQGiizULJ20lCydtJQKq+dWBs2TuUJk6oNG6fyhPmLqF3KuyQ3apfyLvmbqCmPjeSoKY+Nv4maEbWsqCkviL+JmvIsSI4as+Bz1JgFaVFjFnyMmjELsqJmzILPUWMWpEWNWfA5akbUsqLGLPgcNWZBWtSYBZ+jxixIixqz4GPUGrMgK2qNWfA5asyCtKgxCz5HzYhaVtSYBZ+jxixIixqz4HPUmAVpUWMWfIxaZxZkRa0zCz5HjVmQFjVmweeoGVHLihqz4HPUmAVpUWMWfI4asyAtasyCj1EbzIKsqA1mweeoMQvSosYs+Bw1I2pZUWMWfI4asyAtasyCz1FjFqRFjVnwMWqTWZAVtcks+Bw1ZkFa1JgFn6NmRC0rasyCz1FjFqRFjVnwOWrMgrSoMQs+Rk363eO5UZN+l/jfRI1ZkBY1ZsHnqBlRy4qa9CwYbf6gfNfWu6htngVr/Pkfvs6ezuf9M+HPeecx/w+ff847Kp33P8zD2Y4fIev//FPFuzxMZT7r55zvT3C24P/0vHm2n8/zvu7R/370f6oW6H8H/dz9Em3Q/y/6A/S/hf4E/W+hv0D/W+gN9L+FvoH+t9CX2nnfhV56cv4uetbsr6Fnzf4W+oM1+2voWbO/hp41+2voWbO/ht5A/1voWbP/Afre+g/6Pud/iV55zfY1f1CO13kE6COUyus09Q2V81Bem8kolddjLspTeQ0mo1Red8kolddaMkrl9ZWM0kCZhVJ5HSWjVF47yShZO2koWTtpKFk7WSgv1k4aStZOGkrWThpK1k4aSgNlFkrWThpK1k4aStZOGkrWThpK1k4WSmPtpKFk7aShZO2koWTtpKE0UGahZO2koWTtpKFk7aShZO2koWTtZKFsymsn1obNpjxhUrVhsylPmL+JmvIuSY6aEbWPUVMeG8lRUx4bfxM15QWRHDXlBfE3UVOeBblR68yCj1HrzIK0qDELPkeNWZAWNSNqH6PGLEiLGrPgc9SYBWlRYxZ8jhqzICtqg1nwMWqDWZAWNWbB56gxC9KiZkTtY9SYBWlRYxZ8jhqzIC1qzILPUWMWZEVtMgs+Rm0yC9Kixiz4HDVmQVrUjKh9jBqzIC1qzILPUWMWpEWNWfA5asyCrKgtZsHHqC1mQVrUmAWfo8YsSIuaEbWPUWMWpEWNWfA5asyCtKgxCz5HjVmQFLX1YhZ8itp6MQvSosYs+Bw1ZkFa1IyofYwasyAtasyCz1FjFqRFjVnwOWrMgqyoSb9h/S+iJv0a9OSoMQs+R41ZkBY1I2ofo8YsSIsas+Bz1JgFaVGTngWjzR+UY467qO2dBdf68/L6y46WzmfM18955zH/D5//97yb34f9//N5/8M8nO34EbKeo9tNHja/5PphfNbPOd+f4GzB/+l582w/n+dsM/rfD/5P1eaXYoP+X+gv0P8WegP9b6FvoP8t9B30v4V+gP630E/Q/xb6Ujvvq9Bf0pPzd9GzZn8NPWv219CzZn8NvYH+t9CzZn8NPWv219CzZn8NPWv2P0DfW/9B3+f8L9Err9m+5g/K8TqPAH2A0pTXaeobKpcpr81klMrrMRml8hpMRmmgzEKpvNaSUSqvr2SUymsqGaXyOkpGqbx2clE21k4aStZOGkrWThpK1k4aSgNlFkrWThpK1k4aStZOGkrWThpK1k4Wys7aSUPJ2klDydpJQ8naSUNpoMxCydpJQ8naSUPJ2klDydpJQ8nayUI5WDtpKFk7aShZO2koldfOX2jDhknzydSGDeUJ8zdRU94lyVFT3iV/EzXlsZEcNeWx8RdRm8oLIjdqU3lB/E3UlGdBctSYBZ+jZkQtK2rMgs9RYxakRY1Z8DlqzIK0qDELPkZtMQuyoraYBZ+jxixIixqz4HPUjKhlRY1Z8DlqzIK0qDELPkeNWZAWNWbBh6hdrxezICdqb5TMgs9RYxakRY1Z8DlqRtSyosYs+Bw1ZkFa1JgFn6PGLEiLGrPgY9QOZkFW1A5mweeoMQvSosYs+Bw1I2pZUWMWfI4asyAtasyCz1FjFqRFjVnwMWonsyAraiez4HPUmAVpUWMWfI6aEbWsqDELPkeNWZAWNWbB56gxC9Kixiz4GDXpl8PnRk36Ze9/EzVmQVrUmAWfo2ZELStqzILPUWMWpEWNWfA5asyCtKgxCz5GTfqt3LlRk34r9xxt/qAcc9xFbe8saPbn2V6tj4BPP4/jn7/uZzsjOv/Kja3Xv87a72Jj1+tPbsz6v4Pz//3jsY4/V3asa9yk7IJiAkWDYgLFBsUEih2KCRQHFBMoTigmUFxQ/O8pbn6FdlWKBxQTKLJdMiiyXTIoGhQTKLJdMiiyXTIosl0yKLJdMiiyXRIodrZLBkW2SwZFtksGRbZLBkWDYgJFtksGRbZLBkW2SwZFtksGRbZLAsXBdsmgyHbJoMh2yaDIdsmgaFBMoMh2yaDIdsmgyHbJoMh2yaDIdkmgONkuGRTZLhkU2S4ZFNkuGRQNigkU2S4ZFNkuGRTZLhkU2S4ZFNkuCRQX2yWDItslgyLbJYMi2yWDokExgSLbJYMi2yWDItslgyLbJYMi2+W/p3i82C4ZFNkuGRTZLhkU2S4ZFA2KCRTZLhkU2S4ZFNkuGRTrbJf+c9Sj27GXYp3t8osUjzrb5Tcp1tkuv0mxznb5TYp1tstvUjQoJlCss11+k2Kd7fKbFOtsl9+kyHbJoMh2SaB4sl0yKLJdMiiyXTIosl0yKNpeiuPPy5WufkXvYmr9B+Lr/D9/+89nb1/82fsXf/bxxZ99fvFnX9/72Te/VTv3sx9f/NnPL/7s1xd/9i/+Xr2++Hv1+uLv1euLv1evL/5evb74e9W++HvVvvh71b74e9W++Ht19/tIUz/7F3+v2hd/r9oXf6/aF3+v2hd/r7Yv/l5tX/y92r74e7V98ffq7nflpX72L/5ebQ/+Xh39z/+Phvmyu8/+4O/V8LM/+Hs1/OwP/l6NPnt/8Pdq+Nkf/L0afvYHf6+Gn/3B36vhZ3/w92r42R/8vRp+9i/+Xu1f/L3av/h7tX/x9+r44u/V8cXfq+OLv1fHF3+v7n7HSOpnf/D36jz//PFsd3t1PPh79Xj/X5J//vo4/vU//a9P/+Bv1r/49A/+bv2LT//gb9f4088Hf7/+xad/8DfsX3z6B3/H/sWnf/C37F98+gd/z/7Fp3/wN+1ffPqv/q6dX/1dO7/6u3Z+9Xft+urv2vXV37Xrq79r11d/1+72Nyd/+q/+rl1f/V27vvq7dn31d+365u/a8/XN37Xn65u/a8/XN3/Xnq9v/q49X9/8XXu+vvm79nx983ft+frm79rz9c3ftefrq79rj6/+rj2++rv2+Orv2uOrv2t3+/GSP/1Xf9ceX/1de3z1d+3x1d+1x1d/155f/V17fvV37fnV37XnV3/XPtnn9Bef/qu/a5/sdPqLT//V37VP9jr9xaf/6u/aJ7ud/uLTf/V37ZP9Tn/x6b/6u/bJjqe/+PRf/V37ZM/TX3z6r/6ufbLr6S8+/Vd/1z7Z9/QXn/6rv2uf7Hz6i0//1d+1T/Y+/cWn/+rv2ie7n/7i03/1d+2T/U9/8em/+rv2yQ6ov/j0X/1d+2QP1F98+q/+rn2yC+ovPv1Xf9c+2Qf1F5/+q79rn+yE+otP/9XftU/2Qv3Fp//q79onu6H+4tN/9Xftk/1Qf/Hpv/q79smOqL/49F/9XftkT9RffPqv/q59sivqLz79V3/XPtkX9Ref/qu/a5/sjPqLT//V37Vf7Y06v9obdX61N+r8am/U+dXeqPOrvVHnV3ujzq/2Rp1f7Y06v9obdX61N+r8am/U+dXeqPOrvVHnV3ujzq/2Rp1f7Y06v9obdX61N+r8am/U+dXeqPOrvVHnV3ujzq/2Rl1f7Y26vtobdX21N+r6am/U9frm79rrq71R11d7o66v9kZdX+2Nur7aG3V9tTfq+mpv1PXV3qjrq71R11d7o66v9kZdX+2Nur7aG3V9tTfq+mpv1PXV3qjrq71R11d7o66v9kZdX+2Nur7aG3V9tTfq+mpv1PXV3qjrq71R11d7o66v9kZdX+2Nur7aG3V9tTfq+mpv1PXV3qjrq71R11d7o66v9kZdX+2Nur7aG3V9tTfq+mpv1PXV3qjrq71R11d7o66v9kZdX+2Nur7aG3V9tTfq+mpv1PXV3qjrq71R11d7o66v9kZdX+2Nur7aG3V9tTfq+mpv1PXV3qjrq71R11d7o66v9kZdX+2Nur7aG3V9tTfq+mpv1PXV3qjrq71R11d7o66v9kZdX+2Nur7aG3V9tTfq+mpv1PXV3qjrq71R16O9Uec8/3z66zXvPv2Tv2uvOf58ejuum0/veKPW9ecTHf3zpx+v9ucDjdfonz99b9efo/bWzs9/PMfPH88xXv/+438++/HFn/384s9+ffFnty/+7O2LP3v/4s8+vvizzy/+7Ot7P/v64u/V9cXfq+uLv1fXF3+vri/+Xl1f/L26vvh7dX3x9+r64u/V9b3fq/b63u9Ve33v96q9nvu9uv73f3mF/8vHeR5//qff/+8+bo763K/h9KM+91s7/ajP/ZJPP+pzO0H6UZ9bIdKP+tzGkX7U5xaU7KMez+0z/+FRj/Xvo86boz63/vzHT3X971Ht7qiF2lJ0VJ22dOi0pUOnLR06benQaUuHTls6dNrSWaYtxUct05bCYnjqtKWzUFuKjmo6d1WnLZ06benUaUunTls6ddrSpdOWrkK/LUVHLdOWwmJ46bSlq1Bbio6q05YunbZ06bSlS6ctXTptyXTakum0JdP5d0tWpi2FxdB02pIVakvRUXXakum0JdNpS6bTlppOW2o6banptKWm8++WWpm2FBbDptOWWqG2FB1Vpy01nbbUdNpS12lLXactdZ221HXaUi/021J01DJtKSyGXact9UJtKTqqTlvqOm1p6LSlodOWhk5bGjptaei0paHz75ZGmbYUFsOh05ZGobYUHVWnLT3Y4Jt+VJ229GA/cPpRddrSg+3D6UfVaUsPdhunH7VMWwqL4YPNydlt6cGi5eyjPtjLnH1XH6xxTj+qTlt6sCQ6/aimc1SdtvRgY3X6UXX+3dKDfdjZxfDB+uzkttQebNtOP6pMW2o6Lu+m4/JuL9M5qkxbajou76bj8m46Lu9Wx+UdFcNWx+UdtiUdl3er5PIO7qqOy7vpuLybjsu76bi8m47Lu+m4vJuOy7vVcXmHxbCOyztsSzou71bJ5R3dVdM5qk5b0nF5Nx2Xd9NxeTcdl3fTcXm3Oi7vsBjWcXmHbUnH5d0qubyju6rTlnRc3k3H5d10XN5Nx+XddFzeTcfl3eq4vMNiWMflHbYlHZd3q+Tyju6qTlvScXk3HZd303F5Nx2Xd9NxeTcdl3er4/IOi2Edl3fYlnRc3q2Syzu6qzptScfl3XRc3k3H5d10XN5Nx+XddFzerY7LOyyGdVzeYVvScXm3Si7v6K7qtCUdl3fTcXk3HZd303F5Nx2Xd9Nxebc6Lu+wGNZxeYdtScfl3Sq5vKO7qtOWdFzeTcfl3XRc3k3H5d10XN5Nx+Xd6ri8w2JYx+UdtiUdl3er5PIO7qqOy7vpuLybjsu76bi8m47Lu+m4vJuOy7vVcXmHxbCOyztsSzou717J5f35rnYdl3fXcXl3HZd3f5nOUWXaUtdxeXcdl3ev4/KOimGv4/IO25KOy7tXcnkHd1XH5d11XN5dx+XddVzeXcfl3XVc3l3H5d3ruLzDYljH5R22JR2Xd6/k8g7uqo7Lu+u4vLuOy7vruLy7jsu767i8u47Lu9dxeYfFsI7LO2xLOi7vXsnlHd1V0zmqTlvScXl3HZd313F5dx2Xd9dxefc6Lu+wGNZxeYdtScfl3Su5vKO7qtOWdFzeXcfl3XVc3l3H5d11XN5dx+Xd67i8w2JYx+UdtiUdl3ev5PKO7qpOW9JxeXcdl3fXcXl3HZd313F5dx2Xd6/j8g6LYR2Xd9iWdFzevZLLO7qrOm1Jx+XddVzeXcfl3XVc3l3H5d11XN69jss7LIZ1XN5hW9JxefdKLu/oruq0JR2Xd9dxeXcdl3fXcXl3HZd313F59zou77AY1nF5h21Jx+XdK7m8o7uq05Z0XN5dx+XddVzeXcfl3XVc3l3H5d3ruLzDYljH5R22JR2Xd6/k8v58V4eOy3vouLyHjst76Li8x8t0jirTloaOy3vUcXlHxXDUcXlHbWnouLxHJZd3cFd1XN5Dx+U9dFzeQ8flPXRc3kPH5T10XN6jjss7LIZ1XN5hW9JxeY9KLu/gruq4vIeOy3vouLyHjst76Li8h47Le+i4vEcdl3dYDOu4vMO2pOPyHpVc3sFd1XF5Dx2X99BxeQ8dl/fQcXkPHZf30HF5jzou77AY1nF5h21Jx+U9Krm8o7tqOkfVaUs6Lu+h4/IeOi7voePyHjou71HH5R0Wwzou77At6bi8RyWXd3RXddqSjst76Li8h47Le+i4vIeOy3vouLxHHZd3WAzruLzDtqTj8h6VXN7RXdVpSzou76Hj8h46Lu+h4/IeOi7voePyHnVc3mExrOPyDtuSjst7VHJ5R3dVpy3puLyHjst76Li8h47Le+i4vIeOy3vUcXmHxbCOyztsSzou71HJ5R3dVZ22pOPyHjou76Hj8h46Lu+h4/IeOi7vUcflHRbDOi7vsC3puLxHJZd3dFdl2tLUcXlPHZf31HF5Tx2X93yZzlFl/t3SrOPyjorhrOPyjtrS1HF5z0ou7+Cu6ri8p47Le+q4vKeOy3vquLynjst76ri8Zx2Xd1gM67i8w7ak4/KelVzewV3VcXlPHZf31HF5Tx2X99RxeU8dl/fUcXnPOi7vsBjWcXmHbUnH5T0rubyDu6rj8p46Lu+p4/KeOi7vqePynjou76nj8p51XN5hMazj8g7bko7Le1ZyeQd3VcflPXVc3lPH5T11XN5Tx+U9dVzeU8flPeu4vMNiWMflHbYlHZf3rOTyju6q6RxVpy3puLynjst76ri8p47Le+q4vGcdl3dYDOu4vMO2pOPynpVc3tFd1WlLOi7vqePynjou76nj8p46Lu+p4/KedVzeYTGs4/IO25KOy3tWcnlHd1WnLem4vKeOy3vquLynjst76ri8p47Le9ZxeYfFsI7LO2xLOi7vWcnlHd1Vnbak4/KeOi7vqePynjou76nj8p46Lu9Zx+UdFsM6Lu+wLem4vGcll3d0V3Xako7Le+m4vJeOy3vpuLyXjst7vUznqDJvPll1XN5RW1o6Lu9VyeUd3VWdtqTj8l46Lu+l4/JeOi7vpePyXjou71XH5R0Wwzou77At6bi8VyWXd3BXdVzeS8flvXRc3kvH5b10XN5Lx+W9dFzeq47LOyyGdVzeYVvScXmvSi7v4K7quLyXjst76bi8l47Le+m4vJeOy3vpuLxXHZd3WAzruLzDtqTj8l6VXN7BXdVxeS8dl/fScXkvHZf30nF5Lx2X99Jxea86Lu+wGNZxeYdtScflvSq5vIO7quPyXjou76Xj8l46Lu+l4/JeOi7vpePyXnVc3mExrOPyDtuSjst7VXJ5R3fVdI6q05Z0XN5Lx+W9dFzeS8flvXRc3quOyzsshnVc3mFb0nF5r0ou7+iu6rQlHZf30nF5Lx2X99JxeS8dl/fScXmvOi7vsBjWcXmHbUnH5b0qubyju6rTlnRc3kvH5b10XN5Lx+W9dFzeS8flveq4vMNiWMflHbYlHZf3quTyju6qTlvScXkvGZe3vWRc3u+jqrSl91FV2tL7qCr/bul9VBMphu+jqrSl91FVXN7vo6q0pfdRVdrS+6g6bUnG5f0+qk5bknF5v4+q05ZkXN7vo6q8+eR9VJ22JOPyfh9Vpy3JuLztJePyfh9Vpy3JuLzfR9VpSzIu7/dRVf7d0vuoKm8+eR9Vpy3JuLzfR9VpSzIu7/dRddqSjMv7fVSdtiTj8n4fVactybi830dVefPJ+6g6bUnG5W2vSi7v4K7KuLzfR9VpSzIu7/dRTeeoOm1JxuX9PqrOv1uq4/IOi2Edl3fYlmRc3u+j6rQlGZf3+6g6bUnG5f0+qk5bknF5v4+q05ZkXN7vo6q8+cRedVzeYVuScXm/j6rTlmRc3u+jms5RddqSjMv7fVSdtiTj8n4fVeffLdVxeYfFsI7LO2xLMi7v91F12pKMy/t9VJ22JOPyfh9Vpy3JuLzfR9VpSzIu7/dRVd588j6qTluScXm/j2o6d1WnLcm4vN9H1WlLMi7v91F12pKMy/t9VJ1/t1TH5R0Wwzou77Atybi830fVaUsyLu/3UXXakozL+31UmbZ06Li8Dx2X96Hj8j7quLyjYni8TKUtHTou76OSyzu6qzJt6dBxeR86Lu9Dx+V96Li8Dx2X96Hj8j7quLzDYljH5R22JR2X91HJ5R3dVZ22pOPyPnRc3oeOy/vQcXkfOi7vQ8flfdRxeYfFsI7LO2xLOi7vo5LLO7qrOm1Jx+V96Li8Dx2X96Hj8j50XN6Hjsv7qOPyDothHZd32JZ0XN5HJZd3cFd1XN6Hjsv70HF5Hzou70PH5X3ouLwPHZf3UcflHRbDOi7vsC3puLyPSi7v4K7quLwPHZf3oePyPnRc3oeOy/vQcXkfOi7vo47LOyyGdVzeYVvScXkflVzewV3VcXkfOi7vQ8flfei4vA8dl/eh4/I+dFzeRx2Xd1gM67i8w7ak4/I+Krm8g7uq4/I+dFzeh47L+9BxeR86Lu9Dx+V96Li8jzou77AY1nF5h21Jx+V9VHJ5R3fVdI6q05Z0XN6Hjsv70HF5Hzou70PH5X3UcXmHxbCOyztsSzou76OSyzu6qzptScflfei4vA8dl/eh4/I+dVzep47L+6zj8o6K4VnH5R21pfNlOkeVaUunjsv71HF5nzou71PH5X3quLxPHZf3qePyPuu4vMNiWMflHbYlHZf3WcnlHd1Vnbak4/I+dVzep47L+9RxeZ86Lu9Tx+V91nF5h8Wwjss7bEs6Lu+zkss7uqs6bUnH5X3quLxPHZf3qePyPnVc3qeOy/us4/IOi2Edl3fYlnRc3mcll3d0V3Xako7L+9RxeZ86Lu9Tx+V96ri8Tx2X91nH5R0Wwzou77At6bi8z0ou7+Cu6ri8Tx2X96nj8j51XN6njsv71HF5nzou77OOyzsshnVc3mFb0nF5n5Vc3sFd1XF5nzou71PH5X3quLxPHZf3qePyPnVc3mcdl3dYDOu4vMO2pOPyPiu5vIO7quPyPnVc3qeOy/vUcXmfOi7vU8flfeq4vM86Lu+wGNZxeYdtScflfVZyeQd3Vcflfeq4vE8dl/ep4/I+dVzep47L+9RxeZ91XN5hMazj8g7bko7L+6zk8o7uqukcVact6bi8Tx2X96nj8j51XN6Xjsv7quPyjorhVcflHbWlS8flfb1M567KtKVLx+V96bi8Lx2X96Xj8r50XN6Xjsv7quPyDothHZd32JZ0XN5XJZd3dFd12pKOy/vScXlfOi7vS8flfem4vC8dl/dVx+UdFsM6Lu+wLem4vK9KLu/oruq0JR2X96Xj8r50XN6Xjsv70nF5Xzou76uOyzsshnVc3mFb0nF5X5Vc3tFd1WlLOi7vS8flfem4vC8dl/el4/K+dFzeVx2Xd1gM67i8w7ak4/K+Krm8o7uq05Z0XN6Xjsv70nF5Xzou70vH5X3puLyvOi7vsBjWcXmHbUnH5X1VcnkHd1XH5X3puLwvHZf3pePyvnRc3peOy/vScXlfdVzeYTGs4/IO25KOy/uq5PIO7qqOy/vScXlfOi7vS8flfem4vC8dl/el4/K+6ri8w2JYx+UdtiUdl/dVyeUd3FUdl/el4/K+dFzel47L+9JxeV86Lu9Lx+V91XF5h8Wwjss7bEs6Lu+rkss7uKs6Lu9Lx+V96bi8Lx2X96Xj8r50XN6Xjsvb6ri8o2JodVzeUVsyHZe3VXJ5R3fVdI4q05ZMx+VtOi5v03F5m47L23Rc3lbH5R0Wwzou77At6bi8rZLLO7qrOm1Jx+VtOi5v03F5m47L23Rc3qbj8rY6Lu+wGNZxeYdtScflbZVc3tFd1WlLOi5v03F5m47L23Rc3qbj8jYdl7fVcXmHxbCOyztsSzoub6vk8o7uqk5b0nF5m47L23Rc3qbj8jYdl7fpuLytjss7LIZ1XN5hW9JxeVsll3d0V3Xako7L23Rc3qbj8jYdl7fpuLxNx+VtdVzeYTGs4/IO25KOy9squbyju6rTlnRc3qbj8jYdl7fpuLxNx+VtOi5vq+PyDothHZd32JZ0XN5WyeUd3FUdl7fpuLxNx+VtOi5v03F5m47L23Rc3lbH5R0Wwzou77At6bi8rZLLO7irOi5v03F5m47L23Rc3qbj8jYdl7fpuLytjss7LIZ1XN5hW9JxeVsll3dwV3Vc3qbj8jYdl7fpuLxNx+VtOi5v03F5Wx2Xd1QMWx2Xd9SWmo7Lu1VyeX++q03H5d1epnNUmbbUdFzeTcfl3XRc3k3H5d3quLzDYljH5R22JR2Xd6vk8o7uqukcVact6bi8m47Lu+m4vJuOy7vpuLxbHZd3WAzruLzDtqTj8m6VXN7RXdVpSzou76bj8m46Lu+m4/JuOi7vpuPybnVc3mExrOPyDtuSjsu7VXJ5R3dVpy3puLybjsu76bi8m47Lu+m4vJuOy7vVcXmHxbCOyztsSzou71bJ5R3dVZ22pOPybjou76bj8m46Lu+m4/JuOi7vVsflHRbDOi7vsC3puLxbJZd3dFd12pKOy7vpuLybjsu76bi8m47Lu+m4vFsdl3dYDOu4vMO2pOPybpVc3tFd1WlLOi7vpuPybjou76bj8m46Lu+m4/JudVzeYTGs4/IO25KOy7tVcnkHd1XH5d10XN5Nx+XddFzeTcfl3XRc3k3H5d3quLzDYljH5R22JR2Xd6vk8g7uqo7Lu+m4vJuOy7vpuLybjsu76bi8m47Lu9VxeYfFsI7LO2pLXcfl3Su5vD/f1a7j8u46Lu/+Mp2jyrSlruPy7jou767j8u51XN5RMex1XN5hW9JxefdKLu/gruq4vLuOy7vruLy7jsu767i8u47Lu+u4vHsdl3dYDOu4vMO2pOPy7pVc3tFdNZ2j6rQlHZd313F5dx2Xd9dxeXcdl3ev4/IOi2Edl3fYlnRc3r2Syzu6qzptScfl3XVc3l3H5d11XN5dx+XddVzevY7LOyyGdVzeYVvScXn3Si7v6K7qtCUdl3fXcXl3HZd313F5dx2Xd9dxefc6Lu+wGNZxeYdtScfl3Su5vKO7qtOWdFzeXcfl3XVc3l3H5d11XN5dx+Xd67i8w2JYx+UdtiUdl3ev5PKO7qpOW9JxeXcdl3fXcXl3HZd313F5dx2Xd6/j8g6LYR2Xd9iWdFzevZLLO7qrOm1Jx+XddVzeXcfl3XVc3l3H5d11XN69jss7LIZ1XN5hW9JxefdKLu/gruq4vLuOy7vruLy7jsu767i8u47Lu+u4vHsdl3dYDOu4vMO2pOPyHpVc3p/v6tBxeQ8dl/fQcXmPl+kcVaYtDR2X99BxeY86Lu+oGI46Lu+wLem4vEcll3dwV3Vc3kPH5T10XN5Dx+U9dFzeQ8flPXRc3qOOyzsshnVc3mFb0nF5j0ou7+Cu6ri8h47Le+i4vIeOy3vouLyHjst76Li8Rx2Xd1gM67i8w7ak4/IelVze0V01naPqtCUdl/fQcXkPHZf30HF5Dx2X96jj8g6LYR2Xd9iWdFzeo5LLO7qrOm1Jx+U9dFzeQ8flPXRc3kPH5T10XN6jjss7LIZ1XN5hW9JxeY9KLu/oruq0JR2X99BxeQ8dl/fQcXkPHZf30HF5jzou77AY1nF5h21Jx+U9Krm8o7uq05Z0XN5Dx+U9dFzeQ8flPXRc3kPH5T3quLzDYljH5R22JR2X96jk8o7uqk5b0nF5Dx2X99BxeQ8dl/fQcXkPHZf3qOPyDothHZd32JZ0XN6jkss7uqs6bUnH5T10XN5Dx+U9dFzeQ8flPXRc3qOOyzsshnVc3mFb0nF5j0ou7893deq4vKeOy3vquLynjst7vkznqDJtaeq4vGcdl3dUDGcdl3fUlqaOy3tWcnkHd1XH5T11XN5Tx+U9dVzeU8flPXVc3lPH5T3ruLzDYljH5R22JR2X96zk8g7uqo7Le+q4vKeOy3vquLynjst76ri8p47Le9ZxeYfFsI7LO2xLOi7vWcnlHdxVHZf31HF5Tx2X99RxeU8dl/fUcXlPHZf3rOPyDothHZd32JZ0XN6zkss7uqumc1SdtqTj8p46Lu+p4/KeOi7vqePynnVc3mExrOPyDtuSjst7VnJ5R3dVpy3puLynjst76ri8p47Le+q4vKeOy3vWcXmHxbCOyztsSzou71nJ5R3dVZ22pOPynjou76nj8p46Lu+p4/KeOi7vWcflHRbDOi7vsC3puLxnJZd3dFd12pKOy3vquLynjst76ri8p47Le+q4vGcdl3dYDOu4vMO2pOPynpVc3tFd1WlLOi7vqePynjou76nj8p46Lu+p4/KedVzeYTGs4/IO25KOy3tWcnlHd1WmLS0dl/fScXkvHZf30nF5r5fpHFXm3y2tOi7vqBiuOi7vqC0tHZf3quTyDu6qjst76bi8l47Le+m4vJeOy3vpuLyXjst71XF5h8Wwjss7bEs6Lu9VyeUd3FUdl/fScXkvHZf30nF5Lx2X99JxeS8dl/eq4/IOi2Edl3fYlnRc3quSyzu4qzou76Xj8l46Lu+l4/JeOi7vpePyXjou71XH5R0Wwzou77At6bi8VyWXd3BXdVzeS8flvXRc3kvH5b10XN5Lx+W9dFzeq47LOyyGdVzeYVvScXmvSi7v6K6azlF12pKOy3vpuLyXjst76bi8l47Le9VxeYfFsI7LO2xLOi7vVcnlHd1Vnbak4/JeOi7vpePyXjou76Xj8l46Lu9Vx+UdFsM6Lu+wLem4vFcll3d0V3Xako7Le+m4vJeOy3vpuLyXjst76bi8Vx2Xd1gM67i8w7ak4/JelVze0V3VaUs6Lu+l4/JeOi7vpePyXjou76Xj8l51XN5hMazj8g7bko7Le1VyeUd3Vactybi820vG5f0+qkpbeh9VpS29j6rSlt5HNZ2jqrz55H1Ulbb0PqqKy/t9VJW29D6qTluScXm/j6rTlmRc3u+j6rQlGZf3+6gq/27pfVSVN5+8j6rTlmRc3u+j6rQlGZf3+6g6bUnG5f0+qk5bknF5v4+q05ZkXN7vo6q8+eR9VJ22JOPybq9KLu/grsq4vN9H1WlLMi7v91FN56g6bUnG5f0+qsq/W3ofVeXNJ++j6rQlGZf3+6g6bUnG5f0+qk5bknF5v4+q05ZkXN7vo+q0JRmX9/uoKm8+aa86Lu+wLcm4vN9H1WlLMi7v91FN56g6bUnG5f0+qk5bknF5v4+q8++W6ri8w2JYx+UdtiUZl/f7qDptScbl/T6qTluScXm/j6rTlmRc3u+j6rQlGZf3+6gqbz55H1WnLcm4vN9HNZ27qtOWZFze76PqtCUZl/f7qDptScbl/T6qzr9bquPyDothHZd32JZkXN7vo+q0JRmX9/uoOm1JxuX9PqpOW5Jxeb+PqtOWZFze76OqvPnkfVSTaUsyLu/3UXXakozL+31Unbak4/I+dFzeh47L+9BxeR86Lu/jZSrF8Kjj8o7a0qHj8j4qubyjuyrTlg4dl/eh4/I+dFzeh47L+9BxeR86Lu+jjss7LIZ1XN5hW9JxeR+VXN7RXdVpSzou70PH5X3ouLwPHZf3oePyPnRc3kcdl3dYDOu4vMO2pOPyPiq5vIO7quPyPnRc3oeOy/vQcXkfOi7vQ8flfei4vI86Lu+wGNZxeYdtScflfVRyeQd3Vcflfei4vA8dl/eh4/I+dFzeh47L+9BxeR91XN5hMazj8g7bko7L+6jk8g7uqo7L+9BxeR86Lu9Dx+V96Li8Dx2X96Hj8j7quLzDYljH5R22JR2X91HJ5R3cVR2X96Hj8j50XN6Hjsv70HF5Hzou70PH5X3UcXmHxbCOyztsSzou76OSyzu6q6ZzVJ22pOPyPnRc3oeOy/vQcXkfOi7vo47LOyyGdVzeYVvScXkflVze0V3VaUs6Lu9Dx+V96Li8Dx2X96Hj8j50XN5HHZd3WAzruLzDtqTj8j4qubyju6rTlnRc3oeOy/vQcXmfOi7vU8flfeq4vM86Lu+oGJ4vU2lLp47L+6zk8o7uqkxbOnVc3qeOy/vUcXmfOi7vU8flfeq4vM86Lu+wGNZxeYdtScflfVZyeUd3Vact6bi8Tx2X96nj8j51XN6njsv71HF5n3Vc3mExrOPyDtuSjsv7rOTyju6qTlvScXmfOi7vU8flfeq4vE8dl/ep4/I+67i8w2JYx+UdtiUdl/dZyeUd3FUdl/ep4/I+dVzep47L+9RxeZ86Lu9Tx+V91nF5h8Wwjss7bEs6Lu+zkss7uKs6Lu9Tx+V96ri8Tx2X96nj8j51XN6njsv7rOPyDothHZd32JZ0XN5nJZd3cFd1XN6njsv71HF5nzou71PH5X3quLxPHZf3WcflHRbDOi7vsC3puLzPSi7v4K7quLxPHZf3qePyPnVc3qeOy/vUcXmfOi7vs47LOyyGdVzeYVvScXmflVze0V01naPqtCUdl/ep4/I+dVzep47L+9RxeZ91XN5hMazj8g7bko7L+6zk8o7uqk5b0nF5nzou71PH5X3quLwvHZf3pePyvuq4vKNieNVxeUdt6XqZzlFl2tKl4/K+dFzel47L+9JxeV86Lu9Lx+V96bi8rzou77AY1nF5h21Jx+V9VXJ5R3dVpy3puLwvHZf3pePyvnRc3peOy/vScXlfdVzeYTGs4/IO25KOy/uq5PKO7qpOW9JxeV86Lu9Lx+V96bi8Lx2X96Xj8r7quLzDYljH5R22JR2X91XJ5R3dVZ22pOPyvnRc3peOy/vScXlfOi7vS8flfdVxeYfFsI7LO2xLOi7vq5LLO7irOi7vS8flfem4vC8dl/el4/K+dFzel47L+6rj8g6LYR2Xd9iWdFzeVyWXd3BXdVzel47L+9JxeV86Lu9Lx+V96bi8Lx2X91XH5R0Wwzou77At6bi8r0ou7+Cu6ri8Lx2X96Xj8r50XN6Xjsv70nF5Xzou76uOyzsshnVc3mFb0nF5X5Vc3sFd1XF5Xzou70vH5X3puLwvHZf3pePyvnRc3lcdl3dYDOu4vMO2pOPyviq5vKO7ajpH1WlLOi7vS8flfem4vC8dl7fpuLytjss7KoZWx+UdtSXTcXnby3TuqkxbMh2Xt+m4vE3H5W06Lm/TcXmbjsvb6ri8w2JYx+UdtiUdl7dVcnlHd1WnLem4vE3H5W06Lm/TcXmbjsvbdFzeVsflHRbDOi7vsC3puLytkss7uqs6bUnH5W06Lm/TcXmbjsvbdFzepuPytjou77AY1nF5h21Jx+VtlVze0V3VaUs6Lm/TcXmbjsvbdFzepuPyNh2Xt9VxeYfFsI7LO2xLOi5vq+Tyju6qTlvScXmbjsvbdFzepuPyNh2Xt+m4vK2OyzsshnVc3mFb0nF5WyWXd3BXdVzepuPyNh2Xt+m4vE3H5W06Lm/TcXlbHZd3WAzruLzDtqTj8rZKLu/gruq4vE3H5W06Lm/TcXmbjsvbdFzepuPytjou77AY1nF5h21Jx+VtlVzewV3VcXmbjsvbdFzepuPyNh2Xt+m4vE3H5W11XN5hMazj8g7bko7L2yq5vIO7quPyNh2Xt+m4vE3H5W06Lm/TcXmbjsu71XF5R8Ww1XF5R22p6bi8WyWXd3RXTeeoMm2p6bi8m47Lu+m4vJuOy7vpuLxbHZd3WAzruLzDtqTj8m6VXN7RXdVpSzou76bj8m46Lu+m4/JuOi7vpuPybnVc3mExrOPyDtuSjsu7VXJ5R3dVpy3puLybjsu76bi8m47Lu+m4vJuOy7vVcXmHxbCOyztsSzou71bJ5R3dVZ22pOPybjou76bj8m46Lu+m4/JuOi7vVsflHRbDOi7vsC3puLxbJZd3dFd12pKOy7vpuLybjsu76bi8m47Lu+m4vFsdl3dYDOu4vMO2pOPybpVc3tFd1WlLOi7vpuPybjou76bj8m46Lu+m4/JudVzeYTGs4/IO25KOy7tVcnkHd1XH5d10XN5Nx+XddFzeTcfl3XRc3k3H5d3quLzDYljH5R22JR2Xd6vk8g7uqo7Lu+m4vJuOy7vpuLybjsu76bi8m47Lu9VxeYfFsI7LO2xLOi7vVsnlHdxVHZd303F5Nx2Xd9NxeTcdl3fTcXk3HZd3q+Pyjophr+PyjtpS13F590ou7893teu4vPvLdI4q05a6jsu767i8u47Lu+u4vHsdl3dYDOu4vMO2pOPy7pVc3tFdNZ2j6rQlHZd313F5dx2Xd9dxeXcdl3ev4/IOi2Edl3fYlnRc3r2Syzu6qzptScfl3XVc3l3H5d11XN5dx+XddVzevY7LOyyGdVzeYVvScXn3Si7v6K7qtCUdl3fXcXl3HZd313F5dx2Xd9dxefc6Lu+wGNZxeYdtScfl3Su5vKO7qtOWdFzeXcfl3XVc3l3H5d11XN5dx+Xd67i8w2JYx+UdtiUdl3ev5PKO7qpOW9JxeXcdl3fXcXl3HZd313F5dx2Xd6/j8g6LYR2Xd9iWdFzevZLLO7qrOm1Jx+XddVzeXcfl3XVc3l3H5d11XN69jss7LIZ1XN5hW9JxefdKLu/gruq4vLuOy7vruLy7jsu767i8u47Lu+u4vHsdl3dYDOu4vMO2pOPy7pVc3sFd1XF5dx2Xd9dxeXcdl3fXcXl3HZd313F59zou77AY1nF5R21p6Li8RyWX9+e7OnRc3kPH5T1epnNUmbY0dFzeQ8flPXRc3qOOyzsqhqOOyztsSzou71HJ5R3cVR2X99BxeQ8dl/fQcXkPHZf30HF5Dx2X96jj8g6LYR2Xd9iWdFzeo5LLO7qrpnNUnbak4/IeOi7voePyHjou76Hj8h51XN5hMazj8g7bko7Le1RyeUd3Vact6bi8h47Le+i4vIeOy3vouLyHjst71HF5h8Wwjss7bEs6Lu9RyeUd3VWdtqTj8h46Lu+h4/IeOi7voePyHjou71HH5R0Wwzou77At6bi8RyWXd3RXddqSjst76Li8h47Le+i4vIeOy3vouLxHHZd3WAzruLzDtqTj8h6VXN7RXdVpSzou76Hj8h46Lu+h4/IeOi7voePyHnVc3mExrOPyDtuSjst7VHJ5R3dVpy3puLyHjst76Li8h47Le+i4vIeOy3vUcXmHxbCOyztsSzou71HJ5R3cVR2X99BxeQ8dl/fQcXkPHZf30HF5Dx2X96jj8g6LYR2Xd9iWdFzes5LL+/NdnTou76nj8p46Lu/5Mp2jyrSlqePynjou71nH5R0Vw1nH5R22JR2X96zk8g7uqo7Le+q4vKeOy3vquLynjst76ri8p47Le9ZxeYfFsI7LO2xLOi7vWcnlHdxVHZf31HF5Tx2X99RxeU8dl/fUcXlPHZf3rOPyDothHZd32JZ0XN6zkss7uqumc1SdtqTj8p46Lu+p4/KeOi7vqePynnVc3mExrOPyDtuSjst7VnJ5R3dVpy3puLynjst76ri8p47Le+q4vKeOy3vWcXmHxbCOyztsSzou71nJ5R3dVZ22pOPynjou76nj8p46Lu+p4/KeOi7vWcflHRbDOi7vsC3puLxnJZd3dFd12pKOy3vquLynjst76ri8p47Le+q4vGcdl3dYDOu4vMO2pOPynpVc3tFd1WlLOi7vqePynjou76nj8p46Lu+p4/KedVzeYTGs4/IO25KOy3tWcnlHd1WnLem4vKeOy3vquLynjst76ri8p47Le9ZxeYfFsI7LO2xLOi7vWcnl/fmuLh2X99JxeS8dl/fScXmvl+kcVaYtLR2X96rj8o6K4arj8o7a0tJxea9KLu/gruq4vJeOy3vpuLyXjst76bi8l47Le+m4vFcdl3dYDOu4vMO2pOPyXpVc3sFd1XF5Lx2X99JxeS8dl/fScXkvHZf30nF5rzou77AY1nF5h21Jx+W9Krm8g7uq4/JeOi7vpePyXjou76Xj8l46Lu+l4/JedVzeYTGs4/IO25KOy3tVcnlHd9V0jqrTlnRc3kvH5b10XN5Lx+W9dFzeq47LOyyGdVzeYVvScXmvSi7v6K7qtCUdl/fScXkvHZf30nF5Lx2X99Jxea86Lu+wGNZxeYdtScflvSq5vKO7qtOWdFzeS8flvXRc3kvH5b10XN5Lx+W96ri8w2JYx+UdtiUdl/eq5PKO7qpOW9JxeS8dl/fScXkvHZf30nF5Lx2X96rj8g6LYR2Xd9iWdFzeq5LLO7qrOm1Jx+W9dFzeS8flvXRc3kvH5b10XN6rjss7LIZ1XN5hW9Jxea9KLu/orqq0pf6ScXm/j6rSlt5HVWlL76OqtKX3UU3nqCr/bul9VJU3n7yPqtKW3kdVcXm/j6rTlmRc3u+j6rQlGZf3+6g6bUnG5f0+qk5bknF5v4+q8uaT91F12pKMy7u/Krm8g7sq4/J+H1WnLcm4vN9HNZ2j6rQlGZf3+6gq/27pfVSVN5+8j6rTlmRc3u+j6rQlGZf3+6g6bUnG5f0+qk5bknF5v4+q05ZkXN7vo6q8+aS/6ri8w7Yk4/J+H1WnLcm4vN9HNZ2j6rQlGZf3+6g6bUnG5f0+qs6/W6rj8g6LYR2Xd9iWZFze76PqtCUZl/f7qDptScbl/T6qTluScXm/j6rTlmRc3u+jqrz55H1UnbYk4/J+H9V07qpOW5Jxeb+PqtOWZFze76PqtCUZl/f7qDr/bqmOyzsshnVc3mFbknF5v4+q05ZkXN7vo+q0JRmX9/uoOm1JxuX9PqpOW5Jxeb+PqvLmk/dRTaYtybi830fVaUsyLu/3UXXakozLu79kXN7vo+q0JRmX9/uoOv9uqY7LOyyGdVzeYVuScXm/j6rTlmRc3u+jyrSlQ8flfei4vA8dl/eh4/I+XqZzVJU3n7yPKtOWDh2X91HJ5R3dVZ22pOPyPnRc3oeOy/vQcXkfOi7vQ8flfdRxeYfFsI7LO2xLOi7vo5LLO7irOi7vQ8flfei4vA8dl/eh4/I+dFzeh47L+6jj8g6LYR2Xd9iWdFzeRyWXd3BXdVzeh47L+9BxeR86Lu9Dx+V96Li8Dx2X91HH5R0Wwzou77At6bi8j0ou7+Cu6ri8Dx2X96Hj8j50XN6Hjsv70HF5Hzou76OOyzsshnVc3mFb0nF5H5Vc3sFd1XF5Hzou70PH5X3ouLwPHZf3oePyPnRc3kcdl3dYDOu4vMO2pOPyPiq5vKO7ajpH1WlLOi7vQ8flfei4vA8dl/eh4/I+6ri8w2JYx+UdtiUdl/dRyeUd3VWdtqTj8j50XN6Hjsv70HF5Hzou70PH5X3UcXmHxbCOyztsSzou76OSyzu6qzptScflfei4vA8dl/eh4/I+dFzeh47L+6jj8g6LYR2Xd9iWdFzeRyWXd3RXddqSjsv70HF5nzou71PH5X3quLxPHZf3+TKVYnjWcXlHbenUcXmflVze0V2VaUunjsv71HF5nzou71PH5X3quLxPHZf3WcflHRbDOi7vsC3puLzPSi7v6K7qtCUdl/ep4/I+dVzep47L+9RxeZ86Lu+zjss7LIZ1XN5hW9JxeZ+VXN7BXdVxeZ86Lu9Tx+V96ri8Tx2X96nj8j51XN5nHZd3WAzruLzDtqTj8j4rubyDu6rj8j51XN6njsv71HF5nzou71PH5X3quLzPOi7vsBjWcXmHbUnH5X1WcnkHd1XH5X3quLxPHZf3qePyPnVc3qeOy/vUcXmfdVzeYTGs4/IO25KOy/us5PIO7qqOy/vUcXmfOi7vU8flfeq4vE8dl/ep4/I+67i8w2JYx+UdtiUdl/dZyeUd3VXTOapOW9JxeZ86Lu9Tx+V96ri8Tx2X91nH5R0Wwzou77At6bi8z0ou7+iu6rQlHZf3qePyPnVc3qeOy/vUcXmfOi7vs47LOyyGdVzeYVvScXmflVze0V3VaUs6Lu9Tx+V96ri8Lx2X96Xj8r50XN5XHZd3VAyvl6m0pUvH5X1VcnlHd1WmLV06Lu9Lx+V96bi8Lx2X96Xj8r50XN5XHZd3WAzruLzDtqTj8r4qubyju6rTlnRc3peOy/vScXlfOi7vS8flfem4vK86Lu+wGNZxeYdtScflfVVyeUd3Vact6bi8Lx2X96Xj8r50XN6Xjsv70nF5X3Vc3mExrOPyDtuSjsv7quTyDu6qjsv70nF5Xzou70vH5X3puLwvHZf3pePyvuq4vMNiWMflHbYlHZf3VcnlHdxVHZf3pePyvnRc3peOy/vScXlfOi7vS8flfdVxeYfFsI7LO2xLOi7vq5LLO7irOi7vS8flfem4vC8dl/el4/K+dFzel47L+6rj8g6LYR2Xd9iWdFzeVyWXd3BXdVzel47L+9JxeV86Lu9Lx+V96bi8Lx2X91XH5R0Wwzou77At6bi8r0ou7+iums5RddqSjsv70nF5Xzou70vH5X3puLyvOi7vsBjWcXmHbUnH5X1VcnlHd1WnLem4vC8dl/el4/K+dFzepuPyNh2Xt9VxeUfF0Oq4vKO2ZC/TOapMWzIdl7fpuLxNx+VtOi5v03F5m47L23Rc3lbH5R0Wwzou77At6bi8rZLLO7qrOm1Jx+VtOi5v03F5m47L23Rc3qbj8rY6Lu+wGNZxeYdtScflbZVc3tFd1WlLOi5v03F5m47L23Rc3qbj8jYdl7fVcXmHxbCOyztsSzoub6vk8o7uqk5b0nF5m47L23Rc3qbj8jYdl7fpuLytjss7LIZ1XN5hW9JxeVsll3dwV3Vc3qbj8jYdl7fpuLxNx+VtOi5v03F5Wx2Xd1gM67i8w7ak4/K2Si7v4K7quLxNx+VtOi5v03F5m47L23Rc3qbj8rY6Lu+wGNZxeYdtScflbZVc3sFd1XF5m47L23Rc3qbj8jYdl7fpuLxNx+VtdVzeYTGs4/IO25KOy9squbyDu6rj8jYdl7fpuLxNx+VtOi5v03F5m47L2+q4vMNiWMflHbYlHZe3VXJ5R3fVdI6q05Z0XN6m4/I2HZe36bi8m47Lu9VxeUfFsNVxeUdtqem4vNvLdO6qTFtqOi7vpuPybjou76bj8m46Lu+m4/JudVzeYTGs4/IO25KOy7tVcnlHd1WnLem4vJuOy7vpuLybjsu76bi8m47Lu9VxeYfFsI7LO2xLOi7vVsnlHd1Vnbak4/JuOi7vpuPybjou76bj8m46Lu9Wx+UdFsM6Lu+wLem4vFsll3d0V3Xako7Lu+m4vJuOy7vpuLybjsu76bi8Wx2Xd1gM67i8w7ak4/JulVze0V3VaUs6Lu+m4/JuOi7vpuPybjou76bj8m51XN5hMazj8g7bko7Lu1VyeQd3Vcfl3XRc3k3H5d10XN5Nx+XddFzeTcfl3eq4vMNiWMflHbYlHZd3q+TyDu6qjsu76bi8m47Lu+m4vJuOy7vpuLybjsu71XF5h8Wwjss7bEs6Lu9WyeUd3FUdl3fTcXk3HZd303F5Nx2Xd9NxeTcdl3er4/IOi2Edl3fYlnRc3q2Syzu4qzou76bj8m46Lu+m4/JuOi7vpuPybjou717H5R0Vw17H5R21pa7j8u6VXN7RXTWdo8q0pa7j8u46Lu+u4/LuOi7vruPy7nVc3mExrOPyDtuSjsu7V3J5R3dVpy3puLy7jsu767i8u47Lu+u4vLuOy7vXcXmHxbCOyztsSzou717J5R3dVZ22pOPy7jou767j8u46Lu+u4/LuOi7vXsflHRbDOi7vsC3puLx7JZd3dFd12pKOy7vruLy7jsu767i8u47Lu+u4vHsdl3dYDOu4vMO2pOPy7pVc3tFd1WlLOi7vruPy7jou767j8u46Lu+u4/LudVzeYTGs4/IO25KOy7tXcnlHd1WnLem4vLuOy7vruLy7jsu767i8u47Lu9dxeYfFsI7LO2xLOi7vXsnlHdxVHZd313F5dx2Xd9dxeXcdl3fXcXl3HZd3r+PyDothHZd32JZ0XN69kss7uKs6Lu+u4/LuOi7vruPy7jou767j8u46Lu9ex+UdFsM6Lu+wLem4vHsll3dwV3Vc3l3H5d11XN5dx+XddVzeXcfl3XVc3r2OyzsqhqOOyztqS0PH5T0qubw/39Wh4/IeL9M5qkxbGjou76Hj8h46Lu+h4/IedVzeYTGs4/IO25KOy3tUcnlHd9V0jqrTlnRc3kPH5T10XN5Dx+U9dFzeo47LOyyGdVzeYVvScXmPSi7v6K7qtCUdl/fQcXkPHZf30HF5Dx2X99BxeY86Lu+wGNZxeYdtScflPSq5vKO7qtOWdFzeQ8flPXRc3kPH5T10XN5Dx+U96ri8w2JYx+UdtiUdl/eo5PKO7qpOW9JxeQ8dl/fQcXkPHZf30HF5Dx2X96jj8g6LYR2Xd9iWdFzeo5LLO7qrOm1Jx+U9dFzeQ8flPXRc3kPH5T10XN6jjss7LIZ1XN5hW9JxeY9KLu/oruq0JR2X99BxeQ8dl/fQcXkPHZf30HF5jzou77AY1nF5h21Jx+U9Krm8g7uq4/IeOi7voePyHjou76Hj8h46Lu+h4/IedVzeYTGs4/IO25KOy3tUcnkHd1XH5T10XN5Dx+U9dFzeQ8flPXRc3kPH5T3quLzDYljH5R21panj8p6VXN6f7+rUcXlPHZf3fJnOUWXa0tRxeU8dl/fUcXnPOi7vqBjOOi7vsC3puLxnJZd3cFd1XN5Tx+U9dVzeU8flPXVc3lPH5T11XN6zjss7LIZ1XN5hW9Jxec9KLu/orprOUXXako7Le+q4vKeOy3vquLynjst71nF5h8Wwjss7bEs6Lu9ZyeUd3VWdtqTj8p46Lu+p4/KeOi7vqePynjou71nH5R0Wwzou77At6bi8ZyWXd3RXddqSjst76ri8p47Le+q4vKeOy3vquLxnHZd3WAzruLzDtqTj8p6VXN7RXdVpSzou76nj8p46Lu+p4/KeOi7vqePynnVc3mExrOPyDtuSjst7VnJ5R3dVpy3puLynjst76ri8p47Le+q4vKeOy3vWcXmHxbCOyztsSzou71nJ5R3dVZ22pOPynjou76nj8p46Lu+p4/KeOi7vWcflHRbDOi7vsC3puLxnJZd3cFd1XN5Tx+U9dVzeU8flPXVc3lPH5T11XN6zjss7LIZ1XN5hW9Jxea9KLu/Pd3XpuLyXjst76bi818t0jirTlpaOy3vpuLxXHZd3VAxXHZd32JZ0XN6rkss7uKs6Lu+l4/JeOi7vpePyXjou76Xj8l46Lu9Vx+UdFsM6Lu+wLem4vFcll3dwV3Vc3kvH5b10XN5Lx+W9dFzeS8flvXRc3quOyzsshnVc3mFb0nF5r0ou7+iums5RddqSjst76bi8l47Le+m4vJeOy3vVcXmHxbCOyztsSzou71XJ5R3dVZ22pOPyXjou76Xj8l46Lu+l4/JeOi7vVcflHRbDOi7vsC3puLxXJZd3dFd12pKOy3vpuLyXjst76bi8l47Le+m4vFcdl3dYDOu4vMO2pOPyXpVc3tFd1WlLOi7vpePyXjou76Xj8l46Lu+l4/JedVzeYTGs4/IO25KOy3tVcnlHd1WnLem4vJeOy3vpuLyXjst76bi8l47Le9VxeYfFsI7LO2xLOi7vVcnlHd1Vnbak4/JeOi7vpePyXjou76Xj8l46Lu9Vx+UdFsM6Lu+wLem4vFcll/fHuzpeMi7v91FV2tL7qCpt6X1Ulbb0PqrpHFWlLb2PqvLvlt5HVXnzyfuoKm3pfVQVl/d4VXJ5B3dVxuX9PqpOW5Jxeb+PajpH1WlLMi7v91FV/t3S+6gqbz55H1WnLcm4vN9H1WlLMi7v91F12pKMy/t9VJ22JOPyfh9Vpy3JuLzfR1V588l41XF5h21JxuX9PqpOW5Jxeb+PajpH1WlLMi7v91F12pKMy/t9VJ1/t1TH5R0Wwzou77Atybi830fVaUsyLu/3UXXakozL+31UnbYk4/J+H1WnLcm4vN+fU+XNJ+/PqdOWZFze789pOndVpy3JuLzfn1OnLcm4vN+fU6ctybi830fV+XdLdVzeYTGs4/IO25KMy/t9VJ22JOPyfh9Vpy3JuLzfR9VpSzIu7/eH02lLMi7v94dTefPJ+8OZTFuScXn/z4fTuas6bUnG5f3+cDptScbl/T6qTluScXm/j6rz75bquLzDYljH5R22JRmX9/uoOm1JxuX9PqpOW5Jxeb+PqtOWZFze76PqtCUZl/f7qCpvPnkfVactybi830fVaUs6Lu9Dx+V96Li8Dx2X96Hj8j5epnNUmX+3dNRxeUfF8Kjj8o7a0qHj8j4qubyDu6rj8j50XN6Hjsv70HF5Hzou70PH5X3ouLyPOi7vsBjWcXmHbUnH5X1UcnkHd1XH5X3ouLwPHZf3oePyPnRc3oeOy/vQcXkfdVzeYTGs4/IO25KOy/uo5PIO7qqOy/vQcXkfOi7vQ8flfei4vA8dl/eh4/I+6ri8w2JYx+UdtiUdl/dRyeUd3FUdl/eh4/I+dFzeh47L+9BxeR86Lu9Dx+V91HF5h8Wwjss7bEs6Lu+jkss7uqumc1SdtqTj8j50XN6Hjsv70HF5Hzou76OOyzsshnVc3mFb0nF5H5Vc3tFd1WlLOi7vQ8flfei4vA8dl/eh4/I+dFzeRx2Xd1gM67i8w7ak4/I+Krm8o7uq05Z0XN6Hjsv70HF5Hzou70PH5X3ouLyPOi7vsBjWcXmHbUnH5X1UcnlHd1WnLem4vA8dl/eh4/I+dFzeh47L+9BxeR91XN5hMazj8g7bko7L+6jk8o7uqk5b0nF5nzou71PH5X3quLxPHZf3+TKdo8q8+eSs4/KO2tKp4/I+K7m8o7uq05Z0XN6njsv71HF5nzou71PH5X3quLzPOi7vsBjWcXmHbUnH5X1WcnkHd1XH5X3quLxPHZf3qePyPnVc3qeOy/vUcXmfdVzeYTGs4/IO25KOy/us5PIO7qqOy/vUcXmfOi7vU8flfeq4vE8dl/ep4/I+67i8w2JYx+UdtiUdl/dZyeUd3FUdl/ep4/I+dVzep47L+9RxeZ86Lu9Tx+V91nF5h8Wwjss7bEs6Lu+zkss7uKs6Lu9Tx+V96ri8Tx2X96nj8j51XN6njsv7rOPyDothHZd32JZ0XN5nJZd3dFdN56g6bUnH5X3quLxPHZf3qePyPnVc3mcdl3dYDOu4vMO2pOPyPiu5vKO7qtOWdFzep47L+9RxeZ86Lu9Tx+V96ri8zzou77AY1nF5h21Jx+V9VnJ5R3dVpy3puLxPHZf3qePyPnVc3qeOy/vUcXmfdVzeYTGs4/IO25KOy/us5PKO7qpOW9JxeZ86Lu9Lx+V96bi8Lx2X96Xj8r5eplIMrzou76gtXTou76uSyzu6qzJt6dJxeV86Lu9Lx+V96bi8Lx2X96Xj8r7quLzDYljH5R22JR2X91XJ5R3dVZ22pOPyvnRc3peOy/vScXlfOi7vS8flfdVxeYfFsI7LO2xLOi7vq5LLO7irOi7vS8flfem4vC8dl/el4/K+dFzel47L+6rj8g6LYR2Xd9iWdFzeVyWXd3BXdVzel47L+9JxeV86Lu9Lx+V96bi8Lx2X91XH5R0Wwzou77At6bi8r0ou7+Cu6ri8Lx2X96Xj8r50XN6Xjsv70nF5Xzou76uOyzsshnVc3mFb0nF5X5Vc3sFd1XF5Xzou70vH5X3puLwvHZf3pePyvnRc3lcdl3dYDOu4vMO2pOPyviq5vKO7ajpH1WlLOi7vS8flfem4vC8dl/el4/K+6ri8w2JYx+UdtiUdl/dVyeUd3VWdtqTj8r50XN6Xjsv70nF5Xzou70vH5X3VcXmHxbCOyztsSzou76uSyzu6qzptScflfem4vC8dl7fpuLxNx+VtOi5vq+PyjoqhvUylLZmOy9squbyjuyrTlkzH5W06Lm/TcXmbjsvbdFzepuPytjou77AY1nF5h21Jx+VtlVze0V3VaUs6Lm/TcXmbjsvbdFzepuPyNh2Xt9VxeYfFsI7LO2xLOi5vq+Tyju6qTlvScXmbjsvbdFzepuPyNh2Xt+m4vK2OyzsshnVc3mFb0nF5WyWXd3BXdVzepuPyNh2Xt+m4vE3H5W06Lm/TcXlbHZd3WAzruLzDtqTj8rZKLu/gruq4vE3H5W06Lm/TcXmbjsvbdFzepuPytjou77AY1nF5h21Jx+VtlVzewV3VcXmbjsvbdFzepuPyNh2Xt+m4vE3H5W11XN5hMazj8g7bko7L2yq5vIO7quPyNh2Xt+m4vE3H5W06Lm/TcXmbjsvb6ri8w2JYx+UdtiUdl7dVcnlHd9V0jqrTlnRc3qbj8jYdl7fpuLxNx+VtdVzeYTGs4/IO25KOy9squbyju6rTlnRc3qbj8jYdl7fpuLybjsu76bi8Wx2Xd1QMWx2Xd9SW2st0jirTlpqOy7vpuLybjsu76bi8m47Lu+m4vJuOy7vVcXmHxbCOyztsSzou71bJ5R3dVZ22pOPybjou76bj8m46Lu+m4/JuOi7vVsflHRbDOi7vsC3puLxbJZd3dFd12pKOy7vpuLybjsu76bi8m47Lu+m4vFsdl3dYDOu4vMO2pOPybpVc3tFd1WlLOi7vpuPybjou76bj8m46Lu+m4/JudVzeYTGs4/IO25KOy7tVcnkHd1XH5d10XN5Nx+XddFzeTcfl3XRc3k3H5d3quLzDYljH5R22JR2Xd6vk8g7uqo7Lu+m4vJuOy7vpuLybjsu76bi8m47Lu9VxeYfFsI7LO2xLOi7vVsnlHdxVHZd303F5Nx2Xd9NxeTcdl3fTcXk3HZd3q+PyDothHZd32JZ0XN6tkss7uKs6Lu+m4/JuOi7vpuPybjou76bj8m46Lu9Wx+UdFsM6Lu+wLem4vFsll3d0V03nqDptScfl3XRc3k3H5d10XN5dx+Xd67i8o2LY67i8o7bUdVze/WU6d1WmLXUdl3fXcXl3HZd313F5dx2Xd9dxefc6Lu+wGNZxeYdtScfl3Su5vKO7qtOWdFzeXcfl3XVc3l3H5d11XN5dx+Xd67i8w2JYx+UdtiUdl3ev5PKO7qpOW9JxeXcdl3fXcXl3HZd313F5dx2Xd6/j8g6LYR2Xd9iWdFzevZLLO7qrOm1Jx+XddVzeXcfl3XVc3l3H5d11XN69jss7LIZ1XN5hW9JxefdKLu/oruq0JR2Xd9dxeXcdl3fXcXl3HZd313F59zou77AY1nF5h21Jx+XdK7m8g7uq4/LuOi7vruPy7jou767j8u46Lu+u4/LudVzeYTGs4/IO25KOy7tXcnkHd1XH5d11XN5dx+XddVzeXcfl3XVc3l3H5d3ruLzDYljH5R22JR2Xd6/k8g7uqo7Lu+u4vLuOy7vruLy7jsu767i8u47Lu9dxeYfFsI7LO2xLOi7vXsnlHdxVHZd313F5dx2Xd9dxeXcdl3fXcXl3HZf3qOPyjorhqOPyjtrS0HF5j0ou7+iums5RZdrS0HF5Dx2X99BxeQ8dl/fQcXmPOi7vsBjWcXmHbUnH5T0qubyju6rTlnRc3kPH5T10XN5Dx+U9dFzeQ8flPeq4vMNiWMflHbYlHZf3qOTyju6qTlvScXkPHZf30HF5Dx2X99BxeQ8dl/eo4/IOi2Edl3fYlnRc3qOSyzu6qzptScflPXRc3kPH5T10XN5Dx+U9dFzeo47LOyyGdVzeYVvScXmPSi7v6K7qtCUdl/fQcXkPHZf30HF5Dx2X99BxeY86Lu+wGNZxeYdtScflPSq5vKO7qtOWdFzeQ8flPXRc3kPH5T10XN5Dx+U96ri8w2JYx+UdtiUdl/eo5PIO7qqOy3vouLyHjst76Li8h47Le+i4vIeOy3vUcXmHxbCOyztsSzou71HJ5R3cVR2X99BxeQ8dl/fQcXkPHZf30HF5Dx2X96jj8g6LYR2Xd9iWdFzeo5LLO7irOi7voePyHjou76Hj8h46Lu+h4/IeOi7vUcflHRXDWcflHbWlqePynpVc3p/v6tRxec+X6RxVpi1NHZf31HF5Tx2X99Rxec86Lu+wGNZxeYdtScflPSu5vKO7ajpH1WlLOi7vqePynjou76nj8p46Lu9Zx+UdFsM6Lu+wLem4vGcll3d0V3Xako7Le+q4vKeOy3vquLynjst76ri8Zx2Xd1gM67i8w7ak4/KelVze0V3VaUs6Lu+p4/KeOi7vqePynjou76nj8p51XN5hMazj8g7bko7Le1ZyeUd3Vact6bi8p47Le+q4vKeOy3vquLynjst71nF5h8Wwjss7bEs6Lu9ZyeUd3VWdtqTj8p46Lu+p4/KeOi7vqePynjou71nH5R0Wwzou77At6bi8ZyWXd3RXddqSjst76ri8p47Le+q4vKeOy3vquLxnHZd3WAzruLzDtqTj8p6VXN7BXdVxeU8dl/fUcXlPHZf31HF5Tx2X99Rxec86Lu+wGNZxeYdtScflPSu5vIO7quPynjou76nj8p46Lu+p4/KeOi7vqePynnVc3mExrOPyjtrS0nF5r0ou7893dem4vJeOy3u9TOeoMm1p6bi8l47Le+m4vFcdl3dUDFcdl3fYlnRc3quSyzu4qzou76Xj8l46Lu+l4/JeOi7vpePyXjou71XH5R0Wwzou77At6bi8VyWXd3RXTeeoOm1Jx+W9dFzeS8flvXRc3kvH5b3quLzDYljH5R22JR2X96rk8o7uqk5b0nF5Lx2X99JxeS8dl/fScXkvHZf3quPyDothHZd32JZ0XN6rkss7uqs6bUnH5b10XN5Lx+W9dFzeS8flvXRc3quOyzsshnVc3mFb0nF5r0ou7+iu6rQlHZf30nF5Lx2X99JxeS8dl/fScXmvOi7vsBjWcXmHbUnH5b0qubyju6rTlnRc3kvH5b10XN5Lx+W9dFzeS8flveq4vMNiWMflHbYlHZf3quTyju6qTlvScXkvHZf30nF5Lx2X99JxeS8dl/eq4/IOi2Edl3fYlnRc3quSyzu4qzou76Xj8l46Lu+l4/JeOi7vpePyXjou71XH5R0Wwzou77Atybi856uSy/vjXX0fVaUtvY+q0pbeR1VpS++jms5RVdrS+6gqbel9VJV/t/Q+qsqbT95H1WlLMi7v91F12pKMy/t9VJ22JOPyfh9Vpy3JuLzfR9VpSzIu7/dRVd58Ml91XN5hW5Jxeb+PqtOWZFze76OazlF12pKMy/t9VJ22JOPyfh9V5d8tzVcdl3dYDOu4vMO2JOPyfh9Vpy3JuLzfR9VpSzIu7/dRddqSjMv7fVSdtiTj8n4fVeXNJ++j6rQlGZf3+6imc1d12pKMy/t9VJ22JOPyfh9Vpy3JuLzfR9X5d0t1XN5hMazj8g7bkozL+31UnbYk4/J+H1WnLcm4vN9H1WlLMi7v91F12pKMy/t9VJU3n7yPajJtScbl/T6qTluScXm/j6rTlmRc3vMl4/J+H1WnLcm4vN9H1fl3S3Vc3mExrOPyDtuSjMv7fVSdtiTj8n4fVactybi830fVaUsyLu/3UXXakozL+31UlTefvI+q05ZkXN7vo+q0JRmX93zJuLzfR9VpSzIu7/dRddqSjMv7fVSdf7dUx+UdFsM6Lu+wLcm4vN9HlWlLh47L+9BxeR86Lu9Dx+V9vEznqDJt6dBxeR91XN5RMTzquLyjtnTouLyPSi7v4K7quLwPHZf3oePyPnRc3oeOy/vQcXkfOi7vo47LOyyGdVzeYVvScXkflVzewV3VcXkfOi7vQ8flfei4vA8dl/eh4/I+dFzeRx2Xd1gM67i8w7ak4/I+Krm8g7uq4/I+dFzeh47L+9BxeR86Lu9Dx+V96Li8jzou77AY1nF5h21Jx+V9VHJ5R3fVdI6q05Z0XN6Hjsv70HF5Hzou70PH5X3UcXmHxbCOyztsSzou76OSyzu6qzptScflfei4vA8dl/eh4/I+dFzeh47L+6jj8g6LYR2Xd9iWdFzeRyWXd3RXddqSjsv70HF5Hzou70PH5X3ouLwPHZf3UcflHRbDOi7vsC3puLyPSi7v6K7qtCUdl/eh4/I+dFzeh47L+9BxeR86Lu+jjss7LIZ1XN5hW9JxeR+VXN7RXdVpSzou70PH5X3ouLwPHZf3oePyPnRc3kcdl3dYDOu4vMO2pOPyPiq5vKO7KtOWTh2X96nj8j51XN6njsv7fJnOUWX+3dJZx+UdFcOzjss7akunjsv7rOTyDu6qjsv71HF5nzou71PH5X3quLxPHZf3qePyPuu4vMNiWMflHbYlHZf3WcnlHdxVHZf3qePyPnVc3qeOy/vUcXmfOi7vU8flfdZxeYfFsI7LO2xLOi7vs5LLO7irOi7vU8flfeq4vE8dl/ep4/I+dVzep47L+6zj8g6LYR2Xd9iWdFzeZyWXd3BXdVzep47L+9RxeZ86Lu9Tx+V96ri8Tx2X91nH5R0Wwzou77At6bi8z0ou7+iums5RddqSjsv71HF5nzou71PH5X3quLzPOi7vsBjWcXmHbUnH5X1WcnlHd1WnLem4vE8dl/ep4/I+dVzep47L+9RxeZ91XN5hMazj8g7bko7L+6zk8o7uqk5b0nF5nzou71PH5X3quLxPHZf3qePyPuu4vMNiWMflHbYlHZf3WcnlHd1Vnbak4/I+dVzep47L+9RxeZ86Lu9Tx+V91nF5h8Wwjss7bEs6Lu+zkss7uqs6bUnH5X3puLwvHZf3pePyvnRc3tfLdI4q8+aTq47LO2pLl47L+6rk8o7uqk5b0nF5Xzou70vH5X3puLwvHZf3pePyvuq4vMNiWMflHbYlHZf3VcnlHdxVHZf3pePyvnRc3peOy/vScXlfOi7vS8flfdVxeYfFsI7LO2xLOi7vq5LLO7irOi7vS8flfem4vC8dl/el4/K+dFzel47L+6rj8g6LYR2Xd9iWdFzeVyWXd3BXdVzel47L+9JxeV86Lu9Lx+V96bi8Lx2X91XH5R0Wwzou77At6bi8r0ou7+Cu6ri8Lx2X96Xj8r50XN6Xjsv70nF5Xzou76uOyzsshnVc3mFb0nF5X5Vc3tFdNZ2j6rQlHZf3pePyvnRc3peOy/vScXlfdVzeYTGs4/IO25KOy/uq5PKO7qpOW9JxeV86Lu9Lx+V96bi8Lx2X96Xj8r7quLzDYljH5R22JR2X91XJ5R3dVZ22pOPyvnRc3peOy/vScXlfOi7vS8flfdVxeYfFsI7LO2xLOi7vq5LLO7qrOm1Jx+V96bi8TcflbToub9NxeZuOy9teplIMrY7LO2pLpuPytkou7+iuyrQl03F5m47L23Rc3qbj8jYdl7fpuLytjss7LIZ1XN5hW9JxeVsll3d0V3Xako7L23Rc3qbj8jYdl7fpuLxNx+VtdVzeYTGs4/IO25KOy9squbyDu6rj8jYdl7fpuLxNx+VtOi5v03F5m47L2+q4vMNiWMflHbYlHZe3VXJ5B3dVx+VtOi5v03F5m47L23Rc3qbj8jYdl7fVcXmHxbCOyztsSzoub6vk8g7uqo7L23Rc3qbj8jYdl7fpuLxNx+VtOi5vq+PyDothHZd32JZ0XN5WyeUd3FUdl7fpuLxNx+VtOi5v03F5m47L23Rc3lbH5R0Wwzou77At6bi8rZLLO7qrpnNUnbak4/I2HZe36bi8TcflbToub6vj8g6LYR2Xd9iWdFzeVsnlHd1Vnbak4/I2HZe36bi8TcflbToub9NxeVsdl3dYDOu4vMO2pOPytkou7+iu6rQlHZe36bi8Tcfl3XRc3k3H5d10XN6tjss7KobtZSptqem4vFsll3d0V2XaUtNxeTcdl3fTcXk3HZd303F5Nx2Xd6vj8g6LYR2Xd9iWdFzerZLLO7qrOm1Jx+XddFzeTcfl3XRc3k3H5d10XN6tjss7LIZ1XN5hW9JxebdKLu/oruq0JR2Xd9NxeTcdl3fTcXk3HZd303F5tzou77AY1nF5h21Jx+XdKrm8g7uq4/JuOi7vpuPybjou76bj8m46Lu+m4/JudVzeYTGs4/IO25KOy7tVcnkHd1XH5d10XN5Nx+XddFzeTcfl3XRc3k3H5d3quLzDYljH5R22JR2Xd6vk8g7uqo7Lu+m4vJuOy7vpuLybjsu76bi8m47Lu9VxeYfFsI7LO2xLOi7vVsnlHdxVHZd303F5Nx2Xd9NxeTcdl3fTcXk3HZd3q+PyDothHZd32JZ0XN6tkss7uqumc1SdtqTj8m46Lu+m4/JuOi7vpuPybnVc3mExrOPyDtuSjsu7VXJ5R3dVpy3puLybjsu76bi8m47Lu+u4vLuOy7vXcXlHxbDXcXlHbam/TOeoMm2p67i8u47Lu+u4vLuOy7vruLy7jsu767i8ex2Xd1gM67i8w7ak4/LulVze0V3VaUs6Lu+u4/LuOi7vruPy7jou767j8u51XN5hMazj8g7bko7Lu1dyeUd3Vact6bi8u47Lu+u4vLuOy7vruLy7jsu713F5h8Wwjss7bEs6Lu9eyeUd3VWdtqTj8u46Lu+u4/LuOi7vruPy7jou717H5R0Wwzou77At6bi8eyWXd3BXdVzeXcfl3XVc3l3H5d11XN5dx+XddVzevY7LOyyGdVzeYVvScXn3Si7v4K7quLy7jsu767i8u47Lu+u4vLuOy7vruLx7HZd3WAzruLzDtqTj8u6VXN7BXdVxeXcdl3fXcXl3HZd313F5dx2Xd9dxefc6Lu+wGNZxeYdtScfl3Su5vIO7quPy7jou767j8u46Lu+u4/LuOi7vruPy7nVc3mExrOPyDtuSjsu7V3J5R3fVdI6q05Z0XN5dx+XddVzeXcflPXRc3qOOyzsqhqOOyztqS0PH5T1epnNXZdrS0HF5Dx2X99BxeQ8dl/fQcXkPHZf3qOPyDothHZd32JZ0XN6jkss7uqs6bUnH5T10XN5Dx+U9dFzeQ8flPXRc3qOOyzsshnVc3mFb0nF5j0ou7+iu6rQlHZf30HF5Dx2X99BxeQ8dl/fQcXmPOi7vsBjWcXmHbUnH5T0qubyju6rTlnRc3kPH5T10XN5Dx+U9dFzeQ8flPeq4vMNiWMflHbYlHZf3qOTyju6qTlvScXkPHZf30HF5Dx2X99BxeQ8dl/eo4/IOi2Edl3fYlnRc3qOSyzu4qzou76Hj8h46Lu+h4/IeOi7voePyHjou71HH5R0Wwzou77At6bi8RyWXd3BXdVzeQ8flPXRc3kPH5T10XN5Dx+U9dFzeo47LOyyGdVzeYVvScXmPSi7v4K7quLyHjst76Li8h47Le+i4vIeOy3vouLxHHZd3WAzruLzDtqTj8h6VXN7BXdVxeQ8dl/fQcXkPHZf30HF5Dx2X99Bxec86Lu+oGM46Lu+oLU0dl/es5PKO7qrpHFWmLU0dl/fUcXlPHZf31HF5Tx2X96zj8g6LYR2Xd9iWdFzes5LLO7qrOm1Jx+U9dVzeU8flPXVc3lPH5T11XN6zjss7LIZ1XN5hW9Jxec9KLu/oruq0JR2X99RxeU8dl/fUcXlPHZf31HF5zzou77AY1nF5h21Jx+U9K7m8o7uq05Z0XN5Tx+U9dVzeU8flPXVc3lPH5T3ruLzDYljH5R22JR2X96zk8o7uqk5b0nF5Tx2X99RxeU8dl/fUcXlPHZf3rOPyDothHZd32JZ0XN6zkss7uqs6bUnH5T11XN5Tx+U9dVzeU8flPXVc3rOOyzsshnVc3mFb0nF5z0ou7+Cu6ri8p47Le+q4vKeOy3vquLynjst76ri8Zx2Xd1gM67i8w7ak4/KelVzewV3VcXlPHZf31HF5Tx2X99RxeU8dl/fUcXnPOi7vsBjWcXmHbUnH5T0rubyDu6rj8p46Lu+p4/KeOi7vqePynjou76nj8p51XN5RMVx1XN5RW1o6Lu9VyeX9+a4uHZf3epnOUWXa0tJxeS8dl/fScXkvHZf3quPyDothHZd32JZ0XN6rkss7uqumc1SdtqTj8l46Lu+l4/JeOi7vpePyXnVc3mExrOPyDtuSjst7VXJ5R3dVpy3puLyXjst76bi8l47Le+m4vJeOy3vVcXmHxbCOyztsSzou71XJ5R3dVZ22pOPyXjou76Xj8l46Lu+l4/JeOi7vVcflHRbDOi7vsC3puLxXJZd3dFd12pKOy3vpuLyXjst76bi8l47Le+m4vFcdl3dYDOu4vMO2pOPyXpVc3tFd1WlLOi7vpePyXjou76Xj8l46Lu+l4/JedVzeYTGs4/IO25KOy3tVcnlHd1WnLem4vJeOy3vpuLyXjst76bi8l47Le9VxeYfFsI7LO2xLOi7vVcnlHdxVHZf30nF5Lx2X99JxeS8dl/fScXkvHZf3quPyDothHZd32JZ0XN6rkss7uKs6Lu+l4/JeOi7vpePyXjou76Xj8l46Lu9Vx+UdFsM6Lu+gLa2XjMv7fVSVtvQ+qkpbeh9VpS29j2o6R1VpS++jqrSl91FV2tL7qCr/bul9VJU3n6xXHZd32JZkXN7vo+q0JRmX9/uopnNUnbYk4/J+H1WnLcm4vN9HVfl3S+tVx+UdFsM6Lu+wLcm4vN9H1WlLMi7v91F12pKMy/t9VJ22JOPyfh9Vpy3JuLzfR1V588n7qGXakh32c1Rrd0+1TFuKj2pVjnpZ/9+j/t8A3/x5O/73arfjOn7+fPwBU6ZbZYMp08SywZTpbdlgyrS8/xDM1a8fMNe4AVOmEyaDqeM3zwZTpm9mgynTTrPBlOmy2WAMMPdgVJtvCEa1+YZgVJtvCIbm64Ch+d6DqeOqzwZD83XA0HwdMDRfB4wB5h4MzdcBQ/N1wNB8HTA0XwcMzfceTJ33DmSDofk6YGi+DhiarwPGAHMPhubrgKH5OmBovg4Ymq8DhuZ7D6bOOySywdB8HTA0XwcMzdcBY4C5B0PzdcDQfB0wNF8HDM3XAUPzvQdT530g2WBovg4Ymq8DhubrgDHA3IOh+TpgaL4OGJqvA4bm64Ch+d6DqfNul2wwNF8HDM3XAUPzdcAYYO7B0HwdMDRfBwzN1wFD83XA0HxvwRx13tOTDYbm64Ch+TpgaL4OGAPMPRiarwOG5uuAofk6YGi+Dhia7z2YOu9cygZD83XA0HwdMDRfB4wB5h4MzdcBQ/N1wNB8HTA0XwcMzfceTJ33Z2WDofk6YGi+DhiarwPGAHMPhubrgKH5OmBovg4Ymq8DhuZ7D6bOu9CywdB8HTA0XwcMzdcBY4C5B0PzdcDQfB0wNF8HDM3XAUPzvQfDO9w8MDRfBwzN1wFD83XAGGDuwdB8HTA0XwcMzdcBQ/N1wNB878HwDjcPDM3XAUPzdcDQfB0wBph7MDRfBwzN1wFD83XA0HwdMDTfezC8w80DQ/N1wNB8HTA0XweMAeYeDM3XAUPzdcDQfB0wNF8HDM33HgzvcPPA0HwdMDRfBwzN1wFjgLkHQ/N1wNB8HTA0XwcMzdcBQ/O9B8M73DwwNF8HDM3XAUPzdcAYYO7B0HwdMDRfBwzN1wFD83XA0HzvwfAONw8MzdcBQ/N1wNB8HTAGmHswNF8HDM3XAUPzdcDQfB0wNN9bMCfvcPPA0HwdMDRfBwzN1wFjgLkHQ/N1wNB8HTA0XwcMzdcBQ/O9B8M73DwwNF8HDM3XAUPzdcAYYO7B0HwdMDRfBwzN1wFD83XA0HzvwfAONw8MzdcBQ/N1wNB8HTAGmHswNF8HDM3XAUPzdcDQfB0wNN97MLzDzQND83XA0HwdMDRfB4wB5h4MzdcBQ/N1wNB8HTA0XwcMzfceDO9w88DQfB0wNF8HDM3XAWOAuQdD83XA0HwdMDRfBwzN1wFD870HwzvcPDA0XwcMzdcBQ/N1wBhg7sHQfB0wNF8HDM3XAUPzdcDQfO/B8A43DwzN1wFD83XA0HwdMAaYezA0XwcMzdcBQ/N1wNB8HTA033swvMPNA0PzdcDQfB0wNF8HjAHmHgzN1wFD83XA0HwdMDRfBwzN9x4M73DzwNB8HTA0XwcMzdcBY4C5B0PzdcDQfB0wNF8HDM3XAUPzvQfDO9w8MDRfBwzN1wFD83XAGGDuwdB8HTA0XwcMzdcBQ/N1wNB8b8FcvMPNA0PzdcDQfB0wNF8HjAHmHgzN1wFD83XA0HwdMDRfBwzN9x4M73DzwNB8HTA0XwcMzdcBY4C5B0PzdcDQfB0wNF8HDM3XAUPzvQfDO9w8MDRfBwzN1wFD83XAGGDuwdB8HTA0XwcMzdcBQ/N1wNB878HwDjcPDM3XAUPzdcDQfB0wBph7MDRfBwzN1wFD83XA0HwdMDTfezC8w80DQ/N1wNB8HTA0XweMAeYeDM3XAUPzdcDQfB0wNF8HDM33HgzvcPPA0HwdMDRfBwzN1wFjgLkHQ/N1wNB8HTA0XwcMzdcBQ/O9B8M73DwwNF8HDM3XAUPzdcAYYO7B0HwdMDRfBwzN1wFD83XA0HzvwfAONw8MzdcBQ/N1wNB8HTAGmHswNF8HDM3XAUPzdcDQfB0wNN97MLzDzQND83XA0HwdMDRfB4wB5h4MzdcBQ/N1wNB8HTA0XwcMzfceDO9w88DQfB0wNF8HDM3XAWOAuQdD83XA0HwdMDRfBwzN1wFD870FY7zDzQND83XA0HwdMDRfB4wB5h4MzdcBQ/N1wNB8HTA0XwcMzfceDO9w88DQfB0wNF8HDM3XAWOAuQdD83XA0HwdMDRfBwzN1wFD870HwzvcPDA0XwcMzdcBQ/N1wBhg7sHQfB0wNF8HDM3XAUPzdcDQfO/B8A43DwzN1wFD83XA0HwdMAaYezA0XwcMzdcBQ/N1wNB8HTA033swvMPNA0PzdcDQfB0wNF8HjAHmHgzN1wFD83XA0HwdMDRfBwzN9x4M73DzwNB8HTA0XwcMzdcBY4C5B0PzdcDQfB0wNF8HDM3XAUPzvQfDO9w8MDRfBwzN1wFD83XAGGDuwdB8HTA0XwcMzdcBQ/N1wNB878HwDjcPDM3XAUPzdcDQfB0wBph7MDRfBwzN1wFD83XA0HwdMDTfezC8w80DQ/N1wNB8HTA0XweMAeYeDM3XAUPzdcDQfB0wNF8HDM33HgzvcPPA0HwdMDRfBwzN1wFjgLkHQ/N1wNB8HTA0XwcMzdcBQ/O9BdN4h5sHhubrgKH5OmBovg4YA8w9GJqvA4bm64Ch+TpgaL4OGJrvPRje4eaBofk6YGi+DhiarwPGAHMPhubrgKH5OmBovg4Ymq8DhuZ7D4Z3uHlgaL4OGJqvA4bm64AxwNyDofk6YGi+DhiarwOG5uuAofneg+Edbh4Ymq8DhubrgKH5OmAMMPdgaL4OGJqvA4bm64Ch+TpgaL73YHiHmweG5uuAofk6YGi+DhgDzD0Ymq8DhubrgKH5OmBovg4Ymu89GN7h5oGh+TpgaL4OGJqvA8YAcw+G5uuAofk6YGi+DhiarwOG5nsPhne4eWBovg4Ymq8DhubrgDHA3IOh+TpgaL4OGJqvA4bm64Ch+d6D4R1uHhiarwOG5uuAofk6YAww92Bovg4Ymq8DhubrgKH5OmBovvdgeIebB4bm64Ch+TpgaL4OGAPMPRiarwOG5uuAofk6YGi+Dhia7z0Y3uHmgaH5OmBovg4Ymq8DxgBzD4bm64Ch+TpgaL4OGJqvA4bmewum8w43DwzN1wFD83XA0HwdMAaYezA0XwcMzdcBQ/N1wNB8HTA033swvMPNA0PzdcDQfB0wNF8HjAHmHgzN1wFD83XA0HwdMDRfBwzN9x4M73DzwNB8HTA0XwcMzdcBY4C5B0PzdcDQfB0wNF8HDM3XAUPzvQfDO9w8MDRfBwzN1wFD83XAGGDuwdB8HTA0XwcMzdcBQ/N1wNB878HwDjcPDM3XAUPzdcDQfB0wBph7MDRfBwzN1wFD83XA0HwdMDTfezC8w80DQ/N1wNB8HTA0XweMAeYeDM3XAUPzdcDQfB0wNF8HDM33HgzvcPPA0HwdMDRfBwzN1wFjgLkHQ/N1wNB8HTA0XwcMzdcBQ/O9B8M73DwwNF8HDM3XAUPzdcAYYO7B0HwdMDRfBwzN1wFD83XA0HzvwfAONw8MzdcBQ/N1wNB8HTAGmHswNF8HDM3XAUPzdcDQfB0wNN97MLzDzQND83XA0HwdMDRfB4wB5h4MzdcBQ/N1wNB8HTA0XwcMzfcWzOAdbh4Ymq8DhubrgKH5OmAMMPdgaL4OGJqvA4bm64Ch+TpgaL73YHiHmweG5uuAofk6YGi+DhgDzD0Ymq8DhubrgKH5OmBovg4Ymu89GN7h5oGh+TpgaL4OGJqvA8YAcw+G5uuAofk6YGi+DhiarwOG5nsPhne4eWBovg4Ymq8DhubrgDHA3IOh+TpgaL4OGJqvA4bm64Ch+d6D4R1uHhiarwOG5uuAofk6YAww92Bovg4Ymq8DhubrgKH5OmBovvdgeIebB4bm64Ch+TpgaL4OGAPMPRiarwOG5uuAofk6YGi+Dhia7z0Y3uHmgaH5OmBovg4Ymq8DxgBzD4bm64Ch+TpgaL4OGJqvA4bmew+Gd7h5YGi+DhiarwOG5uuAMcDcg6H5OmBovg4Ymq8DhubrgKH53oPhHW4eGJqvA4bm64Ch+TpgDDD3YGi+DhiarwOG5uuAofk6YGi+92B4h5sHhubrgKH5OmBovg4YA8w9GJqvA4bm64Ch+TpgaL4OGJrvLZjJO9w8MDRfBwzN1wFD83XAGGDuwdB8HTA0XwcMzdcBQ/N1wNB878HwDjcPDM3XAUPzdcDQfB0wBph7MDRfBwzN1wFD83XA0HwdMDTfezC8w80DQ/N1wNB8HTA0XweMAeYeDM3XAUPzdcDQfB0wNF8HDM33HgzvcPPA0HwdMDRfBwzN1wFjgLkHQ/N1wNB8HTA0XwcMzdcBQ/O9B8M73DwwNF8HDM3XAUPzdcAYYO7B0HwdMDRfBwzN1wFD83XA0HzvwfAONw8MzdcBQ/N1wNB8HTAGmHswNF8HDM3XAUPzdcDQfB0wNN97MLzDzQND83XA0HwdMDRfB4wB5h4MzdcBQ/N1wNB8HTA0XwcMzfceDO9w88DQfB0wNF8HDM3XAWOAuQdD83XA0HwdMDRfBwzN1wFD870HwzvcPDA0XwcMzdcBQ/N1wBhg7sHQfB0wNF8HDM3XAUPzdcDQfO/B8A43DwzN1wFD83XA0HwdMAaYezA0XwcMzdcBQ/N1wNB8HTA031swi3e4eWBovg4Ymq8DhubrgDHA3IOh+TpgaL4OGJqvA4bm64Ch+d6D4R1uHhiarwOG5uuAofk6YAww92Bovg4Ymq8DhubrgKH5OmBovvdgeIebB4bm64Ch+TpgaL4OGAPMPRiarwOG5uuAofk6YGi+Dhia7z0Y3uHmgaH5OmBovg4Ymq8DxgBzD4bm64Ch+TpgaL4OGJqvA4bmew+Gd7h5YGi+DhiarwOG5uuAMcDcg6H5OmBovg4Ymq8DhubrgKH53oPhHW4eGJqvA4bm64Ch+TpgDDD3YGi+DhiarwOG5uuAofk6YGi+92B4h5sHhubrgKH5OmBovg4YA8w9GJqvA4bm64Ch+TpgaL4OGJrvPRje4eaBofk6YGi+DhiarwPGAHMPhubrgKH5OmBovg4Ymq8DhuZ7D4Z3uHlgaL4OGJqvA4bm64AxwNyDofk6YGi+DhiarwOG5uuAofneg+Edbh4Ymq8DhubrgKH5OmAMMPdgaL4OGJqvA4bm64Ch+TpgaL43YM7Xi3e4eWBovg4Ymq8DhubrgDHA3IOh+TpgaL4OGJqvA4bm64Ch+d6D4R1uHhiarwOG5uuAofk6YAww92Bovg4Ymq8DhubrgKH5OmBovvdgeIebB4bm64Ch+TpgaL4OGAPMPRiarwOG5uuAofk6YGi+Dhia7z0Y3uHmgaH5OmBovg4Ymq8DxgBzD4bm64Ch+TpgaL4OGJqvA4bmew+Gd7h5YGi+DhiarwOG5uuAMcDcg6H5OmBovg4Ymq8DhubrgKH53oPhHW4eGJqvA4bm64Ch+TpgDDD3YGi+DhiarwOG5uuAofk6YGi+92B4h5sHhubrgKH5OmBovg4YA8w9GJqvA4bm64Ch+TpgaL4OGJrvPRje4eaBofk6YGi+DhiarwPGAHMPhubrgKH5OmBovg4Ymq8DhuZ7D4Z3uHlgaL4OGJqvA4bm64AxwNyDofk6YGi+DhiarwOG5uuAofneg+Edbh4Ymq8DhubrgKH5OmAMMPdgaL4OGJqvA4bm64Ch+TpgaL63YA7e4eaBofk6YGi+DhiarwPGAHMPhubrgKH5OmBovg4Ymq8DhuZ7D4Z3uHlgaL4OGJqvA4bm64AxwNyDofk6YGi+DhiarwOG5uuAofneg+Edbh4Ymq8DhubrgKH5OmAMMPdgaL4OGJqvA4bm64Ch+TpgaL73YHiHmweG5uuAofk6YGi+DhgDzD0Ymq8DhubrgKH5OmBovg4Ymu89GN7h5oGh+TpgaL4OGJqvA8YAcw+G5uuAofk6YGi+DhiarwOG5nsPhne4eWBovg4Ymq8DhubrgDHA3IOh+TpgaL4OGJqvA4bm64Ch+d6D4R1uHhiarwOG5uuAofk6YAww92Bovg4Ymq8DhubrgKH5OmBovvdgeIebB4bm64Ch+TpgaL4OGAPMPRiarwOG5uuAofk6YGi+Dhia7z0Y3uHmgaH5OmBovg4Ymq8DxgBzD4bm64Ch+TpgaL4OGJqvA4bmew+Gd7h5YGi+DhiarwOG5uuAMcDcg6H5OmBovg4Ymq8DhubrgKH53oI5eYebB4bm64Ch+TpgaL4OGAPMPRiarwOG5uuAofk6YGi+Dhia7z0Y3uHmgaH5OmBovg4Ymq8DxgBzD4bm64Ch+TpgaL4OGJqvA4bmew+Gd7h5YGi+DhiarwOG5uuAMcDcg6H5OmBovg4Ymq8DhubrgKH53oPhHW4eGJqvA4bm64Ch+TpgDDD3YGi+DhiarwOG5uuAofk6YGi+92B4h5sHhubrgKH5OmBovg4YA8w9GJqvA4bm64Ch+TpgaL4OGJrvPRje4eaBofk6YGi+DhiarwPGAHMPhubrgKH5OmBovg4Ymq8DhuZ7D4Z3uHlgaL4OGJqvA4bm64AxwNyDofk6YGi+DhiarwOG5uuAofneg+Edbh4Ymq8DhubrgKH5OmAMMPdgaL4OGJqvA4bm64Ch+TpgaL73YHiHmweG5uuAofk6YGi+DhgDzD0Ymq8DhubrgKH5OmBovg4Ymu89GN7h5oGh+TpgaL4OGJqvA8YAcw+G5uuAofk6YGi+DhiarwOG5nsL5uIdbh4Ymq8DhubrgKH5OmAMMPdgaL4OGJqvA4bm64Ch+TpgaL73YHiHmweG5uuAofk6YGi+DhgDzD0Ymq8DhubrgKH5OmBovg4Ymu89GN7h5oGh+TpgaL4OGJqvA8YAcw+G5uuAofk6YGi+DhiarwOG5nsPhne4eWBovg4Ymq8DhubrgDHA3IOh+TpgaL4OGJqvA4bm64Ch+d6D4R1uHhiarwOG5uuAofk6YAww92Bovg4Ymq8DhubrgKH5OmBovvdgeIebB4bm64Ch+TpgaL4OGAPMPRiarwOG5uuAofk6YGi+Dhia7z0Y3uHmgaH5OmBovg4Ymq8DxgBzD4bm64Ch+TpgaL4OGJqvA4bmew+Gd7h5YGi+DhiarwOG5uuAMcDcg6H5OmBovg4Ymq8DhubrgKH53oPhHW4eGJqvA4bm64Ch+TpgDDD3YGi+DhiarwOG5uuAofk6YGi+92B4h5sHhubrgKH5OmBovg4YA8w9GJqvA4bm64Ch+TpgaL4OGJrvLRjjHW4eGJqvA4bm64Ch+TpgDDD3YGi+DhiarwOG5uuAofk6YGi+92B4h5sHhubrgKH5OmBovg4YA8w9GJqvA4bm64Ch+TpgaL4OGJrvPRje4eaBofk6YGi+DhiarwPGAHMPhubrgKH5OmBovg4Ymq8DhuZ7D4Z3uHlgaL4OGJqvA4bm64AxwNyDofk6YGi+DhiarwOG5uuAofneg+Edbh4Ymq8DhubrgKH5OmAMMPdgaL4OGJqvA4bm64Ch+TpgaL73YHiHmweG5uuAofk6YGi+DhgDzD0Ymq8DhubrgKH5OmBovg4Ymu89GN7h5oGh+TpgaL4OGJqvA8YAcw+G5uuAofk6YGi+DhiarwOG5nsPhne4eWBovg4Ymq8DhubrgDHA3IOh+TpgaL4OGJqvA4bm64Ch+d6D4R1uHhiarwOG5uuAofk6YAww92Bovg4Ymq8DhubrgKH5OmBovvdgeIebB4bm64Ch+TpgaL4OGAPMPRiarwOG5uuAofk6YGi+Dhia7y2YxjvcPDA0XwcMzdcBQ/N1wBhg7sHQfB0wNF8HDM3XAUPzdcDQfO/B8A43DwzN1wFD83XA0HwdMAaYezA0XwcMzdcBQ/N1wNB8HTA033swvMPNA0PzdcDQfB0wNF8HjAHmHgzN1wFD83XA0HwdMDRfBwzN9x4M73DzwNB8HTA0XwcMzdcBY4C5B0PzdcDQfB0wNF8HDM3XAUPzvQfDO9w8MDRfBwzN1wFD83XAGGDuwdB8HTA0XwcMzdcBQ/N1wNB878HwDjcPDM3XAUPzdcDQfB0wBph7MDRfBwzN1wFD83XA0HwdMDTfezC8w80DQ/N1wNB8HTA0XweMAeYeDM3XAUPzdcDQfB0wNF8HDM33HgzvcPPA0HwdMDRfBwzN1wFjgLkHQ/N1wNB8HTA0XwcMzdcBQ/O9B8M73DwwNF8HDM3XAUPzdcAYYO7B0HwdMDRfBwzN1wFD83XA0HzvwfAONw8MzdcBQ/N1wNB8HTAGmHswNF8HDM3XAUPzdcDQfB0wNN9bMJ13uHlgaL4OGJqvA4bm64AxwNyDofk6YGi+DhiarwOG5uuAofneg+Edbh4Ymq8DhubrgKH5OmAMMPdgaL4OGJqvA4bm64Ch+TpgaL73YHiHmweG5uuAofk6YGi+DhgDzD0Ymq8DhubrgKH5OmBovg4Ymu89GN7h5oGh+TpgaL4OGJqvA8YAcw+G5uuAofk6YGi+DhiarwOG5nsPhne4eWBovg4Ymq8DhubrgDHA3IOh+TpgaL4OGJqvA4bm64Ch+d6D4R1uHhiarwOG5uuAofk6YAww92Bovg4Ymq8DhubrgKH5OmBovvdgeIebB4bm64Ch+TpgaL4OGAPMPRiarwOG5uuAofk6YGi+Dhia7z0Y3uHmgaH5OmBovg4Ymq8DxgBzD4bm64Ch+TpgaL4OGJqvA4bmew+Gd7h5YGi+DhiarwOG5uuAMcDcg6H5OmBovg4Ymq8DhubrgKH53oPhHW4eGJqvA4bm64Ch+TpgDDD3YGi+DhiarwOG5uuAofk6YGi+t2AG73DzwNB8HTA0XwcMzdcBY4C5B0PzdcDQfB0wNF8HDM3XAUPzvQfDO9w8MDRfBwzN1wFD83XAGGDuwdB8HTA0XwcMzdcBQ/N1wNB878HwDjcPDM3XAUPzdcDQfB0wBph7MDRfBwzN1wFD83XA0HwdMDTfezC8w80DQ/N1wNB8HTA0XweMAeYeDM3XAUPzdcDQfB0wNF8HDM33HgzvcPPA0HwdMDRfBwzN1wFjgLkHQ/N1wNB8HTA0XwcMzdcBQ/O9B8M73DwwNF8HDM3XAUPzdcAYYO7B0HwdMDRfBwzN1wFD83XA0HzvwfAONw8MzdcBQ/N1wNB8HTAGmHswNF8HDM3XAUPzdcDQfB0wNN97MLzDzQND83XA0HwdMDRfB4wB5h4MzdcBQ/N1wNB8HTA0XwcMzfceDO9w88DQfB0wNF8HDM3XAWOAuQdD83XA0HwdMDRfBwzN1wFD870HwzvcPDA0XwcMzdcBQ/N1wBhg7sHQfB0wNF8HDM3XAUPzdcDQfG/BTN7h5oGh+TpgaL4OGJqvA8YAcw+G5uuAofk6YGi+DhiarwOG5nsPhne4eWBovg4Ymq8DhubrgDHA3IOh+TpgaL4OGJqvA4bm64Ch+d6D4R1uHhiarwOG5uuAofk6YAww92Bovg4Ymq8DhubrgKH5OmBovvdgeIebB4bm64Ch+TpgaL4OGAPMPRiarwOG5uuAofk6YGi+Dhia7z0Y3uHmgaH5OmBovg4Ymq8DxgBzD4bm64Ch+TpgaL4OGJqvA4bmew+Gd7h5YGi+DhiarwOG5uuAMcDcg6H5OmBovg4Ymq8DhubrgKH53oPhHW4eGJqvA4bm64Ch+TpgDDD3YGi+DhiarwOG5uuAofk6YGi+92B4h5sHhubrgKH5OmBovg4YA8w9GJqvA4bm64Ch+TpgaL4OGJrvPRje4eaBofk6YGi+DhiarwPGAHMPhubrgKH5OmBovg4Ymq8DhuZ7D4Z3uHlgaL4OGJqvA4bm64AxwNyDofk6YGi+DhiarwOG5uuAofneglm8w80DQ/N1wNB8HTA0XweMAeYeDM3XAUPzdcDQfB0wNF8HDM33HgzvcPPA0HwdMDRfBwzN1wFjgLkHQ/N1wNB8HTA0XwcMzdcBQ/O9B8M73DwwNF8HDM3XAUPzdcAYYO7B0HwdMDRfBwzN1wFD83XA0HzvwfAONw8MzdcBQ/N1wNB8HTAGmHswNF8HDM3XAUPzdcDQfB0wNN97MLzDzQND83XA0HwdMDRfB4wB5h4MzdcBQ/N1wNB8HTA0XwcMzfceDO9w88DQfB0wNF8HDM3XAWOAuQdD83XA0HwdMDRfBwzN1wFD870HwzvcPDA0XwcMzdcBQ/N1wBhg7sHQfB0wNF8HDM3XAUPzdcDQfO/B8A43DwzN1wFD83XA0HwdMAaYezA0XwcMzdcBQ/N1wNB8HTA033swvMPNA0PzdcDQfB0wNF8HjAHmHgzN1wFD83XA0HwdMDRfBwzN9x4M73DzwNB8HTA0XwcMzdcBY4C5B0PzdcDQfB0wNF8HDM3XAUPzvQNzvHiHmweG5uuAofk6YGi+DhgDzD0Ymq8DhubrgKH5OmBovg4Ymu89GN7h5oGh+TpgaL4OGJqvA8YAcw+G5uuAofk6YGi+DhiarwOG5nsPhne4eWBovg4Ymq8DhubrgDHA3IOh+TpgaL4OGJqvA4bm64Ch+d6D4R1uHhiarwOG5uuAofk6YAww92Bovg4Ymq8DhubrgKH5OmBovvdgeIebB4bm64Ch+TpgaL4OGAPMPRiarwOG5uuAofk6YGi+Dhia7z0Y3uHmgaH5OmBovg4Ymq8DxgBzD4bm64Ch+TpgaL4OGJqvA4bmew+Gd7h5YGi+DhiarwOG5uuAMcDcg6H5OmBovg4Ymq8DhubrgKH53oPhHW4eGJqvA4bm64Ch+TpgDDD3YGi+DhiarwOG5uuAofk6YGi+92B4h5sHhubrgKH5OmBovg4YA8w9GJqvA6ZM823z9QOmn+vzn5+H/fnr8zz+9UH6PfTX+vnfvq4R/Plrjj9/fRyv//3j9od5mVL9HObz53Mfc5w3zMv09QcxXz85X8e8YV5mCnxPzuu8L+97cl7nVXxflPMy2+iLcl5mdn1Rzg3m23NeZix+Uc7Zoftzzg7dn3N26P6cs0N35/yo8/bKr8n5UefFmF+Uc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zOu+S/Z6c13lN7RflnB26P+fs0P05N5hvzzk7dH/O2aH7c84O3Z9zduj+nLNDt+e8zpudvyfndV4a/UU5Z4fuzzk7dH/ODebbc84O3Z9zduj+nLND9+ecHbo/5+zQ7Tmv857178l5nVe4f1HO2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0e86NHbo958YO3Z9zduj+nLND9+fcYL495+zQ/Tlnh+7POTt0f87Zoftzzg7dnvPGDt2e88YO3Z9zduj+nLND9+fcYL495+zQ/Tlnh+7POTt0f87Zoftzzg7dnvPODt2e884O3Z9zduj+nLND9+fcYL495+zQ/Tlnh+7POTt0f87Zoftzzg7dnvPBDt2e88EO3Z9zduj+nLND9+fcYL495+zQ/Tlnh+7POTt0f87Zoftzzg7dnvPJDt2e88kO3Z9zduj+nLND9+fcYL495+zQ/Tlnh+7POTt0f87Zoftzzg7dnvPFDt2e88UO3Z9zduj+nLND9+fcYL495+zQ/Tlnh+7POTt0f87Zoftzzg7dnfPzxQ7dnfPzxQ7dn3N26P6cs0P359xgvj3n7ND9OWeH7s85O3R/ztmh+3PODt2e84Mduj3nBzt0f87Zoftzzg7dn3OD+facs0P355wduj/n7ND9OWeH7s85O3R7zk926Pacn+zQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDtOb/YodtzfrFD9+ecHbo/5+zQ/Tk3mG/POTt0f87Zoftzzg7dn3N26P6cs0O359zYodtzbuzQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDtOW/s0O05b+zQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDtOe/s0O057+zQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDtOR/s0O05H+zQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDtOZ/s0O05n+zQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDtOV/s0O05X+zQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDdOb9e7NDdOb9e7ND9OWeH7s85O3R/zg3m23PODt2fc3bo/pyzQ/fnnB26P+fs0O05P9ih23N+sEP355wduj/n7ND9OTeYb885O3R/ztmh+3PODt2fc3bo/pyzQ7fn/GSHbs/5yQ7dn3N26P6cs0P359xgvj3n7ND9OWeH7s85O3R/ztmh+3PODt2e84sduj3nFzt0f87Zoftzzg7dn3OD+facs0P355wduj/n7ND9OWeH7s85O3R7zo0duj3nxg7dn3N26P6cs0P359xgvj3n7ND9OWeH7s85O3R/ztmh+3PODt2e88YO3Z7zxg7dn3N26P6cs0P359xgvj3n7ND9OWeH7s85O3R/ztmh+3PODt2e884O3Z7zzg7dn3N26P6cs0P359xgvj3n7ND9OWeH7s85O3R/ztmh+3PODt2e88EO3Z7zwQ7dn3N26P6cs0P359xgvj3n7ND9OWeH7s85O3R/ztmh+3PODt2e88kO3Z7zyQ7dn3N26P6cs0P359xgvj3n7ND9OWeH7s85O3R/ztmh+3PODt2e88UO3Z7zxQ7dn3N26P6cs0P359xgvj3n7ND9OWeH7s85O3R/ztmh+3PODt2dc3uxQ3fn3F7s0P05Z4fuzzk7dH/ODebbc84O3Z9zduj+nLND9+ecHbo/5+zQ7Tk/2KHbc36wQ/fnnB26P+fs0P05N5hvzzk7dH/O2aH7c84O3Z9zduj+nLNDt+f8ZIduz/nJDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zix26PecXO3R/ztmh+3PODt2fc4P59pyzQ/fnnB26P+fs0P05Z4fuzzk7dHvOjR26PefGDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zxg7dnvPGDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zzg7dnvPODt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zwQ7dnvPBDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zyQ7dnvPJDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zxQ7dnvPFDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z3z9mKH7s55e7FD9+ecHbo/5+zQ/Tk3mG/POTt0f87Zoftzzg7dn3N26P6cs0O35/xgh27P+cEO3Z9zduj+nLND9+fcYL495+zQ/Tlnh+7POTt0f87Zoftzzg7dnvOTHbo95yc7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0e84vduj2nF/s0P05Z4fuzzk7dH/ODebbc84O3Z9zduj+nLND9+ecHbo/5+zQ7Tk3duj2nBs7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0e84bO3R7zhs7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0e847O3R7zjs7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0e84HO3R7zgc7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0e84nO3R7zic7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0e84XO3R7zhc7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0d877ix26O+f9xQ7dn3N26P6cs0P359xgvj3n7ND9OWeH7s85O3R/ztmh+3PODt2e84Mduj3nBzt0f87Zoftzzg7dn3OD+facs0P355wduj/n7ND9OWeH7s85O3R7zk926Pacn+zQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDtOb/YodtzfrFD9+ecHbo/5+zQ/Tk3mG/POTt0f87Zoftzzg7dn3N26P6cs0O359zYodtzbuzQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDtOW/s0O05b+zQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDtOe/s0O057+zQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDtOR/s0O05H+zQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDtOZ/s0O05n+zQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDtOV/s0O05X+zQ/Tlnh+7POTt0f84N5ttzzg7dn3N26P6cs0P355wduj/n7NDdOR8vdujunI8XO3R/ztmh+3PODt2fc4P59pyzQ/fnnB26P+fs0P05Z4fuzzk7dHvOD3bo9pwf7ND9OWeH7s85O3R/zg3m23PODt2fc3bo/pyzQ/fnnB26P+fs0O05P9mh23N+skP355wduj/n7ND9OTeYb885O3R/ztmh+3PODt2fc3bo/pyzQ7fn/GKHbs/5xQ7dn3N26P6cs0P359xgvj3n7ND9OWeH7s85O3R/ztmh+3PODt2ec2OHbs+5sUP355wduj/n7ND9OTeYb885O3R/ztmh+3PODt2fc3bo/pyzQ7fnvLFDt+e8sUP355wduj/n7ND9OTeYb885O3R/ztmh+3PODt2fc3bo/pyzQ7fnvLNDt+e8s0P355wduj/n7ND9OTeYb885O3R/ztmh+3PODt2fc3bo/pyzQ7fnfLBDt+d8sEP355wduj/n7ND9OTeYb885O3R/ztmh+3PODt2fc3bo/pyzQ7fnfLJDt+d8skP355wduj/n7ND9OTeYb885O3R/ztmh+3PODt2fc3bo/pyzQ7fnfLFDt+d8sUP355wduj/n7ND9OTeYb885O3R/ztmh+3PODt2fc3bo/pyzQ3fnfL7YobtzPl/s0P05Z4fuzzk7dH/ODebbc84O3Z9zduj+nLND9+ecHbo/5+zQ7Tk/2KHbc36wQ/fnnB26P+fs0P05N5hvzzk7dH/O2aH7c84O3Z9zduj+nLNDt+f8ZIduz/nJDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zix26PecXO3R/ztmh+3PODt2fc4P59pyzQ/fnnB26P+fs0P05Z4fuzzk7dHvOjR26PefGDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zxg7dnvPGDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zzg7dnvPODt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zwQ7dnvPBDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zyQ7dnvPJDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zxQ7dnvPFDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z3z9WKH7s75erFD9+ecHbo/5+zQ/Tk3mG/POTt0f87Zoftzzg7dn3N26P6cs0O35/xgh27P+cEO3Z9zduj+nLND9+fcYL495+zQ/Tlnh+7POTt0f87Zoftzzg7dnvOTHbo95yc7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0e84vduj2nF/s0P05Z4fuzzk7dH/ODebbc84O3Z9zduj+nLND9+ecHbo/5+zQ7Tk3duj2nBs7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0e84bO3R7zhs7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0e847O3R7zjs7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0e84HO3R7zgc7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0e84nO3R7zic7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0e84XO3R7zhc7dH/O2aH7c84O3Z9zg/n2nLND9+ecHbo/5+zQ/Tlnh+7POTt0c87P14sdujnnb+bs0P05Z4fuzzk7dH/ODebbc84O3Z9zduj+nLND9+ecHbo/5+zQ7Tk/2KHbc36wQ/fnnB26P+fs0P05N5hvzzk7dH/O2aH7c84O3Z9zduj+nLNDt+f8ZIduz/nJDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zix26PecXO3R/ztmh+3PODt2fc4P59pyzQ/fnnB26P+fs0P05Z4fuzzk7dHvOjR26PefGDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zxg7dnvPGDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zzg7dnvPODt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zwQ7dnvPBDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zyQ7dnvPJDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z7zxQ7dnvPFDt2fc3bo/pyzQ/fn3GC+Pefs0P05Z4fuzzk7dH/O2aH7c84O3Z3z48UO3Z3z48UO3Z9zduj+nLND9+fcYL495+zQ/Tlnh+7POTt0f87Zoftzzg7NZn4exx/m59FumB/s0HTmZ1s//9vrumHODo2Z96P9/F+Lfr6Of//5PxiZlikYWYspGA2MGRjZdCkYmWkpGFleKRgZUykY2UcZGE8mTwpGVkwKRlZMCkZWTApGA2MGRlZMCkZWTApGVkwKRlZMCkZWTAbGixWTgpEVk4KRFZOCkRWTgtHAmIGRFZOCkRWTgpEVk4KRFZOCkRWTgdFYMSkYWTEpGFkxKRhZMSkYDYwZGFkxKRhZMSkYWTEpGFkxKRhZMRkYGysmBSMrJgUjKyYFIysmBaOBMQMjKyYFIysmBSMrJgUjKyYFIysmA2NnxaRgZMWkYGTFpGBkxcQYx+vnY7//37PdYDQwZqSRFZOCkRWTcqlZMSlpZMWkYGTFZFzqwYrJSONgxaRgZMWkXGpWTEoaDYwZGFkxKZeaFZOSRlZMCkZWTMqlZsVkpHGyYlIwsmIyLvVkxaSkkRWTgtHAmHGpWTEpaWTFpGBkxaRcalZMShpZMRkYFysm41IvVkxKGlkxKRhZMSmX2sCYkUZWTApGVkzKpWbFpKSRFZOCkRWTcKnPFysmIY3v/29gzMDIikm51KyYlDQaGDMwsmJSLjUrJiWNrJgUjKyYlEvNislI48GKScHIism41AcrJiWNrJgUjAbGjEvNiklJIysmBSMrJuVSs2JS0siKycB4smIyLvXJiklJIysmBSMrJuVSGxgz0siKScHIikm51KyYlDSyYlIwsmIyLvXFislI48WKScHIikm51KyYlDQaGDMwsmJSLjUrJiWNrJgUjKyYlEvNislIo7FiUjCyYjIutbFiUtLIiknBaGDMuNSsmJQ0smJSMLJiUi41KyYljayYDIyNFZNxqRsrJiWNrJgUjKyYlEttYMxIIysmBSMrJuVSs2JS0siKScHIism41J0Vk5HGzopJwciKSbnUrJiUNBoYMzCyYlIuNSsmJY2smBSMrJiUS82KyUjjYMWkYGTFZFzqwYpJSSMrJgWjgTHjUrNiUtLIiknByIpJudSsmJQ0smIyME5WTMalnqyYv8B4Xj9pHGezz3/e1+v4c8h1jJ8/PtbNH8/T7J8/nmc///3H/zwg9tHDHxDL6+EPyHhAz35ArMWHPyB26MMfEAv34Q+I7fzwB8Qqf/YDWuz9hz8gfkl4+APil4SHPyB+SXj4AzIe0LMfEL8kPPwB8UvCwx8QvyQ8/AHxS8LDHxC/JDz6AV0vfkl4+APil4SHPyB+SXj4A+KXhIc/IOMBPfsB8UvCwx8QvyQ8/AHxS8LDHxC/JDz8AfFLwrMf0MEvCQ9/QPyS8PAHxC8JD39A/JKQ8F+rXYeBMQMjqzzhP/q7DrZzShpZuCkY2aEpl5q1mJHGk02XgpHllXGpT/ZRShpZMSkYDYwZl5oVk5JGVkwKRlZMyqVmxaSkkRWTgfFixWRc6osVk5JGVkwKRlZMyqU2MGakkRWTgpEVk3KpWTEpaWTFpGBkxWRcamPFZKTRWDEpGFkxKZeaFZOSRgNjBkZWTMqlZsWkpJEVk4KRFZNyqVkxGWlsrJgUjKyYjEvdWDEpaWTFpGA0MGZcalZMShpZMSkYWTEpl5oVk5JGVkwGxs6KybjUnRWTkkZWTApGVkzKpTYwZqSRFZOCkRWTcqlZMSlpZMWkYGTFZFzqwYrJSONgxaRgZMWkXGpWTEoaDYwZGFkxKZeaFZOSRlZMCkZWTMqlZsVkpHGyYlIwsmIyLvVkxaSkkRWTgtHAmHGpWTEpaWTFpGBkxaRcalZMShpZMRkYFysm41IvVkxKGlkxKRhZMSmX2sCYkUZWTApGVkzKpWbFpKSRFZOCkRWTcKntxYpJSKO9WDEpGFkxKZeaFZOSRgNjBkZWTMqlZsWkpJEVk4KRFZNyqVkxGWk8WDEpGFkxGZf6YMWkpJEVk4LRwJhxqVkxKWlkxaRgZMWkXGpWTEoaWTEZGE9WTMalPlkxKWlkxaRgZMWkXGoDY0YaWTEpGFkxKZeaFZOSRlZMCkZWTMalvlgxGWm8WDEpGFkxKZeaFfMXGM/rJ43jbPb5z/t6HX8OuY7x88fHuvnjeZr988fz7Oe///ifB2Q8oGc/IJbXwx8Qm+7hD4i1+PAHxA59+ANi4T77ARnb+eEPiFX+8AfE3n/4A+KXhIc/IOMBPfsB8UvCwx8QvyQ8/AHxS8LDHxC/JDz8AfFLwrMfUOOXhIc/IH5JePgD4peEhz8gfkl4+AMyHtCzHxC/JDz8AfFLwsMfEL8kPPwB8UvCwx8QvyQ8+wF1fkl4+APil4SHPyB+SXj4A+KXhIc/IOMBPfsB8UtCxn+t1tn7KRhZ5Rn/0V9nO6ekkYWbgXGwQzMu9WAtpqSRTZeCkeWVcqkNjBlpZMWkYGTFpFxqVkxKGlkxKRhZMRmXerJiMtI4WTEpGFkxKZeaFZOSRgNjBkZWTMqlZsWkpJEVk4KRFZNyqVkxGWlcrJgUjKyYjEu9WDEpaWTFpGA0MGZcalZMShpZMSkYWTEpl5oVk5JGVkwCxvZixSRc6vZixaSkkRWTgpEVk3KpDYwZaWTFpGBkxaRcalZMShpZMSkYWTEZl/pgxWSk8WDFpGBkxaRcalZMShoNjBkYWTEpl5oVk5JGVkwKRlZMyqVmxWSk8WTFpGBkxWRc6pMVk5JGVkwKRgNjxqVmxaSkkRWTgpEVk3KpWTEpaWTFZGC8WDEZl/pixaSkkRWTgpEVk3KpDYwZaWTFpGBkxaRcalZMShpZMSkYWTEZl9pYMRlpNFZMCkZWTMqlZsWkpNHAmIGRFZNyqVkxKWlkxaRgZMWkXGpWTEYaGysmBSMrJuNSN1ZMShpZMSkYDYwZl5oVk5JGVkwKRlZMyqVmxaSkkRWTgbGzYjIudWfFpKSRFZOCkRWTcqkNjBlpZMWkYGTFpFxqVkxKGlkxKRhZMRmXerBiMtI4WDEpGFkxKZeaFZOSRgNjBkZWTMqlZsWkpJEVk4KRFZNyqVkxGWmcrJgUjKyYjEs9WTEpaWTFpGA0MGZcalbMX2A8r580jrPZ5z/v63X8OeQ6xs8fH+vmj+dp9s8fz7Of//7jfx4Q++jhD4jl9fAHxKZ7+ANiLT77AS126MMfEAv34Q+I7fzwB8Qqf/gDMh7Qsx8QvyQ8/AHxS8LDHxC/JDz8AfFLwsMfEL8kPPoB9Re/JDz8AfFLwsMfEL8kPPwB8UvCwx+Q8YCe/YD4JeHhD4hfEh7+gPgl4eEPiF8SHv6A+CXh2Q/o4JeEhz8gfkl4+APil4SHPyB+SXj4AzIe0LMfEL8kPPwB8UvCwx8QvyQk/Ndq/WDvp2BklSf8R39vtmBMSOPJwk3ByA5NudSsxZQ0GhgzMLK8Ui41+ygljayYFIysmJRLzYrJSOPFiknByIrJuNQXKyYljayYFIwGxoxLzYpJSSMrJgUjKyblUrNiUtLIisnAaKyYjEttrJiUNLJiUjCyYlIutYExI42smBSMrJiUS82KSUkjKyYFIysm41I3VkxGGhsrJgUjKyblUrNiUtJoYMzAyIpJudSsmJQ0smJSMLJiUi41KyYjjZ0Vk4KRFZNxqTsrJiWNrJgUjAbGjEvNiklJIysmBSMrJuVSs2JS0siKycA4WDEZl3qwYlLSyIpJwciKSbnUBsaMNLJiUjCyYlIuNSsmJY2smBSMrJiMSz1ZMRlpnKyYFIysmJRLzYpJSaOBMQMjKyblUrNiUtLIiknByIpJudSsmIw0LlZMCkZWTMalXqyYlDSyYlIwGhgzLjUrJiWNrJgUjKyYlEvNiklJIysmAeN4sWISLvV4sWJS0siKScHIikm51AbGjDSyYlIwsmJSLjUrJiWNrJgUjKyYjEt9sGIy0niwYlIwsmJSLjUrJiWNBsYMjKyYlEvNiklJIysmBSMrJuVSs2Iy0niyYlIwsmIyLvXJiklJIysmBaOBMeNSs2JS0siKScHIikm51KyYlDSyYjIwXqyYjEt9sWJS0siKScHIikm51AbGjDSyYlIwsmJSLjUr5i8wntdPGt+/QtjnP+/rdfw55DrGzx8f6+aP52n2zx/Ps5///uN/HhD76OEPiOX17AdkbLqHPyDW4sMfEDv04Q+IhfvwB2Q8oGc/IFb5wx8Qe//hD4hfEh7+gPgl4eEPiF8Snv2AGr8kPPwB8UvCwx8QvyQ8/AHxS8LDH5DxgJ79gPgl4eEPiF8SHv6A+CXh4Q+IXxIe/oD4JeHZD6jzS8LDHxC/JDz8AfFLwsMfEL8kPPwBGQ/o2Q+IXxIe/oD4JeHhD4hfEh7+gPgl4eEPiF8SMv5rtcHeT8HIKs/4j/4G2zkljSzcFIwGxoxLzVpMSSObLgUjyyvlUrOPUtLIisnAOFkxGZd6smJS0siKScHIikm51AbGjDSyYlIwsmJSLjUrJiWNrJgUjKyYjEu9WDEZaVysmBSMrJiUS82KSUmjgTEDIysm5VKzYlLSyIpJwciKSbnUrJiENM4XKyYFIysm4VLPFysmJY2smBSMBsaMS82KSUkjKyYFIysm5VKzYlLSyIrJwHiwYjIu9cGKSUkjKyYFIysm5VIbGDPSyIpJwciKSbnUrJiUNLJiUjCyYjIu9cmKyUjjyYpJwciKSbnUrJiUNBoYMzCyYlIuNSsmJY2smBSMrJiUS82KyUjjxYpJwciKybjUFysmJY2smBSMBsaMS82KSUkjKyYFIysm5VKzYlLSyIrJwGismIxLbayYlDSyYlIwsmJSLrWBMSONrJgUjKyYlEvNiklJIysmBSMrJuNSN1ZMRhobKyYFIysm5VKzYlLSaGDMwMiKSbnUrJiUNLJiUjCyYlIuNSsmI42dFZOCkRWTcak7KyYljayYFIwGxoxLzYpJSSMrJgUjKyblUrNiUtLIisnAOFgxGZd6sGJS0siKScHIikm51AbGjDSyYlIwsmJSLjUrJiWNrJgUjKyYjEs9WTEZaZysmBSMrJiUS82KSUmjgTEDIysm5VKzYlLSyIpJwciKSbnUrJi/wHheP2kcZ7PPf97X6/hzyHWMnz8+1s0fz9Psnz+eZz///cf/7wNa7KOHPyCW18MfEJvu4Q+ItfjwB2Q8oGc/IBbuwx8Q2/nhD4hV/vAHxN5/+APil4RHP6D14peEhz8gfkl4+APil4SHPyB+SXj4AzIe0LMfEL8kPPwB8UvCwx8QvyQ8/AHxS8LDHxC/JDz7AR38kvDwB8QvCQ9/QPyS8PAHxC8JD39AxgN69gPil4SHPyB+SXj4A+KXhIc/IH5JePgD4peEZz+gk18SHv6A+CXh4Q+IXxIS/nPCdbL3UzAaGP/7/ypznWznlDSycFMwskNTLjVrMSWNbLoMjBfLK+NSX+yjlDSyYlIwsmJSLrWBMSONrJgUjKyYlEvNiklJIysmBSMrJuNSGysmI43GiknByIpJudSsmJQ0GhgzMLJiUi41KyYljayYFIysmJRLzYrJSGNjxaRgZMVkXOrGiklJIysmBaOBMeNSs2JS0siKScHIikm51KyYlDSyYjIwdlZMxqXurJiUNLJiUjCyYlIutYExI42smBSMrJiUS82KSUkjKyYFIysm41IPVkxGGgcrJgUjKyblUrNiUtJoYMzAyIpJudSsmJQ0smJSMLJiUi41KyYjjZMVk4KRFZNxqScrJiWNrJgUjAbGjEvNiklJIysmBSMrJuVSs2JS0siKycC4WDEZl3qxYlLSyIpJwciKSbnUBsaMNLJiUjCyYlIuNSsmJY2smBSMrJj//lJfrxcr5r9P4xsjKyYFIysm5VKzYlLSaGDMwMiKSbnUrJiUNLJiUjCyYlIuNSsmI40HKyYFIysm41IfrJiUNLJiUjAaGDMuNSsmJY2smBSMrJiUS82KSUkjKyYD48mKybjUJysmJY2smBSMrJiUS21gzEgjKyYFIysm5VKzYlLSyIpJwciKybjUFysmI40XKyYFIysm5VKzYlLSaGDMwMiKSbnUrJiUNLJiUjCyYlIuNSsmI43GiknByIrJuNTGivkLjOf1k8ZxNvv85329jj+HXMf4+eNj3fzxPM3++eN59vPff/zPA2IfPfwBGQ/o2Q+ITffwB8RafPgDYoc+/AGxcB/+gNjOz35AjVX+8AfE3n/4A+KXhIc/IH5JePgDMh7Qsx8QvyQ8/AHxS8LDHxC/JDz8AfFLwsMfEL8kPPsBdX5JePgD4peEhz8gfkl4+APil4SHPyDjAT37AfFLwsMfEL8kPPwB8UvCwx8QvyQ8/AHxS8KzH9Dgl4SHPyB+SXj4A+KXhIc/IH5JePgDMh7Qsx8QvyRk/OeEg72fgpFVnvFfZQ62c0oaWbgZGCc7NONST9ZiShrZdCkYWV4pl9rAmJFGVkwKRlZMyqVmxaSkkRWTgpEVk3GpFysmI42LFZOCkRWTcqlZMSlpNDBmYGTFpFxqVkxKGlkxKRhZMSmXmhWTkMbjxYpJwciKSbjUx4sVk5JGVkwKRgNjxqVmxaSkkRWTgpEVk3KpWTEpaWTFZGA8WDEZl/pgxaSkkRWTgpEVk3KpDYwZaWTFpGBkxaRcalZMShpZMSkYWTEZl/pkxWSk8WTFpGBkxaRcalZMShoNjBkYWTEpl5oVk5JGVkwKRlZMyqVmxWSk8WLFpGBkxWRc6osVk5JGVkwKRgNjxqVmxaSkkRWTgpEVk3KpWTEpaWTFZGA0VkzGpTZWTEoaWTEpGFkxKZfawJiRRlZMCkZWTMqlZsWkpJEVk4KRFZNxqRsrJiONjRWTgpEVk3KpWTEpaTQwZmBkxaRcalZMShpZMSkYWTEpl5oVk5HGzopJwciKybjUnRWTkkZWTApGA2PGpWbFpKSRFZOCkRWTcqlZMSlpZMVkYBysmIxLPVgxKWlkxaRgZMWkXGoDY0YaWTEpGFkxKZeaFZOSRlZMCkZWTMalnqyYjDROVkwKRlZMyqVmxaSk0cCYgZEVk3KpWTEpaWTFpGBkxaRcalZMRhoXKyYFIysm41IvVkxKGlkxKRgNjBmXmhXzFxjP6yeN42z2+c/7eh1/DrmO8fPHx7r543ma/fPH8+znv//4nwfEPnr4A2J5PfwBseke/oBYi49+QOeLHfrwB8TCffgDYjs//AGxyh/+gIwH9OwHxC8JD39A/JLw8AfELwkPf0D8kvDwB8QvCc9+QAe/JDz8AfFLwsMfEL8kPPwB8UvCwx+Q8YCe/YD4JeHhD4hfEh7+gPgl4eEPiF8SHv6A+CXh2Q/o5JeEhz8gfkl4+APil4SHPyB+SXj4AzIe0LMfEL8kPPwB8UvCwx8QvyQ8/AHxS0LCf054nuz9DIwXqzzhv8o8L7ZzShpZuCkY2aEpl9rAmJFGNl0KRpZXyqVmH6WkkRWTgpEVk3GpjRWTkUZjxaRgZMWkXGpWTEoaDYwZGFkxKZeaFZOSRlZMCkZWTMqlZsVkpLGxYlIwsmIyLnVjxaSkkRWTgtHAmHGpWTEpaWTFpGBkxaRcalZMShpZMRkYOysm41J3VkxKGlkxKRhZMSmX2sCYkUZWTApGVkzKpWbFpKSRFZOCkRWTcakHKyYjjYMVk4KRFZNyqVkxKWk0MGZgZMWkXGpWTEoaWTEpGFkxKZeaFZORxsmKScHIism41JMVk5JGVkwKRgNjxqVmxaSkkRWTgpEVk3KpWTEpaWTFZGBcrJiMS71YMSlpZMWkYGTFpFxqA2NGGlkxKRhZMSmXmhWTkkZWTApGVkzCpb5erJiENF4vVkwKRlZMyqVmxaSk0cCYgZEVk3KpWTEpaWTFpGBkxaRcalZMRhoPVkwKRlZMxqU+WDEpaWTFpGA0MGZcalZMShpZMSkYWTEpl5oVk5JGVkwGxpMVk3GpT1ZMShpZMSkYWTEpl9rAmJFGVkwKRlZMyqVmxaSkkRWTgpEVk3GpL1ZMRhovVkwKRlZMyqVmxaSk0cCYgZEVk3KpWTEpaWTFpGBkxaRcalZMRhqNFZOCkRWTcamNFZOSRlZMCkYDY8alZsWkpJEVk4KRFZNyqVkxf4HxvH7SOM5mn/+8r9fx55DrGD9/fKybP56n2T9/PM9+/vuP/3lA7KNnP6DG8nr4A2LTPfwBsRYf/oDYoQ9/QMYDevYDYjs//AGxyh/+gNj7D39A/JLw8AfELwnPfkCdXxIe/oD4JeHhD4hfEh7+gPgl4eEPyHhAz35A/JLw8AfELwkPf0D8kvDwB8QvCQ9/QPyS8OwHNPgl4eEPiF8SHv6A+CXh4Q+IXxIe/oCMB/TsB8QvCQ9/QPyS8PAHxC8JD39A/JLw8AfELwnPfkCTXxIe/oD4JSHjPyec7P0UjKzyjP8qcxoYM9LIwk3ByA5NudSsxZQ0sulSMLK8Mi71Yh9lpHGxYlIwsmJSLjUrJiWNBsYMjKyYlEvNiklJIysmBSMrJuVSs2IS0mgvVkwKRlZMwqW2FysmJY2smBSMBsaMS82KSUkjKyYFIysm5VKzYlLSyIrJwHiwYjIu9cGKSUkjKyYFIysm5VIbGDPSyIpJwciKSbnUrJiUNLJiUjCyYjIu9cmKyUjjyYpJwciKSbnUrJiUNBoYMzCyYlIuNSsmJY2smBSMrJiUS82KyUjjxYpJwciKybjUFysmJY2smBSMBsaMS82KSUkjKyYFIysm5VKzYlLSyIrJwGismIxLbayYlDSyYlIwsmJSLrWBMSONrJgUjKyYlEvNiklJIysmBSMrJuNSN1ZMRhobKyYFIysm5VKzYlLSaGDMwMiKSbnUrJiUNLJiUjCyYlIuNSsmI42dFZOCkRWTcak7KyYljayYFIwGxoxLzYpJSSMrJgUjKyblUrNiUtLIisnAOFgxGZd6sGJS0siKScHIikm51AbGjDSyYlIwsmJSLjUrJiWNrJgUjKyYjEs9WTEZaZysmBSMrJiUS82KSUmjgTEDIysm5VKzYlLSyIpJwciKSbnUrJiMNC5WTApGVkzGpV6smJQ0smJSMBoYMy41KyYljayYFIysmJRLzYpJSSMrJgFje7FiEi51e7Fi/gLjef2kcZzNPv95X6/jzyHXMX7++Fg3fzxPs3/+eJ79/Pcf//OA2EcPf0Asr4c/IOMBPfsBsRYf/oDYoQ9/QCzchz8gtvPDHxCr/NkP6GDvP/wB8UvCwx8QvyQ8/AHxS8LDH5DxgJ79gPgl4eEPiF8SHv6A+CXh4Q+IXxIe/oD4JeHZD+jkl4SHPyB+SXj4A+KXhIc/IH5JePgDMh7Qsx8QvyQ8/AHxS8LDHxC/JDz8AfFLwsMfEL8kPPsBXfyS8PAHxC8JD39A/JLw8AfELwkPf0DGA0r4zwkv9n4KRlZ5xn+VebGdU9LIwk3ByA7NuNTGWsxIo7HpUjCyvFIuNfsoJY0GxgyMrJiUS82KSUkjKyYFIysm5VKzYjLS2FgxKRhZMRmXurFiUtLIiknBaGDMuNSsmJQ0smJSMLJiUi41KyYljayYDIydFZNxqTsrJiWNrJgUjKyYlEttYMxIIysmBSMrJuVSs2JS0siKScHIism41IMVk5HGwYpJwciKSbnUrJiUNBoYMzCyYlIuNSsmJY2smBSMrJiUS82KyUjjZMWkYGTFZFzqyYpJSSMrJgWjgTHjUrNiUtLIiknByIpJudSsmJQ0smIyMC5WTMalXqyYlDSyYlIwsmJSLrWBMSONrJgUjKyYlEvNiklJIysmBSMrJuFS9xcrJiGN/cWKScHIikm51KyYlDQaGDMwsmJSLjUrJiWNrJgUjKyYlEvNislI48GKScHIism41AcrJiWNrJgUjAbGjEvNiklJIysmBSMrJuVSs2JS0siKycB4smIyLvXJiklJIysmBSMrJuVSGxgz0siKScHIikm51KyYlDSyYlIwsmIyLvXFislI48WKScHIikm51KyYlDQaGDMwsmJSLjUrJiWNrJgUjKyYlEvNislIo7FiUjCyYjIutbFiUtLIiknBaGDMuNSsmJQ0smJSMLJiUi41KyYljayYDIyNFZNxqRsrJiWNrJgUjKyYlEttYIwxntdPGsfZ7POf9/U6/hxyHePnj49188fzNPvnj+fZz3//8T8PiH308AfE8nr4A2LTPfwBsRYf/oDYoc9+QJ2F+/AHxHZ++ANilT/8AbH3H/6AjAf07AfELwkPf0D8kvDwB8QvCQ9/QPyS8PAHxC8Jz35Ag18SHv6A+CXh4Q+IXxIe/oD4JeHhD8h4QM9+QPyS8PAHxC8JD39A/JLw8AfELwkPf0D8kvDsBzT5JeHhD4hfEh7+gPgl4eEPiF8SHv6AjAf07AfELwkPf0D8kvDwB8QvCRn/OeFk76dgZJVn/FeZi+2ckcbFwk3ByA5NudSsxZQ0GhgzMLK8Ui41+ygljayYFIysmJRLzYpJSON4sWJSMLJiEi71eLFiUtLIiknBaGDMuNSsmJQ0smJSMLJiUi41KyYljayYDIwHKybjUh+smJQ0smJSMLJiUi61gTEjjayYFIysmJRLzYpJSSMrJgUjKybjUp+smIw0nqyYFIysmJRLzYpJSaOBMQMjKyblUrNiUtLIiknByIpJudSsmIw0XqyYFIysmIxLfbFiUtLIiknBaGDMuNSsmJQ0smJSMLJiUi41KyYljayYDIzGism41MaKSUkjKyYFIysm5VIbGDPSyIpJwciKSbnUrJiUNLJiUjCyYjIudWPFZKSxsWJSMLJiUi41KyYljQbGDIysmJRLzYpJSSMrJgUjKyblUrNiMtLYWTEpGFkxGZe6s2JS0siKScFoYMy41KyYlDSyYlIwsmJSLjUrJiWNrJgMjIMVk3GpBysmJY2smBSMrJiUS21gzEgjKyYFIysm5VKzYlLSyIpJwciKybjUkxWTkcbJiknByIpJudSsmJQ0GhgzMLJiUi41KyYljayYFIysmJRLzYrJSONixaRgZMVkXOrFiklJIysmBaOBMeNSs2JS0siKScHIikm51KyYlDSyYhIwzhcrJuFSzxcrJiWNrJgUjKyYlEttYMxIIysmBSMrJuVSs2L+AuO7YP9gPJt9/vO+XsefQ65j/PzxsW7+eJ5m//zxPPv57z/+5wH9P+293a4sPY4d+C5zXRcS9f8sA8OwewyjgYLbaLcHmAu/+8T58mRk7i+lZB5tbsViBPuisKsrdbgWQ8FFMSTK1kfgD8hWXtgPyNuaDvwB2WoR/AHZOhT8AdkKF/wBRXtA2A/IVuXgD8jW++APyCoJ4A/IKgngD8gqCdgPiKySAP6ArJIA/oCskgD+gKySAP6Aoj0g7AdklQTwB2SVBPAHZJUE8AdklQTwB2SVBOwHFKySAP6ArJIA/oCskgD+gKySAP6Aoj0g7AdklQTwB2SVBPAHZJUE8AdklQTwB2SVBOwHFK2SAP6ArJIgcd4z2npfxI22Kpc4NhujuVFiNtoKV8SNtg4VealttSgyG21NJ+JGW3lJvNTJ1kcSszHZKkbEjbaKEXmpbRUjMhujuVHCjbaKEXmpbRUjMhttFSPiRlvFiLzUtoqRmI3ZVjEibrRVjMRLnW0VIzIbbRUj4sZobpR4qW0VIzIbbRUj4kZbxYi81LaKEZmNtoqRcGOxVYzES11sFSMyG20VI+JGW8WIvNTR3CgxG20VI+JGW8WIvNS2ihGZjbaKEXGjrWIkXupqqxiJ2VhtFSPiRlvFiLzUtooRmY3R3CjhRlvFiLzUtooRmY22ihFxo61iRF5qW8VIzMZmqxgRN9oqRuKlbraKEZmNtooRcWM0N0q81LaKEZmNtooRcaOtYkRealvFiMxGW8UIuLE5W8UIvNTN2SpGZDbaKkbEjbaKEXmpo7lRYjbaKkbEjbaKEXmpbRUjMhttFSPiRlvFSLzU3lYxErPR2ypGxI22ihF5qW0VIzIbo7lRwo22ihF5qW0VIzIbbRUj4kZbxYi81LaKkZiNZKsYETfaKkbipSZbxYjMRlvFiLgxmhslXmpbxYjMRlvFiLjRVjEiL7WtYkRmo61iJNwYbBUj8VIHW8WIzEZbxYi40VYxIi91NDdKzEZbxYi40VYxIi+1rWJEZqOtYkTcaKsYiZc62ipGYjZGW8WIuNFWMSIvta1iRGZjNDdKuNFWMSIvta1iRGajrWJE3GirGJGX2lYxErMx2SpGxI22ipF4qZOtYkRmo61iRNwYzY0SL7WtYkRmo61iRNxoqxiRl9pWMSKz0VYxEm7MtoqReKmzrWI+cCOFfTYWSvH9z3Nz/k6y+bL/2LfOjyvF+PvHlTI9//j3A7L1EfgDspUX+AOK9oCwH5CtFsEfkK1DwR+QrXDBH5CtncEfkK3KsR9QsfU++AOySgL4A7JKAvgDskoC+AOK9oCwH5BVEsAfkFUSwB+QVRLAH5BVEsAfkFUSsB9QtUoC+AOySgL4A7JKAvgDskoC+AOK9oCwH5BVEsAfkFUSwB+QVRLAH5BVEsAfkFUSsB9Qs0oC+AOySgL4A7JKAvgDskoC+AOK9oCwH5BVEvgHtH012x/QVhzrnPdstt4XcaOtylk3kkt5/7XLrnTcaGtnkdloK9zvuzE6Z+vQ77/UmxtttSgyG21NJ+JGW3mJvNTR3CgxG20VI+JGW8WIvNS2ihGZjbaKEXGjrWIkXmpvqxiJ2ehtFSPiRlvFiLzUtooRmY3R3CjhRlvFiLzUtooRmY22ihFxo61iRF5qW8VIzEayVYyIG20VI/FSk61iRGajrWJE3BjNjRIvta1iRGajrWJE3GirGJGX2lYxIrPRVjESbgy2ipF4qYOtYkRmo61iRNxoqxiRlzqaGyVmo61iRNxoqxiRl9pWMSKz0VYxIm60VYzESx1tFSMxG6OtYkTcaKsYkZfaVjEiszGaGyXcaKsYkZfaVjEis9FWMSJutFWMyEttqxiJ2ZhsFSPiRlvFSLzUyVYxIrPRVjEibozmRomX2lYxIrPRVjEibrRVjMhLbasYkdloqxgJN2ZbxUi81NlWMSKz0VYxIm60VYzISx3NjRKz0VYxIm60VYzIS22rGJHZaKsYETfaKkbipS62ipGYjcVWMSJutFWMyEttqxiR2RjNjRJutFWMyEttqxiR2WirGBE32ipG5KW2VYzEbKy2ihFxo61iJF7qaqsYkdloqxgRN0Zzo8RLbasYkdloqxgRN9oqRuSltlWMyGy0VYyEG5utYiRe6marmA/cWOjhxsJdIJ7K3XmpPWD8vhF887gteFZ73NZGH3i8+bh7vAX//ue5OX8n2Xx59vnrjyvF+z9dKVPnAUV7QNgPyNZz4A/IVorgD8jWoOAPyFa34A/I1s3QD8g7W5GDPyBb64M/ICsNgD8gqySAP6BoDwj7AVklAfwBWSUB/AFZJQH8AVklAfwBWSUB+wF5qySAPyCrJIA/IKskgD8gqySAP6BoDwj7AVklAfwBWSUB/AFZJQH8AVklAfwBWSUB+wGRVRLAH5BVEsAfkFUSwB+QVRLAH1C0B4T9gKySwD8gH1O+/9rH8uXnv91o630RN9qq/CM3pic3lo4bbe0s4kZb4Uq4Mdg6VMSNtlr8wI3J7amUT6m9/7nPJe+tFnKpbv95uTvdVoAHON1WdQc4PZrT1zv9NKuvWsPu9BaYf9u7sK8Etr+f/nUfun4nF/aVA7nndWzY5fE0K7DjXXmaVdjxrjzNSux4V55mNXa4K+NpVmTHu/I0q7LjXXmatdbxrjzNCup4V0ZzpZQrbbUj5kpb7Yi5Eni1U/39x61Gzjfe7cUJ732OPa7AyxFxrsDrhT/jSi7tXOlpe8CDawJO6MW5Amfc3+CaulyBU2JxrsA5qzjXeCGuwFnfn3FNaf+w4NOv37xyBU7LxLmeJm/6gOtp8qYPuJ4mb+K55tPkTR9wPU3elOu+BvT5uen9g+tp8qYPuJ4mb/qAa7wQ19PkTR9wPU3e9AHX0+RN9Sn3r9SrreXT5E0fcD1L3vRrZ9NekiX6uqbr/L7RXoprsT79+r7LqZwly5L3zFlysj/0zK9jTr9/TlvZ4ItnXn/9/oojX86S7B3qxLNkkRRpV2CKuafAJV6I61myyI3r4+WIJfW4niWL/ITrWbLIT7ieJYv8hOtpskieaz1NXvgB19Nkeh9wPUtClijvXBPVnr7Ws+RNn3CNF+J6lrwphf2f3j47+96XgXqWvOkTrmfJm1JM7cG1BWaxKNs1pJ4lIzvWi2fJ9Q71YjtLFnmsF8+Snx7rxdNkvod68TQ59aFejOZFAS+eZh1wqBdPs8I41Iu2dpHwoq1dJLxoa5fve5GQrw1X5EVbu0h40dYuEl60tYuEF6N5UcCLtnaR8KKtXSS8aGsXCS/a2kXCi7Z2EfAi8kXFirxoaxcJL9raRcKLtnaR8GI0Lwp40dYuEl60tYuEF23tIuFFW7tIeNHWLgJeRL4a9c+8mJ52vKbi1nrxNGuXQ714mrXLoV48zdrlUC9G86KAF0+zdjnUi6dZuxzqxdOsXQ714mnWLod68TRrlyO9iHydpiIv2tpFwou2dpHwoq1dJLwYzYsCXrS1i4QXbe0i4UVbu0h40dYuEl60tYuAF5EvnlTkRVu7SHjR1i4SXrS1i4QXo3lRwIu2dpHwoq1dJLxoaxcJL9raRcKLtnYR8OJp7tg81ou2dpHwoq1dJLx4lrVL9o3uXsxbAsd4kb2XhE5zP6m8Z86yxvhDz0heNkKnuSb1UCeeZYWRc95PAuRciXFiSeHu85Li11//9sxZVg3ynjnLSkDcM6e5CVbeM2fJ2OU9c5YsXN4zp8msxT0TzTMDz5wmsxb3zGnS5T/1DD15JvQ8c9kcmPXMZXNg1jOXzYE5z5zmnl55z1w2B2Y9c9kcmPXMZXNg1jPRPDPwzGVzYNYzlgOPPGM58MgzlgOPPGM58MAzp7mTWPzL52luMJb3zGly4AM/Z57mIuVDnRithtqvoZ7mPmd5z1w2s2Y9YzssRp6xHRYjz9gOi4FnTnNPs7xnbIfFyDO2w2LkGasuD1bwp7n3WHydepq7jOU9YxuSv7/4PM31xIc60TLrkeJZZt33TDjNLcLynrHMeuQZy6xHnrG9yyPPRPPMwDNWXR55xqrLI8/Yvo3+Cj6c5pZb6XVqOM3NteKeOc1ttAcuPsNpLqM91ImWWQ8U7zT3y8p7JppnBp6xzHrkGcusR56xfRsjz1h1eeQZqy4PPHOau1LlPWOnAgcr+NPcaSq+Tj3NPaXynom2+Pz24vM0V48e6kTLrEeKZ5n1yDOWWY88Y5n1wDOnuclT3jO2b2PkGasujzxj1eWRZ6J5ZuAZ67cxWMGf5gZL8XXqaW6llPfMRfdtiC4+T3PR5JFOPM09k+KKd5q7I+U9Y5n1yDOWWY88E80zA8/Yvo2RZ6y6PPKMVZdHnrHq8sgz1slusII/zX2F4uvU09xBKO8Z62T3/cXnVa8VlHViNMXrK955biAU94xl1iPPWGY98oxl1iPP2L6NgWfsrsChZ6y6PPKMVZdHnrFOdoMV/HnuCpRep57nrkBxz1gnu+8vPs9zreCRTrTMeqR4llkPPHPdGwhZz1hmPfKMZdYjz9i+jZFnonlm4BmrLo88Y9XlkWesk91gBX+eGwil16nnuYFQ2jNXvYFQdPF51csKZZ1omfVA8c5zWaG4Z6J5ZuAZy6xHnrHMeuQZ27cx8oxVl0eeserywDN2A+HQM9bJbrCCP88NhNLr1PPcQCjumWiLz28vPq96WaGsEy2zHimeZdYjz1hmPfKMZdZ9z0S7gXDoGdu3MfKMVZdHnrHq8sgz0Twz8Ix1suuv4ON5biAUXqfG89xAKO4Z62T37cVnvOplhaJOPM+9htKKd57LCsU9Y5n1yDOWWY88E80zA8/Yvo2RZ6y6PPKMVZdHnrHq8sgz1slusII/zw2E0uvU89xAKO4Z62T3/cXnVS8rlHViNMXrK955LisU94xl1iPPWGY98oxl1iPP2L6NgWfsBsKhZ6y6PPKMVZdHnrFOdoMV/HluIJRep57nBkJxz1gnu+8vPq96WaGsEy2zHimeZdYDz9gNhEPPWGY98oxl1iPP2L6NkWeieWbgGasujzxj1eWRZ6yT3WAFf54bCKXXqee5gVDaM1e9gVB08XnVywplnWiZ9UDxznNZobhnonlm4BnLrEeescx65BnbtzHyjFWXR56x6vLAM3YD4dAz1slusII/zw2E0uvU89xAKO6ZaIvPby8+r3pZoawTLbMeKZ5l1iPPWGY98oxl1gPP2A2EQ8/Yvo2RZ6y6PPKMVZdHnonmmYFnrJPdYAV/nhsIpdep57mBUNwz1snu+4vPq15WKOrE89xrKK1457msUNwzllmPPGOZ9cgz0Twz8Izt2xh5xqrLI89YdXnkGasujzxjnewGK/jz3EAovU49zw2E4p6xTnbfX3xe9bJCWSdGU7y+4p3nskJxz1hmPfKMZdYjz1hmPfKM7dvoeybZDYRDz1h1eeQZqy6PPGOd7Por+OSirVO769R0nhsIxT1jney+vfhMV72sUNaJllmPFM8y64Fn7AbCoWcssx55xjLrkWds38bIM9E8M/CMVZdHnrHq8sgz1slusII/zw2E0uvU89xAKO2Zq95AKLr4vOplhbJOtMx6oHjnuaxQ3DPRPDPwjGXWI89YZj3yjO3bGHnGqssjz1h1eeAZu4Fw6BnrZDdYwZ/nBkLpdep5biAU90y0xee3F59XvaxQ1omWWY8UzzLrkWcssx55xjLrgWfsBsKhZ2zfxsgzVl0eecaqyyPPRPPMwDPWyW6wgj/PDYTS69Tz3EAo7hnrZPf9xedVLysUdeJ57jWUVrzzXFYo7hnLrEeescx65Jlonhl4xvZtjDxj1eWRZ6y6PPKMVZdHnrFOdoMV/HluIJRep57nBkJxz1gnu+8vPq96WaGsE6MpXl/xznNZobhnLLMeecYy65FnLLMeecb2bQw8YzcQDj1j1eWRZ6y6PPKMdbIbrODPcwOh9Dr1PDcQinvGOtl9f/F51csKZZ1omfVI8SyzHnjGbiAcesYy65FnLLMeecb2bYw8E80zA89YdXnkGasujzxjnewGK/jz3EAovU49zw2E0p656g2EoovPq15WKOtEy6wHineeywrFPRPNMwPPWGY98oxl1iPP2L6NkWesujzyjFWX+57JdgPh0DPWya6/gs/nuYFQeJ2az3MDobhnoi0+v7v4zFe9rFDWiZZZjxTPMuuRZyyzHnnGMuuBZ+wGwqFnbN/GyDNWXR55xqrLI89E88zAM9bJbrCCP88NhNLr1PPcQCjuGetk9/3F51UvKxR14nnuNZRWvPNcVijuGcusR56xzHrkmWieGXjG9m2MPGPV5ZFnrLo88oxVl0eesU52gxX8eW4glF6nnucGQnHPWCe77y8+r3pZoawToyleX/HOc1mhuGcssx55xjLrkWcssx55xvZtDDxjNxAOPWPV5ZFnrLo88ox1shus4M9zA6H0OvU8NxCKe8Y62X1/8XnVywplnWiZ9UjxLLMeeMZuIBx6xjLrkWcssx55xvZtjDwTzTMDz1h1eeQZqy6PPGOd7AYr+PPcQCi9Tj3PDYTSnrnqDYSii8+rXlYo60TLrAeKd57LCsU9E80zA89YZj3yjGXWI8/Yvo2RZ6y6PPKMVZcHnrEbCIeesU52gxX8eW4glF6nnucGQnHPRFt8fnvxedXLCmWdaJn1SPEssx55xjLrkWcssx54xm4gHHrG9m2MPGPV5ZFnrLo88kw0zww8Y53sBiv489xAKL1OPc8NhOKesU523198XvWyQlEnnudeQ2nFO89lheKescx65BnLrEeeieaZgWds38bIM1ZdHnnGqssjz1h1eeQZ62TXX8GX09xAWKjlu2dKCPW769RymhsI5T1zlhz4Dz1Dbn+byKXY88xZcmB5z0TzzMAzZ8mB/9gzcqWccpprBQ914lky60pxl7BKJffynrPkyjX4fcLUQO27uXI5zZ2C4p45zZ2C8p45S64s75mz5MrynjlLrizvmWieGXjmLLmyvGfOkgDLe+Y0We2feoar/Z3mTsGaHlXRml3rcT1NVltj2LnW3Jvxp7mhr7bHYrg51+VqVdpBlfY0d+7Je+ayVVrBYtFpruc71ImWzw6yttPc5Cfvmcvms6xnrKY78ozVdAeeOc1NfvKesZruyDNW0x15xmq6I89Eq0L1q1CnuXPvgyrUaW7R+6AKdZp78T6oQp3mpjvxWstpbroT98xpbro7soBymkvxDnWi5bODrO009+fJeyaaZwaesZruyDNW0x15xmq6I89YTXfkGavpDjxzmpvu5D1z2ZouV4U6zU13H1ShTnN33QdVqNPcRvdBFeo098uJ11pOc7+cvGfOknkeWUA5zVV0hzrR8tlB1naaW+vkPWN7FEaesZruyDNW0x15JppnBp6xmu7IM1bTHXnGarojz1y2pstVoU5zv9wHVajT3Bj3QRXqNHfAfVCFOs2tbuK1ltPc6ibvmWgFlG8XUE5zq9uhTrR8dpC1neZWN3nP2B6FkWespjvwzGludZP3jNV0R56xmu7IM1bTHXkmmmcGnrlsTZerQp3mVrcPqlCnuaftgyrUaW5e+6AKdZoL0sRrLae59UzeM3aY7PsFlNNckHaoEy2fHWRtp7lLTd4ztkdh5Bmr6Y48YzXdkWespjvyjNV0+56pp7lLTd4zVtMdeeayNV2mClVPc5caX4WqLl6mClVPc98ZX4WqV72WjK211NPcNSbvGTtM9u0CSj3NJWZHOtHuOxtlbXbf2dAztkdh5Bmr6Y48E80zA89YTXfkGavpjjxjNd2RZ6ymO/LMZWu6XBXqPHep8VWo09yl9kEV6jS3o31QhbrqfWd8reWql5h94Bk7TPb9AsppLjE71ImWzw6yNrvvbOgZ26Mw8Izddzb0jNV0R56xmu7IM1bTHXkmmmcGnrGa7sgzl63pclWo89ylxlehTnOX2gdVqNPcjvZBFeqq953xtZarXmL2gWfsMNn3CyinucTsUCdGy9r6WZvddzb0jO1RGHnGarojz1hNd+QZq+kOPGP3nQ09YzXdkWespjvyzGVrulwV6jx3qfFVqNPcpfZBFeo0t6N9UIW66n1nfK3lqpeYfeAZO0z2/QLKaS4xO9SJls8Osja772zoGdujMPJMNM8MPGM13ZFnrKY78ozVdEeesZruyDNW0x145jy3o0lXoc5zlxpfhTrNXWofVKFOczvaB1Woq953xtdarnqJ2QeescNk3y+gnOYSs0OdaPnsKGuzfHbgGbvvbOgZq+mOPGM13ZFnrKY78kw0zww8YzXdkWespjvyzGVrulwV6jx3qfFVqNPcpfZBFeo0t6N9UIW66n1nfK3lqpeYfeAZO0z2/QLKaS4xO9SJls8Osja772zoGdujMPKM1XRHnrGabt8zze47G3rGarojz1hNd+QZq+mOPBOtCtWtQrXz3KXGVqHaae5S46tQ7TS3o/FVqHbV+87YWku76iVmvGdOczPZgQWUdppLzA51ouWzg6zN7jsbeiaaZwaesZruyDNW0x15xmq6I89YTXfkGavpDjxznvvOxD1z2ZouV4U6z11qfBXqNHepfVCFOs3taB9Uoa563xlfa7nqJWYfeMYOk32/gHKaS8wOdaLls4Osze47G3rG9iiMPGM13ZFnrKY78kw0zww8YzXdkWespjvyjNV0R565bE2Xq0Kd5y41vgp1mrvUPqhCneZ2tA+qUFe974yvtVz1ErMPPBOtgPLtAsppLjE71ImWzw6yNrvvbOgZ26Mw8ozVdAeesfvOhp6xmu7IM1bTHXnGarojz0TzzMAzl63pclWo89ylxlehTnOX2gdVqNPcjvZBFeqq953xtZarXmL2gWfsMNn3CyinucTsUCdaPjvI2uy+s6FnbI/CyDNW0x15xmq6I89YTXfkGavpDjxz3fvOWM9YTXfkmcvWdLkq1HnuUuOrUKe5S+2DKtRpbkf7oAp11fvO+FrLVS8x+8Azdpjs+wWU01xidqQT7b6zUdZm950NPWN7FEaesZruyDPRPDPwjNV0R56xmu7IM1bTHXnGarojz1y2pstVoc5zlxpfhTrNXWofVKFOczvaB1Woq953xtdarnqJ2QeescNk3y+gnOYSs0OdaPnsIGuz+86GnrE9Cl3PJGf3nQ09YzXdkWespjvyjNV0R56J5pmBZ6ymO/LMZWu676tQm2dOkwNzVaiN62myWq4KtXE9TZ7KVaGSu+p9Z1ytZfPMRc+dfeAZO0z23QLK5sSLln9lnRgta+tnbXbf2dAztkdh5Bmr6Y48YzXdkWespjvwjN13NvSM1XRHnrGa7sgzl63pclWo89ylxlehTnOX2gdVqNPcjvZBFeqq953xtZarXmL2gWfsMNn3CyinucTsUCdaPjvI2uy+s6FnbI/CyDPRPDPwjNV0R56xmu7IM1bTHXnGarojz1hNd+CZ89yOJl2FOs9danwV6jR3qX1QhTrN7WgfVKGuet8ZX2u56iVmH3jGDpN9v4BymkvMDnWi5bOjrM3y2YFn7L6zoWespjvyjNV0R56xmu7IM9E8M/CM1XRHnrGa7sgzl63pclWo89ylxlehTnOX2gdVqNPcjvZBFeqq953xtZarXmL2gWfsMNn3CyinucTsUCdaPjvI2uy+s6FnbI/CyDNW0x15xmq6A8/YfWdDz1hNd+QZq+mOPGM13ZFnolWh+lWo89ylxlehTnOX2gdVqNPcjvZBFeqq953xtZarXmLGe+Y0N5MdWUA5zSVmhzrR8tlB1mb3nQ09E80zA89YTXfkGavpjjxjNd2RZ6ymO/KM1XQHnjnPfWfinrlsTZerQp3nLjW+CnWau9Q+qEKd5na0D6pQV73vjK+1XPUSsw88Y4fJvl9AOc0lZoc60fLZftbm7b6zoWdsj8LIM1bTHXnGarojz0TzzMAzVtMdecZquiPPWE135JnL1nSZKpQ/z11qbBXKn+YuNb4K5U9zOxpfhfJXve+MrbX4q15i9oFnohVQvltA8ae5xOxQJ1o+O8ja7L6zoWdsj8LIM1bTHXjG7jsbesZquiPPWE135Bmr6Y48E80zA89ctqbLVaHOc5caX4U6zV1qH1ShTnM72gdVqKved8bXWq56idkHnrHDZN8voJzmErNDnWj57CBrs/vOhp6xPQojz1hNd+QZq+mOPGM13ZFnrKY78Mx17ztjPWM13ZFnLlvT5apQ57lLja9CneYutQ+qUKe5He2DKtRV7zvjay1XvcTsA8/YYbLvF1BOc4nZkU60+85GWZvddzb0jO1RGHnGarojz0TzzMAzVtMdecZquiPPWE135Bmr6Y48c9maLleFOs9danwV6jR3qX1QhTrN7WgfVKGuet8ZX2u56iVmH3jGDpN9v4BymkvMDnWi5bODrM3uOxt6xvYoDDxj950NPWM13ZFnrKY78ozVdEeeieaZgWespjvyzGVrulwV6jx3qfFVqNPcpfZBFeo0t6N9UIW66n1nfK3lqpeYfeAZO0z2/QLKaS4xO9SJ0bK2ftZm950NPWN7FEaesZruyDNW0x15xmq6A8/YfWdDz1hNd+QZq+mOPHPZmi5XhTrPXWp8Feo0d6l9UIU6ze1oH1ShrnrfGV9rueolZh94xg6TfbuAQqe5xOxQJ1o+28/ayO47G3rG9iiMPBPNMwPPWE135Bmr6Y48YzXdkWespjvyjNV0B545z+1owlUoOs9damwVik5zlxpfhaLT3I7GV6HoqvedsbUWuuolZh94xg6Tfb+AcppLzA51ouWzo6zN8tmBZ+y+s6FnrKY78ozVdEeesZruyDPRPDPwjNV0R56xmu7IM5et6XJVqPPcpcZXoU5zl9oHVajT3I72QRXqNPedtZzrznUD1eN6llyyFZ8eXJPrcT1LdthaeMzhVrtzOJ6DK7nt/+4VGue6aox8w1er5f6kNiL1+de/wQMnWTx44DzoC3hPHfDAqQoPHjf32BDn9EDf/Ct64BuhPkGPmx/8HX3poMdVfO82dDt6Sj30uBr+CXpcVfYu0CPmhNSJ9sA3FH2CHldovXf+nuT4X1Ongx5XaT9Bjyu1n6AH1loePfBtNRviRA/0tfPWAt8o8wl6YK39gn77bx30wFr7wbwH1toP0ANr7QfoVWst8E0hG+Kcn2JOJ8cEvs3jE/TQWsvFe+BbMT5Br0Vru2oFfHPFBzEH+C6KT9Cr1lrgOx0+QQ+ttVy8B77F4BP00FrLxnvVWgvcsf8DtQLuqv9BzAHufP8JetVaC9xB/hP00FrLxXvgTuyfoIfWWjbeq9Za4I7mH6gVcI/yD2IOcB/xT9Cr1lrgJtufoIfWWi7eA3eg/gQ9tNZy8R64k/Mn6LVobV+tVH+vBe5a/Al61VoL3P33E/TQWsvFe+Auup+gh9ZaLt4Dd7r9BL0Wre2qFXB/2U9ijmatDcDNVz9Br1lrA3BnUj7eB+DuoZ+gh9ZaJt4H4C6cn6DXorU9tQrA3Sw/iTmatTYAd4X8AD1w58ZP0ENrLRfvgfslfoIeWmu5eA/c0/AT9Fq0tqtWwL0BP4k5qrUWuBveJ+hVay1wV7kP4j1w57dP0Gs589ON98Ad1D5Br0Vru2oF3Insk5ijWmuBO3p9gl611gL30fog3gN3xvoEvebztQG4e9Un6LVobVetgDtMfRBzgHtGfYJetdYCd436BL3m87UBuW8Ujx65bxQf75H7Rn2AXnMvi4DcN4qPOch9oz5Ar1prVfeNCth9o9h4r1prsftGcfFedd+ooKZvVFetsPtGcTFHdd+ooLpvVFDdNypg943i4r3qvlEBu28UG+9Va62avlFdtcLuG8XFHNV9o4LqvlFBdd+ogN03iov3qvtGBey+UWy8V621avpGddUKu28UF3NU940KqvtGBdV9owJ23ygu3qvuGxWw+0Zx8V5136igpm9UX61U70NW3TcqqO4bFVT3jQrYfaO4eK+6b1TA7hvFxXvVfaOCmr5RXbXC7hvFxhzVWqu6b1RQ3TcqYPeN4uK96r5RAbtvFBfvVfeNCmr6RnXVCrtvFBtzVGut6r5RUXXfqIjdN4qJ91F136iI3TeKiffRadbaqKZvVE+tInbfKDbmaNbaqLpvVFTdNypi943i4r3qvlERu28UF+9V942KavpGddUKu28UG3NUa63qvlFRdd+oiN03iov3qvtGRey+UVy8V903KqrpG9VVK+i+UVQeMSc46qBH1tpAT+hjDz2y1vLokbWWR4+stSGWB/rSe2uRtZZFD903ikePrLXBtyf0voN+sda2HX3+mjT2/uV7llN83H+6icAdetALPeqFnnChl/j7t9VTD3rWC73ohV71zvWmFvrq/lCS0L3auR6B1ZSDjqumNdz/4ZpKDzqumrLQcdWUhQ6splyEAVZTDrpeNY3AasoExwSsphx0XDXlIkzCVVMWul41Xd31SRK6XjVNetU06VXTpFdNk141zXrVNOtV06xXTbNeNV3d10kSul41zXrVNOtV06xXTbNeNS161bToVdOiV02LXjVd3blJErpeNS161bToVdOiV02LXjWtetW06lXTqldNq141Xd2bSRK6XjWtetW06lXTqldNq141bXrVtOlV06ZXTZteNV3dfUkSul41bXrVtOlV06ZXTZtaNU1OrZomp1ZNk1OrpsmpVdPk1KppcmrVNDm1apqcWjVNTq2aJqdXTb1eNfV61dTrVVOvV01Xd1CShK5XTb1eNfV61dTrVVOvV01Jr5qSXjUlvWpKetV0dY8kSeh61ZT0qinpVVPSq6akV02DXjUNetUUuBcSC12vmgL3QmKh61VT5F5ITFxH7oXEQderpsi9kBhJQu6FxEHXq6bAvZBY6HrVVG8vpKS3F1LS2wsp6e2FlPT2Qkp6eyElvb2Qkt5eSElvL6SktxdS0tsLKenthZT09kJKenshJb29kJLeXkhJby+kpLcXUtLbCynp7YWU9PZCSnp7ISW9vZCS3l5ISW8vpKS3F1LS2wsp6e2FlPT2Qkp6eyElvb2Qkt5eSElvL6SktxdS0tsLKenthZT09kJKenshJb29kJLeXkhJby+kpLcXUtLbCynp7YWU9PZCSnp7ISW9vZCS3l5ISW8vpKS3F1LS2wsp6e2FlPT2Qkp6eyElvb2Qkt5eSFlvL6SstxdS1tsLKevthZSdWjXNenshZb29kLLeXkhZby+krLcXUtbbCynr7YWU9fZCynp7IWW9vZCy3l5IWW8vpKy3F1LW2wsp6+2FlPX2Qsp6eyFlvb2Qst5eSFlvL6SstxdSBu6FVEu7Q2+tBx1XTVnouGrKQsdVUw46cC8kFjqwmnLQgdWUgw6sphz0b6up93VPq0N9RvOftv/yX//9X//5z3/97//5n//2L//lP/713/7H//o11P36D/L97aF5e/92esE/MIf0F2bf35rJD2tTw/pbEvlhfm4YzQ0Lc8Pi3LA0NyzPDZubJXVultS5WdLmZkmbmyVtbpa0uVnS5mZJf1tDLvG+Cs+luM6w7nMrzsc9QIbcGdZmhlH/oy4/zM8N6z+31tr7YaVvLZaHZvjOsDo3rE0N825uWJ9bcLsnA3Vc0i8z8cPa1LB+eYUf1p8lYV9qlfC81tqH0dywMDcszg1L7LBMnWGDB1Afw1p9HRbc3DA/N4zmhoW5YX1PRtonVwyhM6xODeu3dys1+fuwmnvD+rMk5j33i7l1hqW5YXluWD+WbB8x7sO2WkBnWJ0b1qaG9ZsZ8cP83DCaGxbmhsW5Yf3nluo+lVPrxJJ+I4tS9rVLqZ28hPpNJPhhNPXi9Jsn8MPi3LA0NyzPDStzw+rcsDY1rH9Amx82FyfL3Cwpc7OkzM2SwsfJ3htQ6tywNjWsurlhgziZ97c7l44I99em2wJl9+SXb4b7sDI3rM4Na1PD2sCTrTyGpc4wPzeM5oaFuWFxbliaG5bnhg2eW9rnZEmvzy04Xt/817f7tTrnY033pGn7uzP1w2AtW31+p4ehv5blZDT0N8Xyw+LcsDQ3LM8NK388bPtv/tdvfe7HO++3aXB/fj74l+e3DfSzA2l2YJgdGGcHptmBeXZgmR1YZwd2o4TPKdyrQ9vfr2tqn/vx/ZOBfnYgzQ4Mg4HFPwbW3sA4O7D/HHPeFxc+b5WpzsD+c8yFHhy3ZWhnYJsbWJybHehnBw6e45Y2Pga+1iy2gWF2YJwdmGYH5tmBZXZgnR04mDn1ETq2aO9fB3o3O9DPDhzNnKf38ct+r352sq1g9t/Tlttzv/91HPv++1+HyTrAAiqwiAosoQLLqMAKKrCKCqyBAiN3FLA9wP46WdoB5oWAhfAErPHLxb2YsP3tqQMsHwTs/Tp2A1ZQgVVUYA0UWHCowDwqsFF2kZ5yztwbmGYH5tmBZXZgnR3YJgdGNzvQzw6k2YFhduDszImzMycOZk4N5fESve452AaW2YF1dmCbHJjc7MDBBGiPBCO3HDsDw+zAgVdbfkBtpZM79b+//lob7rnNthzrlB36X2A/GUizA8PswDg7MM0OzLMDy+zAOjuwDQbu+zR+LUk6yW0ZzZzHlNuWDNy3ja3weZ/aWynz6V1qvX3QFPdzaPRcmmy/IXk8SIQHKeBBiniQEh6kjAepwEEafBHbFuP7x4Lt7/Qa0Abfpwrtn3h/LQM7kXDwmalQeIRQiqEzsM4ObJMDB5+ZPhjoZwfS7MAwOzDODkyzAwcvJuWnmdPLvlqZHVhnB7a5gXXwYWtb5u8rhRKIOgP97ECaHRhmB8bZgWl2YJ4dOJg5IT4NTKkzsM4ObJMDvZsdOJo54Xlg7gyk2YFhdmCcHZhmB+bZgWV24GjmPMrg29+d0OHb5EByswP97MDRzClPA5vrDAyzA+PswDQ7MM8OLLMD6+zAwcyJT7lcpFdFroPi8wcD/exAmh04mDnRPQ+MnYFxdmCaHZhnB5bZgXV2YJscGEcZcn0kSDGk/8NV+4Pffx+7Ch69kKH9tNb2d2K/WrKfIWokIWApPoDlzsyP4Qc80DUUVxlKqwzlVYaKkKGSH4YaCczSKgSsPTywBYeOoSbvga6h5FYZ8qsM0SpDQpEk+vIwFML3Z2kSijwxPHkgdtZKKf2AB7qG8ipDZZWhuspQmysw1tFHOn6gnx1IswPD7MA4OzDNDsyzA8vswDo7cHbmlNmZU2ZnzuBTDvslug4+uOTWHotE5zqJ9OCzyAcDy+zAOjuwTQ4cHCz6YKCfHUizA8PswDg7cHbm1NmZU2dmzvbf6Nev/aDVGBHdX5FfDSUeg339y+qgzRc/LM0Ny/1hifZhpTeszA2rc8Pa1LD+Iv/XIc/7sPB8YGIf5gfD4mMYdYbRYFjYh/UeQAxzwwazpO0uCc/fsPZhaW5Y/uNh238Lf70Hg0pDdHT/GhxdeRrsaifvCnH3/vZn+vLr/zSuMkgbiSuMpBVG8gojZYWRusJIW2CkXxmQNuJXGFnxxqcVb3xa8canFW98WvHGpxVvfFrxxmeJB5/2X29/UseIhLtSfhh5btu3G5FwV6Z7CSzk50MQ/V/7vUXu9md+SScGC91DIRWHB8njQSI8SAEPUsSDlPAgZTxIBQ8SXvQueNG74kXvihe9K170rnjRu+JF73pA9K77r33rQcp4kAoepIoHqcFBag4P0vo3jvZ2mYGet6ztkNbPpbB/6w4h9CCtn0thP74fQvtavO817yj3ArVPz58xfxNozmkn4MEJ5EeTkvx85msnQPAEHv21gu8QCOgEHruXcs4dAlE7gaSdQIYn8NQKoReFinYCVTsBdCXmCHh0Jc5PvVJajwC6EhfaU4kSO0rs0ZW4uPKeALoSl7xvQi+1k0p4dCUueT/rUV3sEIBS4huk9doa95Q3RKIOpIIHqeJBanCQyOFB8niQCA9SwIO0PtbH+NjykDqhkhIepIwHqeBB+uHofTPSFhgJboURkZj5KCDXwP26OHpcrUn16dflNyTCgxTwIEU8SAkPUsaDVPAgVTxIDQ5SdHiQ8KJ3xIveES96R7zoHfGid8SL3hEveqcDgsC+R6e47DqQ1k9vv3+aLP75esEd0vrpvdXG75Do+XPvr2u7Xv9tZt9TS1k7gaKdQNVOoCknkJ12Al47AdJOIGgnELUT0K7EWbsSZ+1KnLUrcdauxEW7EhftSlzglfj9tvJW4JWYIwCvxBwBeCXmCMArMUcAXokZAhU9jDInSVpFf4mZcyetor/Esoc8KvorL0wXPUDInoCp6Im97HmZir4MkD3b0dAXDcJ00bVRmC76gkT2kEZDX74I043XonuurIqle66sijuf1M6VVXGnmdq5siru7FM7V1b1/qQUOXeurOr9uaqNruKs6kYAPU96f1xjI4Ce+bAEonYC6NkJSwA932AJoGcQLAH0nIAlgK7yHAGPrtvvj1ptBNCVmCUAr8QcAXgl5ghAKfENEpS23iBBqeUNEpT+3SCtVzR67IP/culK/2XI+10robjnqkT7TaApJ0BOOwGvnQBpJxC0E4jaCSTtBLJ2AkU7Ae1KTNqVOGhX4qBdiYN2JQ7alfiADhnCBLQrcdCuxEG7EgftShzRX+ISw04ghw4B9ClUy76/uHWfANQUukGCSs/+gpSgEq4bpOUpVKV4f5srPb8M3ZlXXL0j2f6k15mXSDuBAE4g7Ffbl1Bzh0DUTiBpJ5C1Eyh6CMSe/q3v+iFNoKETCHGfQrG9Eljf9UOaALoSswTQlZglAK/EHAF4JeYIwCsxRwBeiTkC8ErMEYBXYo6AdiUu2pW4aFfiol2Ji3YlXt/1Q5qAdiUu2pW4aFfiol2Ji3YlrtqVuGpX4qpdiat2JV7fukeagHYlrtqVuGpX4qpdiat2JW7albhpV+KmXYmbdiVe3xxGmoB2JW7albhpV+KmXYmbciX2TrkSe6dcib1TrsTeKVdi75QrsXfKldg75UrsnXIl9k65EnunXYm9diX22pXYa1dir12J17c2kSagXYm9diX22pXYa1dir12JSbsSk3YlJu1KTNqVeH1LFmkC2pWYtCsxaVdi0q7EpF2Jg3YlDtqVOGhX4qBdide3ZJEmoF2Jg3YlDtqVOGhX4qBdiaN2JY7alThqV+KoXYnX91WSJqBdiaN2JY7alThqV+KoXYmTdiWG77HFEtCuxPg9tjgC2pUYv8cWR0C7EuP32OIIaFdi7T22vPYeW157jy2vvceW195jy2vvseW199jy2ntsee09trz2Hltee48tr73HltfeY8tr77HltffY8tp7bHntPba89h5bXnuPLa+9x5bX3mPLa++x5bX32PLae2x57T22vPYeW157jy2vvceW195jy2vvseW199jy2ntsee09trz2Hltee48tr73HltfeY8tr77HltffY8tp7bHntPbZIe48t0t5ji7T32CLtPbbIKVdi0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48t0t5ji7T32CLtPbZIe48tgu8vFCndCcRMHQLo70BO+U4gl9QhAPUO/AUJq1/NDRJUxniDBJUD3iBBZXU3SBEP0vqYl+r9367ZOyZkpBrK719vf9bXkHFAJxdhAkU7gaqdQNNNIBzQyUWYgNdOgLQTCNoJRO0ElCtxcMqVODjlShycciUOTrsSe+1K7LUrsYfXgRruBJqjDgH0KNR83QlQ6RCAikI3SFBx5S9IBBUpbpDWv/ul7OWJUnuQCA9SwIMU8SAlPEgZD1LBg1TxIDU4SAd0J2Ah4UXvgBe9A170DnjRO+BF74AXvQNe9D7grHatdIe0LW06kJbPpeb9/Tt589Tz0nKNa8ndl60txdSBtFzjWiZ3h5TzV0i9f7vdZ14ozr2u+tafTZQm4LUTIO0EgnYCUTuB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PEgRD1LCg5TxIBU8SBUPUoODFPCid8CL3gEvege86B3wonfAi94BL3oHvOgd8KJ3wIveES96R7zoHfGid8SL3hEveke86B3xonfEi94RL3pHvOid8KJ3woveCS96J7zonfCid8KL3gkveie86J3wonfCi94ZL3pnvOid8aJ3xoveGS96Z7zonfGid8aL3hkveme86F3wonfBi94FL3oXvOhd8KJ3wYveBS96F7zoXfCid8GL3hUvele86F3xonfFi94VL3pXvOhd8aJ3xYveFS96V7zo3fCid8OL3g0veje86N3wonfDi94NL3o3vOjd8KJ3g4ve2cFF7+zgond2cNE7O7jonR1c9M4OLnpnBxe9s4OL3tnBRe/s8KK3x4veHi96e7zo7fGit8eL3h4venu86O3xorfHi94eL3rjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31jLjnbXMeGctM95Zy4x31rLgnbUseGctC95Zy4J31rI4uOhd8M5aFryzlgXvrGXBO2tZ8M5aFryzlgXvrGXBO2tZ8M5aFryzlgXvrGXBO2tZ8M5aFryzlgXvrGXBO2tZ8M5aFryzlgXvrGXBO2tZ8M5aFryzlgXvrGXBO2tZ8M5aFryzlgXvrGXBO2tZ8M5aFryzlgXvrGXBO2tZ8M5aFryzlgXvrGXBO2tZ8M5algPOx0VKd0gxUwfS+rmUU75DyiW9Qvrpk183I36FEVphJKwwElcYSSuMSLyDqd5/XbN3zIRPNZTfv97+rJ0JX/AgVTxIDQ6SyCknYUgeDxLhQQp4kCIepIQHCS96Z7zonfGid8aL3gUvehe86F3wonc5IC7VcIfUXGcZVda/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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"7":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"62":{"source":"use jwt::JWT;\n\nfn main(\n    data: BoundedVec<u8, 512>,\n    base64_decode_offset: u32,\n    pubkey_modulus_limbs: [Field; 18],\n    redc_params_limbs: [Field; 18],\n    signature_limbs: [Field; 18],\n) -> pub bool {\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_number(\"recyclabilityPercentage\".as_bytes(), 85);\n\n    true\n}\n","path":"/home/david/dev/noir/circuit/src/main.nr"},"63":{"source":"use base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse rsa::{rsa::verify_sha256_pkcs1v15, types::RBN2048};\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\nuse zkemail::partial_hash::partial_sha256_var_end;\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [Field; 18],\n    redc_params_limbs: [Field; 18],\n    signature_limbs: [Field; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [Field; 18],\n        redc_params_limbs: [Field; 18],\n        signature_limbs: [Field; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [Field; 18],\n        redc_params_limbs: [Field; 18],\n        signature_limbs: [Field; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature: RBN2048 = RuntimeBigNum::from_array(params, self.signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/root/nargo/github.com/zkemail/noir-jwt/v0.4.3/src/lib.nr"},"65":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let r = unsafe {\n        //@safety r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n        __boundary_check(limit)\n    };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir_base64/v0.4.0/src/boundary_check.nr"},"66":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[input_byte]\n                } else {\n                    BASE64_DECODE_BE_TABLE[input_byte]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[input_byte]\n            } else {\n                BASE64_DECODE_BE_TABLE[input_byte]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        unsafe {\n            //@safety get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n            // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    assert_eq(\n        has_first_padding_byte_claim,\n        has_second_padding_byte_claim * has_first_padding_byte_claim,\n        \"if first byte contains padding so must the second\",\n    );\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/root/nargo/github.com/noir-lang/noir_base64/v0.4.0/src/decoder.nr"},"103":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_120: Field = 0x1000000000000000000000000000000;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, MOD_BITS>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        let TWO_POW_120 = 0x1000000000000000000000000000000;\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let field_val = if N < 2 {\n            result[0]\n        } else if N == 2 {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120\n        } else {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n        };\n        assert(field_val == field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120;\n        r *= TWO_POW_120;\n        modulus_mod_n *= TWO_POW_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += params.modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [Field; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += borrow_flags[0] as Field * TWO_POW_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * TWO_POW_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    validate_in_range::<_, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb =\n            modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * TWO_POW_120);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n                + (borrow_flags[i] as Field * TWO_POW_120);\n            assert(result_limb == 0);\n        }\n        let result_limb =\n            modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [Field; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb =\n            lhs[0] + rhs[0] - subtrahend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] + rhs[N - 1] - subtrahend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [Field; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/constrained_ops.nr"},"104":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/expressions.nr"},"106":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [Field; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = val[i].to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = val[N - 1].to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/serialization.nr"},"107":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                let idx = (i - 1) / 2;\n                carry_flags[idx] = carry as bool;\n                borrow_flags[idx] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quirky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_helpers.nr"},"108":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]; M] = std::mem::zeroed();\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_ops.nr"},"110":{"source":"use crate::utils::u60_representation::U60Repr;\n\npub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [Field; N],\n\n    // @brief modulus but represented in a U60Repr form\n    pub modulus_u60: U60Repr<N, 2>,\n    pub modulus_u60_x4: U60Repr<N, 4>,\n\n    // @brief double_modulus: used when performing negations and subtractions\n    pub double_modulus: [Field; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [Field; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [Field; N],\n        redc_param: [Field; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.modulus_u60 == other.modulus_u60)\n            & (self.modulus_u60_x4 == other.modulus_u60_x4)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/params.nr"},"111":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32>: Neg + Add + Sub + Mul + Div + Eq {\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self;\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    fn modulus(self) -> Self;\n    fn modulus_bits() -> u32;\n    fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    fn get_limbs(self) -> [Field; N];\n    fn get_limb(self, idx: u32) -> Field;\n    fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    fn __neg(self) -> Self;\n    // unconstrained\n    fn __add(self, other: Self) -> Self;\n    // unconstrained\n    fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    fn __div(self, other: Self) -> Self;\n    // unconstrained\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    fn __invmod(self) -> Self;\n    // unconstrained\n    fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    fn assert_is_not_equal(self, other: Self);\n    fn validate_in_field(self);\n    fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    fn udiv(numerator: Self, divisor: Self) -> Self;\n    fn umod(numerator: Self, divisor: Self) -> Self;\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n    fn is_zero(self) -> bool;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/runtime_bignum.nr"},"118":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\npub(crate) global TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\nunconstrained fn __split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\npub fn split_60_bits(x: Field) -> (u64, u64) {\n    // We assert that the two returned limbs fit within 60 bits each\n    // and reconstruct `x` when added together.\n    let (lo, hi) = unsafe { __split_60_bits(x) };\n    if !std::runtime::is_unconstrained() {\n        let lo_field = lo as Field;\n        let hi_field = hi as Field;\n        lo_field.assert_max_bit_size::<60>();\n        hi_field.assert_max_bit_size::<60>();\n        assert_eq(lo_field + (TWO_POW_60 as Field) * hi_field, x);\n    }\n\n    (lo, hi)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/split_bits.nr"},"119":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::{field_to_u60rep, TWO_POW_60};\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..N {\n            let (lo, hi) = split_bits::split_60_bits(input[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) fn new<let NumFieldSegments: u32>(x: [Field; N * NumFieldSegments]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        for i in 0..(N * NumSegments / 2) {\n            result[i] =\n                x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * TWO_POW_60 as Field);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            let idx = (N * NumSegments) - 1 - i;\n            if (b.limbs[idx] == self.limbs[idx]) {\n                continue;\n            }\n\n            result = b.limbs[idx] < self.limbs[idx];\n            early_exit = true;\n            break;\n        }\n        if early_exit {\n            result\n        } else {\n            self.limbs[0] == b.limbs[0]\n        }\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift = (60 - limb_shift) as u8;\n        let mask: u64 = (((1 as u64) << limb_shift) - 1) << remainder_shift;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = value >> limb_shift;\n            let remainder: u64 = (value << remainder_shift) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << limb_shift) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << limb_shift) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/u60_representation.nr"},"127":{"source":"global ASCII_HEX_TABLE: [u8; 16] = \"0123456789abcdef\".as_bytes();\n\npub fn field_to_hex(value: Field) -> str<64> {\n    let mut result = [0 as u8; 64];\n    let bytes: [u8; 32] = value.to_be_bytes();\n    for i in 0..bytes.len() {\n        result[i * 2] = ASCII_HEX_TABLE[bytes[i] / 16];\n        result[i * 2 + 1] = ASCII_HEX_TABLE[bytes[i] % 16];\n    }\n    From::from(result)\n}\n\n#[deprecated]\npub fn to_hex_string_bytes(value: Field) -> [u8; 64] {\n    field_to_hex(value).as_bytes()\n}\n\nglobal U64_STR_LEN: u32 = 20;\npub fn str_to_u64(arr: impl Into<[u8; U64_STR_LEN]>) -> u64 {\n    let arr = arr.into();\n\n    let mut parsed_number: Field = 0;\n    for i in 0..U64_STR_LEN {\n        let chr = arr[i];\n        if chr != 0 {\n            parsed_number *= 10;\n            let value = crate::tables::ASCII_TO_NUMBER[arr[i]] as Field;\n            parsed_number += value;\n        }\n    }\n    parsed_number as u64\n}\n\npub fn ord(s: str<1>) -> u8 {\n    s.as_bytes()[0]\n}\n\n#[test]\nfn test_field_to_hex() {\n    let my_hash = 0x0d67824fead966192029093a3aa5c719f2b80262c4f14a5c97c5d70e4b27f2bf;\n    let expected = \"0d67824fead966192029093a3aa5c719f2b80262c4f14a5c97c5d70e4b27f2bf\";\n    assert_eq(field_to_hex(my_hash), expected);\n}\n\n#[test]\nfn some_test() {\n    let outer_hash = 0x0d67824fead966192029093a3aa5c719f2b80262c4f14a5c97c5d70e4b27f2bf;\n    let hex_challenge = field_to_hex(outer_hash);\n    let header_prefix: [u8; 26] = \"subject:Re: Tx request: 0x\".as_bytes();\n    let header: [u8; 90] = header_prefix.concat(hex_challenge.as_bytes());\n    assert(\n        header\n            == [\n                115, 117, 98, 106, 101, 99, 116, 58, 82, 101, 58, 32, 84, 120, 32, 114, 101, 113,\n                117, 101, 115, 116, 58, 32, 48, 120, 48, 100, 54, 55, 56, 50, 52, 102, 101, 97, 100,\n                57, 54, 54, 49, 57, 50, 48, 50, 57, 48, 57, 51, 97, 51, 97, 97, 53, 99, 55, 49, 57,\n                102, 50, 98, 56, 48, 50, 54, 50, 99, 52, 102, 49, 52, 97, 53, 99, 57, 55, 99, 53,\n                100, 55, 48, 101, 52, 98, 50, 55, 102, 50, 98, 102,\n            ],\n    );\n}\n\n#[test]\nfn test_str_to_u64() {\n    let s = \"13378584420\".as_bytes();\n    assert(str_to_u64(s.concat([0; 9])) == 13378584420);\n    assert(str_to_u64(\"02345678912345678912\") == 02345678912345678912);\n}\n\n#[test]\nfn test_char() {\n    assert(ord(\"a\") == 97);\n}\n","path":"/root/nargo/github.com/olehmisar/nodash/v0.39.4/src/string.nr"},"130":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_1024() {\n    // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world! test#123\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170,\n                193, 96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n            ],\n    );\n\n    let params: BigNumParams<9, 1024> = BigNumParams::new(\n        false,\n        [\n            0xab238ad9cb37979a43aefbf10be8fb,\n            0x31347febe45fe8c2dac1dd30900704,\n            0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n            0x5eac6390f7873fe97ff9bb14a173ea,\n            0xbc41f700c91fd733a2c63177bbdbd4,\n            0x41442bd58769a3595b659a2ec9c6be,\n            0x4ddc91395f330382aa2e2d3fbe147,\n            0x3d008ff255a0bc71c7887f5728ba1,\n            0xb640c3a8f511c64e,\n        ],\n        [\n            0x5d53d2634c6a0918266043968ce263,\n            0x5dd4be3dce0323a492ee9340aec4db,\n            0xf82d0e2e5c8319f01a460c72c01854,\n            0x236e6fc6e62e8a1d522acda5fb3892,\n            0xdaf755619d66e580901aa224d03174,\n            0x8366291616480e7e1f202dbcedda87,\n            0x40ba1202537d1e94561ccc05265586,\n            0x69b993d857ba89ea5de9822aeb4b93,\n            0x167968c0000761a273,\n        ],\n    );\n\n    let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xc3850e84ea02da3f028ff422f4d6a9,\n            0x9761f0bd9021f76d45c60df0670a19,\n            0xc1ede421a43607ab623ed4d5a17fc8,\n            0x86197b4315206f4d53200b42555831,\n            0xe95783b69db28c26a83706f39d04cd,\n            0x18b178dc1a9ec76fb22b57e4dfa703,\n            0xdd0e19cd5a09ab48e7af4d0e3470e3,\n            0x10004dfab1cf91304e80e6baa4dfc7,\n            0x241c3fd77b90adef,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048() {\n    // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131,\n                166, 79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n            0xbfb937fc4d3cf02cc0af780f3cab44,\n            0xd20637ef7adcf5d238ee87bccc9bca,\n            0xb9db4f2663108e2f8b673f7612ae8b,\n            0x85f894ef669b36bfd3d86b0a28873,\n            0xdcc70e1884e38b8229cce3b884121d,\n            0x35488d1138e0b03e1676f7f5d8a5b3,\n            0xe1a97820e7dcbb4eab35c9b71bb273,\n            0x97d19eb3c63249ddbfcff915863f54,\n            0x3a78c7af6da0f6af0d67b1ca4b6065,\n            0xd7a3c433c020f624821e5e678c7d69,\n            0x52d5b53240feae82ffea3d2a3d9b09,\n            0xb8aad5e19e2163f68997c6fdd71906,\n            0x5db432d06e8b0bf59511100c7894e2,\n            0xadc0bbc4c54da10d1cc88438ea3127,\n            0xece1cf6a1501109cd2734d5893c8d9,\n            0x7196b90acdf06c31b1288064fd0c27,\n            0xc8,\n        ],\n        [\n            0x1b1deccf4dbde852c34a5d6908a0f,\n            0xbc9e5bdab22f023fbcca58692bccf5,\n            0x1f65439685623e45396ff55751c3bf,\n            0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n            0x5ca2e8e3048243c16c708a8030ab0d,\n            0x30079bfeb1fa51e5501581173ca19c,\n            0xff8d5f6bea485fdcc2716327f69ab4,\n            0x36b599d81589416b5b5f037986b999,\n            0x75612e34a4ff29f0a19a7823512f58,\n            0x288b6897929b54c3b26a5faa07c00f,\n            0x4b5675fa13ab7444f1f047d3eb1bbe,\n            0x6ba0ac610ef9f267ab30fe25bb1c84,\n            0xa386b48ee03168d5cea3ecb9dc901f,\n            0xacf1a01f7dba44e050c976142fb1f6,\n            0x97a63b5cb7efc60d3502946aec63cf,\n            0x12cc1d5cab10a1e9e2398d29b9e3ef,\n            0x4635cf25c66e76bba8034df46204fb,\n            0x146f,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xad29e07d16a278de49a371b9760a27,\n            0x86311920cc0e17a3c20cdff4c56dbb,\n            0x863556c6c5247dd83668dd825716ae,\n            0xc247c960945f4485b46c33b87425ca,\n            0x7326463c5c4cd5b08e21b938d9ed9a,\n            0x4f89fe0c82da08a0259eddb34d0da1,\n            0x43a74e76d4e1bd2666f1591889af0d,\n            0x240f7b80f0ff29f4253ee3019f832d,\n            0xc6edd131fbaaf725fd423dac52b362,\n            0x85f9732679242163e8afff44f6104d,\n            0xd3c3bbcb1757013fd6fb80f31dd9a6,\n            0x9008633f15df440e6df6d21ee585a2,\n            0x324df3425ed256e283be5b6b761741,\n            0xc60c1302929bd0e07caa4aeff4e8fd,\n            0x600d804ff13ba8d0e1bc9508714212,\n            0x50f7e75e5751d7edd61167027926be,\n            0x0db41d39442023e1420a8a84fe81d9,\n            0xab,\n        ],\n    };\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n    // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132,\n                239, 227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0xe40ee47801326543c8e84b85d567c1,\n            0x5b54ea87f0ce29de1995697b0696fd,\n            0x457078f8fdce68b437cac0970b2452,\n            0x473ec776fee3731b6ab06e35875ddc,\n            0x62dedd594e5f12c80c3ccb5791a6cd,\n            0xecb934b9d8272c5e3a418145345499,\n            0xd1af643b3d785470ed0c6cd633f706,\n            0xb58a57b9e96eccbdfc7c17f0333d4,\n            0x2ebd34b5039fc596504927c282c60d,\n            0x3a44928a74f25fc1043bb37ce4dfa8,\n            0x91448459f9617fac33a2816162ac9e,\n            0x70cb910d9f3e1a78864640ec6c8240,\n            0x9aed33f6b31f1c9de67248a98c180,\n            0x7f1416e032c79488c94b311e87bd9c,\n            0x7191b4ebb1b3fffa949fa48ed01e5,\n            0x350a75cbaeca6bfdd71ca83cdbcae9,\n            0xfb1d274fa207457c6814d42c09f9cf,\n            0xd4,\n        ],\n        [\n            0x803bf4d38110a7d37fdd05f590dee9,\n            0xa68d317c933f37cab5ab4e7c00a3b9,\n            0x476a05a536bf5f2aa1b8850146cba7,\n            0xca297ea8b5528d91d4836ff27c30ab,\n            0x75cf2eaab76eefa12bbd570f1aea9f,\n            0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n            0xd497db1f6ebe83decacaa647fabea6,\n            0x686b27ca330e25e7a7cf197f6433ef,\n            0xfde04d2225c8308b07580af0058a0f,\n            0xa29fb69777c0e916976243b2b09855,\n            0xf983592285852e7e1c2cb3ae968323,\n            0x673608017f9f5acf67a01b73728d70,\n            0xeeff82521c0bc432a05f4b7444fac0,\n            0x85a89c4d229f60aaa3aa7ac7dac1e2,\n            0xcfecff93bc9fbfe0d6dff6091f2db8,\n            0xf20f047dcb224b4447bd098c07f8c2,\n            0x554bb53cadeb3eaab911a189f90227,\n            0x133b,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xa250eff812c63eaaeaa3f04641c05f,\n            0xecc09613cb8b289c1f37c8f92e6a05,\n            0x2c0a0510058360c07af65d46f594fd,\n            0x943d67513363d3de430c94a1dafe7c,\n            0x511ec8e9b10bc6c6ff0d6c232ccf92,\n            0x50ffd07b3c093b3f5fc027de847731,\n            0xc268e1489449943fdafdf89ff168c3,\n            0x0b8b7f9f49b492f78fda58d252f23a,\n            0x491c6c4ef836a6a8730b7bf81e865e,\n            0x8746c75fb079d014e419543f56d7f0,\n            0x65804c417d6168a8bc0025d255cebf,\n            0xf695e91b77890b8e3fd775fa56e627,\n            0x5e90001c0218550f4083ae28025a2f,\n            0x526bd4eff34f25f62a698f0470e0a6,\n            0x7f224306a7d9daf536b1559434c6c6,\n            0x88809f16fe1fcea3c87511d9319735,\n            0x7694685fee0bfab4a9196b92ec6f2e,\n            0xa7,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n}\n","path":"/root/nargo/github.com/noir-lang/noir_rsa/v0.6.0/lib/src/rsa.nr"},"135":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr"},"136":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine, lt_f};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: Field,\n        body_chunk_offset: Field,\n        num_full_chunks: Field,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: Field) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: Field) -> u8 {\n        self.body[idx as u32]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: Field,\n        starting_haystack_chunk: Field,\n        num_full_chunks: Field,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte as Field + (i as Field * 31) + j as Field;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate: Field = lt_f(i as Field, num_full_chunks) as Field;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as Field * (i as Field + starting_haystack_chunk)];\n            assert(predicate * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: Field = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: Field = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks =\n            lt_f(substring_length as Field, num_bytes_in_first_chunk as Field);\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks as Field * 31 + num_bytes_in_first_chunk as Field;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks as Field + chunk_index as Field + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index as Field;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: Field = chunk_offset as Field;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: Field = i as Field;\n            let predicate: Field = lt_f(i as Field, offset_to_first_needle_byte_in_chunk) as Field;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = (1 - predicate) * (idx - offset_to_first_needle_byte_in_chunk);\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index: Field =\n                starting_needle_byte_index_of_final_chunk as Field + i as Field;\n            let predicate = lt_f(lhs_index, substring_length as Field);\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as Field) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset: Field = chunk_index as Field + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk as Field,\n            body_chunk_offset,\n            num_full_chunks as Field,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/root/nargo/github.com/noir-lang/noir_string_search/v0.3.2/src/lib.nr"},"137":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub unconstrained fn get_lt_predicate_f(x: Field, y: Field) -> bool {\n    let a = x as u32;\n    let b = y as u32;\n    a < b\n}\n\npub fn lt_f(x: Field, y: Field) -> bool {\n    // Safety: As `x` and `y` are known to be valid `u32`s, this function reimplements the\n    // compiler's internal implementation of `lt`\n    unsafe {\n        let predicate = get_lt_predicate_f(x, y);\n        let delta = y as Field - x as Field;\n        let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n        lt_parameter.assert_max_bit_size::<32>();\n\n        predicate\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir_string_search/v0.3.2/src/utils.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","__split_60_bits","__mul","__compute_quadratic_expression_with_borrow_flags","extract_claim_unconstrained","__boundary_check","__validate_decoded","search","get_lt_predicate_f","directive_integer_quotient","directive_invert","directive_to_radix"]}