{"noir_version":"1.0.0-beta.2+1a2a08cbcb68646ff1aaef383cfc1798933c1355","hash":18314850744317800979,"abi":{"parameters":[{"name":"data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":512,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"},{"name":"signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":100,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"public"},"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5634341720269277520":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5675127253506927136":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"6314603625877298116":{"error_kind":"string","string":"haystack length of size 0 not supported"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6543056410826478903":{"error_kind":"string","string":"incorrect value for claim"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7788270038095378938":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"15412340888643424233":{"error_kind":"string","string":"needle length of size 0 not supported"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"18261670735869299181":{"error_kind":"string","string":"data length is too long"}}},"bytecode":"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","debug_symbols":"7P3drixJkl4Jvktd88JVTf+MrzIYDDjT7AGBBjkYsq+Ifve26srYEVnpYd8+HZLbv2UqvCoWDnYtkZR0VRFxXf4//+V/+c//7//9//v/+i//9X/9b//9X/7j/+N//sv/9t/+P//pf/yX//Zfr//f//yXXvr/9b/87/+///Rf//X//9//x3/6//+Pf/mPtb3+w7/85//6v/zLfzxW/T/+w7/8r//lf/vP//Ifx/U//sM/LbMef/u3ZfY//OPj//h//ofr749/8t+f/+S/v/7Jf/989/ePdf7298/z/u+3es6//dt2/P3f/8d/PL/+7Srj65+Wo/9fLPVlxFKMWKoRy/GTLKv+9ndXe8PSjFi6EcswYpk/yVLa+dsfLr21f6RZVjSnE83xsqIpVjTViuawomlWNN2KZljRWH0WH1afxYfVZ3Gz+ixuVp/FzeqzuFl9Fjerz+L2s5/FfbQvmrX+kWZY0UwrmmVF87OfxXP032hWrX9H84//+jzO3/712UoX/7r0V399hfoa/9gf9ddGsRbjWPur/hbrNXT7R/YKZj/A7A3M3p3Z+/piX/Uf2QeYfW70mbo2itX5XiA+C4bzOa/Ywef2AJ/bw/rcvv8MHtbntmB3PrdHKb+xjzr/kd353Fbszue2Ync+hxW787kq2OdG/fN0PoejYwWf2xPcb0/rc1uwW/fbgh3cb0/nc1uxg8/tCT63l/O5rdidz2HF7nyuKnbnc1WxO5+rit35XK3HbxfJs/bzH9mdz1XF7nyuKvaN5tJro331CZ5jn+A59gnuh09wP3w6n9uitznB++cTPMc+wXPsE9wPn9x+eLy4/fB4cfvh8eL2w+PlfK7G3jvHy/kcjo6VO8ceL+s5tmC3nmMLdudzW7Fbf6/r9p46inU/LNjB53YBn9uFO8cexfkcVuzc73WNwu2HR+H2w6PsM8ceZZ859qjcOfao3Dn2qNw59qjcOfb4WVdO7D21cufYo4LP7Qo+tyt3jj0qeI59gOfYB7gfPsD98LHRHPuHbUmfjRU8xz7Ac+wDPMc+wHPsAzzHbuA5dgOf2w18bjfwHPuHTVmx7OA5dgP3ww3cDzfnc/WP3yVvbz7fnc9VwW7t91LszueqYnc+VxW787mq2J3PVcVOeef0jp3yzukdO+Wd0zt28Llq7dMS7NY+LcUOPletfVqKHXyuWvu0FDv4XLX2aSl27vvhYe3TUuwbfY9qI//WsPZvid0E2Kc1wD6tAfZpDW+f1v1OCOzTGtY+LTFnBvu0BtinNcA+rQH2aQ2wT2uAfVrD2qcVfO+09m9Fxwr+3pW1r0uxg793Ze3fEuzePq37e6q3T0uwg89ta5+WYnc+txU7+HtXYJ/WAPu0BtinNax9WrH3zmnt34qOlTvHnta+LsXOnWPPl/O5rdi5c+zp7dMS7Nxze1r7tBQ7d449rX1aip07x55gn9YE+7SmtU8r+N5p7d+KjpU7x57Wvi7Fzp1jT2v/lmD39mnd31O9fVqCHXxuW/u0FLvzua3YuXPsCfZpTbBPa4J9WtPap3X/Hf5p7dNS7Nx3TtPap6XYKe+c/vHtxLT2Yyl263dO6+v+Xtc/fkZa+64Uu/U7J8Fu/c5JsG+0H7b2Y0XHCt4PW/u0FDt4P2zt01Ls4P2wtU9LsYP7YWuflmIH74etfVqKHbwftvZpKXbwnNnapxV877T2b0XHCt4PW/u6FDt4P2zt6xLs1r4ucU+19nUpdvC5be3rUuzO57ZiB++HrX1dih3cD1v7uhT7RnPsjXxdE+zrmmBf1wT7uibY1zXBvq4J9nVNsK9rgn1dE+zrmmBf1wT7uibY1zXBvq65ka9rbuTrmmBf1wT7uibY1zXBvq4J9nVNsK9rgn1dE+zrmmBf1wT7uibY1zXBvq4J9nVNa1/X/ZuVZe3fUuzcd07L2qel2Lm/57Rezufq/TunZe3TUuzcd07L2qel2LnvnJa1T0uwW/u0YmdRy9q/FR0rdz+8rH1dit353Fbs1vthwc7dDy9vn5Zg5/bDy9qnJditfVqKnbsfXmCf1gL7tBbYp7WsfVrB905r/1Z0rNz98LL2dSl27n54Wfu6FDt3P7ysfV2KHXxuW/u6FDt3P7ysfV2KnbsfXta+LsUO7oc38m8ta/9WdKzgOTbY17XAvq7l7esS7OA5trWvS7GDz22wr2uBfV0L7OtaYF/XAvu6lrWvS7FvNMe29m9FxwqeY4N9XQvs61revi7BDp5jW/u6FDv43Ab7uhbY17XAvq4F9nUtsK9rWfu6BLu1f0u8WbH2aSl28Dsna5+WYnc+VxU7+J2TtU9LsYPfOVn7tBQ7+J2TtU9LsW+077X2b0XHCt4PW/u6FDt4Pwz2aS1vn9b97MrbpyXYwf2wtU9LsYP3w2Cf1gL7tBbYp7XAPq1l7dMKvnda+7eiYwXvh619Xffsp7WvS7FzfxfitPZ13d9TT2tfl2Lnntunta9LsXP3w6e1r0uxc/fDp7WvS7Bb+7oU+z5z7NPavxUdK3eOfYJ9XSfY13V6+7oEO3eOfVr7uhQ7+NwG+7pOsK/rBPu6TrCv6wT7uk5rX5di32eOfVr7t6Jj5c6xT7Cv6wT7uk5vX5dgB8+xrX1dih18boN9XSfY13WCfV0n2Nd1gn1dp7WvS7Fz3zmd1j4txc5953Ra+7QUO+Wd0zt27jun09qnpdi575xOa5+WYLf2aSl263NVsG+077X2b0XH6nxuixmKta9LsYP3w2Cf1unt07qfXXn7tO7ZrX1aoh+29mkpdvB+GOzTOsE+rRPs0zrBPq3T2qcVfO+09m9FxwreD1v7uhQ7eD9s7etS7OD9sLWvS7GDz21rX5diB++HrX1dih28H7b2dSl2cD+8kX/rtPZvRcdqfW7f35fAvq4T7Os6vX1dgh08x7b2dQl2sK/rBPu6TrCv6wT7uk6wr+sE+7pOa1+XYt9ojm3t34qOlTvHLi+wsOuC506yL3juKPuC586yL3jnw1vCc0/vC557fF/w3Hn2Bc8daF/w3Il2eYHVXRc8tze+4LmPni547qunC975hJXw3HdPFzzl4dNbeO7Lpwve+umTgue+fSova8mWhOe+frrgrU9YBb/PHvgK1vlEDg+Wuzm+4Lmr4wueuzu+4LmyrQueuz0uL2/dloIn98jWwi0Jz90gX/DOJ7KEJ0+hwdKtC548hbbWbkXfQq09XdHBWou91N3J2uwl4cl7ZGu3l4R3PsHVrdXa7iXhySe4td9LwpP3yNaGLwVvrfiS8OQe2VryJeF3mnJba7vCgyVPucGirwuePOX2Vn0pePKU21r2JeHJJzhY93XBk6fcYOHXBU+ecoOVXxc8uUfeSOJ1BbvTlBus/brgyVNusPjrgidPucHqrwuePOUGy78uePIJDtZ/XfDkKTdYAHbBk3tkawWYhCe/lrKWdEl48mspa02XhKe8lnoLT34tZW3qUvDWqi71Zsfa1SXhya+lrG1dEt75hI0eUln7vcKDJe+RrY1gEp68RyY7u4q3s+t+qFW8nV0KHtwjF2tnl4R3PsElPHiPXMjOrkJ2dhWys6tYO7uCb6HF2vEVHix4j1ysnWASHrxHLtZOMAkP3iMXayeYhCef4NZOMAkP3iMXayeYhAfvkYu1E0zCk3vknRxfxdrxFR4seMpdyE6wQnaCFW8nmIAnO8GKtRNMwpNPcLITrJCdYIXsBCtkJ1ghO8GKtRNMwu805bZ2fIUHS55yk51ghewEK95OMAVPnnJbO8EkPPkEJzvBCtkJVshOsEJ2ghWyE6xYO8EkvPMJK569FGtnl4QHv5Yq1s4uCU95LfUWHvxaqlg7uyQ8+LVUsXZ2SXjwa6li7eyS8Dvtha0dX+HBkvfI1k4wCU/eI5OdXcXb2SWGWt7OLgVP7pGtnV0SnrxHJju7CtnZVcjOrkJ2dhVrZ1f0LdTa8RUeLHmPbO0Ek/DOJ7iEB/8yRbF2gqlbq7UTTMKTT3BrJ5iCt3aCSXjyHtnaCSbhyT2ytRNMwu805bZ2fIUHS55yk51ghewEq95OMAUPnnJXayeYhAef4PUFPsEr2QlWyU6wSnaCVbITrFo7wRT8To6vau34Cg8WPOWuZCdYJTvBqrcTTMGDp9zV2gkm4cknONkJVslOsEp2glWyE6ySnWDV2gkm4cGvpaq1s0vCg19LVWtnl4SnvJZ6B2/t7BKvpaq1s0vCg19LVWtnl4R3PmElvPUJq+A32gtXa8dXeLDgPXK1doIpeGvHl4QHO7uqt7NLDLW8nV0K3vkEVz2ytbNLwpP3yGRnVyU7uyrZ2VXJzq5q7eyKvoVaO77CgyXvka2dYBKevEe2doJJePIe2doJJuHJJ7i1E0zCk/fI1k4wCU/eI1s7wSQ8uUfeyfFVrR1f4cGSp9xkJ1glO8GqtxNMwZOn3NZOMAlPPsHJTrBKdoJVshOskp1glewEq9ZOMAm/05Tb2vEVHix5yk12glWyE6x6O8EUPHnKbe0Ek/DkE5zsBKtkJ1glO8Eq2QlWyU6wau0Ek/Dk11LWzi4JT34tZe3sEvCHtbNLwoNfSx3Wzi4JD34tdbycT1gJD34tdVg7uyT8Rnvhw9rxFR4seI98WDvBJDx4j3yQnV2Ht7Prfqh1eDu7FDy4Rz6snV0SHrxHPsjOroPs7DrIzq6D7Ow6rJ1d0bdQa8dXeLDWJ7i4O1k7wSQ8eI98WDvBJDx4j3xYO8EUvLUTTB2C1k4wCQ/eIx/WTjAJ73zCSnhyj2ztBJPwO025rR1f4cGSp9xkJ9hBdoId3k4wBU+ecls7wSQ8+QQnO8EOshPsIDvBDrIT7CA7wQ5rJ5iE32nKbe34Cg/W+gQXdyeyE+wgO8EObyeYgidPua2dYAqe7AQ7yE6wg+wEO8hOsIPsBDvITrDD2gkm4cGvpQ5rZ5eEJ7+WsnZ2SXjKa6m38OTXUtbOLgnvfMKqNzvWzi4JT34tZe3skvA77YWtHV/RwVo7wdRoxdoJJuHJe2Sys+vwdnaJoZa3s0vBk3tka2eXhCfvkcnOroPs7DrIzq6D7Ow6rJ1d0bdQa8dXeLDkPbK1E0zCk/fI1k4wCQ/eIzdrJ5iEB5/gzdoJJuHBe+T2cj6RJTx4j9ysnWASHtwjt50cX83a8RUdLNkJ1shOsEZ2gjVvJ5iCdz7B1a3V2gkm4cknONkJ1shOsEZ2gjWyE6yRnWDN2gkm4Teacjdrx1d4sOApdyM7wRrZCda8nWAKnjzltnaCSXjyCU52gjWyE6yRnWCN7ARrZCdYs3aCSXjwa6lm7exS8NbOLgkPfi3VrJ1dEh78WqpZO7skPPi1VLN2dkl48GupZu3skvA77YWtHV/hwZL3yNZOMAlP3iOTnV3N29klhlrezi4FT+6RrZ1dEp68RyY7uxrZ2dXIzq5GdnY1a2dX9C3U2vEVHix5j2ztBJPw5D2ytRNMwVs7wdSt1doJJuHJJ7i1E0zCO5/gEp68R7Z2gkl4co9s7QST8DtNua0dX+HBkqfcZCdYIzvBmrcTTMGTp9zWTjAJTz7ByU6wRnaCNbITrJGdYI3sBGvWTjAJ73zCRt9CrR1f4cGSp9xkJ1gjO8GatxPsHr6TnWDd2gkm4cEneCc7wfrL+QSX8OApdyc7wTrZCdatnWASHvxaqls7uyQ8+LVUt3Z2SXjKa6m38M4nrHgt1a2dXRIe/FqqWzu7JDz4tVS3dnYpeGtnV/CQqls7vsKDBe+Ru7UTTMI7n+ASHuzs6t7OLjHU8nZ2KXhyj2zt7FLw1s4uCQ/eI3eys6uTnV2d7Ozq1s6u6FuoteMrPFjwHrlbO8EkPHmPbO0Ek/DkPbK1E0zCk09wayeYhCfvka2dYBKevEe2doJJeHKPvJPjq1s7vsKDJU+5yU6wTnaCdW8nmIInT7mtnWASnnyCk51gnewE62QnWCc7wTrZCdatnWASfqcpt7XjKzxY8pSb7ATrZCdY93aCKXjylNvaCSbhySc42QnWyU6wTnaCdbITrJOdYN3aCabgrR1f6tmLtbNLwpNfS1k7uyS88wkr4cmvpaydXRKe/FrK2tkl4cmvpaydXRJ+p72wteMrPFjyHtnaCSbhyXtksrOrezu7xFDL29ml4ME98rB2dkl48B55kJ1dg+zsGi/nE1bCg6fQw9rZFXwLHdaOr/BgwXvkYe0EU/DWTjAJD/5limHtBBO31mHtBJPw5BPc2gkm4cF75GHtBJPw4D3ysHaCKXhrJ5iE32jKPawdX+HBgqfcg+wEG2Qn2PB2gil48JR7WDvBJDz5BCc7wQbZCTbITrBBdoINshNsWDvBJPxOU25rx1d4sOQpN9kJNshOsOHtBFPw5Cm3tRNMwpNPcLITbJCdYIPsBBtkJ9ggO8GGtRNMwoNfSw1rZ5eEB7+WGtbOLvFmZ1g7uyQ8+YT9WWdXfX394Vr+XRf7bzjLC+e0wvlZU5bG+dGTqpbjd5xZ3uBUL5zDC6d54XQvnOGFM71wlhfOaYXzs/YjjfOz/UM7z69Bc2tvcKoXzuGF07xwuhfO8MKZXjjLC+e0wvlhY47E8fpUXl6fysvrU3l5fSovr0/l5fWpvLw+lZfXp/IPO1n6aF84680G9octKxKneOFULxzneXj092GsXSXhwZK/9U12mwxvt4mCJ39nzNptIr4/M63dJhJ+o3db09qFEh4s+N3WfDUyPPgEn9buFAkPfrc1vd0mCh78nbRp7TaR8OB3W9PabSLhwe+2prXbJPouZO1CCQ+WfIJbu1MkPLgHn9buFAVv7U5Rdydrd4qEJ5/g1m4TCe98gkt48Lutae02kfDgd1vT2m0i4a1/g+P+JcW0dptIeMq7rbfwlHdbb+E32lNPaxdKeLDkKbe1O0XCk3tksttkertNRKfm7TZR8OQpt7XbRMKTe2Sy22SS3SaT7DaZZLfJtHabRN9CrV0o0cFau1PU3cnanSLhre1kCp78TTBrd4q6tVq7UyQ8+QTv5BO8k6fcnfxNsEH+Jtgg98iD3COPnabcP2ur+XSw5Cn3IE+5B3nKPchT7kGeck/ylHuST/BJPsEnecr9w6aiYHjylHuSe+RJ7pHnTlPuudOUe5Gn3Is85V7kKfciT7l/2GoVe2td5Cn3Ip/gi3yCL/KUe5Gn3Cd5yn2Se+ST3CNbO8fEb3BMa4eYhKf8BsdbeOcTVsI7n7AS3vmElfCU11Jv4Je1E0zCg3/lalk7viQ8+IRdL/AJu6ydXRIefMIua2eXhAefsMva2aXgrZ1dEh78HnlZO7sk/Ebf1Fo7Ob6WteNLzP8X2dm1yM6uRXZ2LW9n1/3mZZGdXcva2SUGuYvs7FpkZ9ciO7sW2dm1yM6uRXZ2LWtnV/Qt1NrxFR2stRNM3Z2snWASHvxNrWXtBJPwzie4urV6O7sUPPkEt3Z2SXjwN7WWtbNLwVs7uyQ8uUcmO7uWtbMr+hZq7fgKD5Y85bZ2gkl48pTb2gkm4clTbm9nl4Inn+DWzi4JT55yWzu7JDx5yk12di2ys2tZO7uib6HWjq/oYK2dYOruZO0Ek/DkKbe1E0zCO5/g6tbq7exS8OQT3NrZJeHJU25rZ5eCt3Z2SXhyj0x2di1rZ5d6AmDt7JLw5NdS1s4uCU95LfXu8YW1s0vCW7+WWl/3+brefFRaO7UkvPVrKQVv/VpKwe+0R7Z2cIUHS94jWzu7JDx5j2zt7JLw5D2ytbNLwpN7ZLKza1k7uyS884ks4cl7ZGtnl4QnT6GtnV3Rt1Brx1dwsKe1E0zcnU5rJ5iEB++RT2snmIR3PsHFrfW0doJJePAJflo7wSQ8eI98WjvBFLy1E0zCg3vk09oJJuE3mnKfOznBTrIT7CQ7wU6yE+wkO8FOshPsJDvBTrIT7CQ7wU6yE+wkO8FOshPsJDvBTrIT7NzJCXbu5AQ7yU6wk+wEO8lOsJPsBDvJTrCT7AQ7yU6wk+wEO8lOsJPsBDvJTrCT7AQ7yU6w09oJJp69nNaOLwkPfi11Wju7JDz4t6VOa2eXeC11Wju7FLy1s0u82TmtnV0SHvxa6rR2dkl45xM2ekhl7fgKD5a8R7Z2gkl48h7Z2vGl4L2dXWKo5e3sUvDkHtna2SXhnU9wCU/eI5OdXSfZ2XWSnV2ntbMr+hZq7fgKD5a8R7Z2gkl48h7Z2gkm4cl7ZGsnmIQnn+DWTjAJT94jWzvBJDx5j2ztBJPw5B55J8fXae34Cg+WPOUmO8FOshPs9HaCCXiyE+y0doJJePIJTnaCnWQn2El2gp1kJ9hJdoKd1k4wCb/PlLu+rB1f4cFyp9wXPHfKfcFzp9wXvPMJLuG5U+4LnjvlvuC5J/gFzz3BL3julLu+wE6wC5475b7guT3yBc/tkS945xP2/tnLBc99LXXBc19LXfDc11IXPOW11Ft47mup+rJ2dkl47mupC577WuqC576WuuCtT1gFv89e+ArW+UQOD5a7R77guXvkC567R64vsLPrgufukS946ym0gif3yNbOLgnP3SNf8Nw98gVPnkKDnV0XPHkKbe3sir6FWju+woMl75GtnWAS3vkEl/DcX6a44Ml7ZGsnmIQnn+DWTjAFb+0Ek/DkPbK1E0zCk3tkayeYhN9pym3t+AoPljzlBjvBLnjylNvbCabgyVNuayeYhCef4GAn2AVPnnKDnWAXPHnKDXaCXfDkHnkjx9cV7E5TbrAT7IInT7nBTrALnjzlBjvBLnjylBvsBLvgySc42Al2wZOn3GAn2AVP7pGtnWASnvxaytrZJeHJr6WsnV0SnvJa6h28tbNLvZaydnZJePJrKWtnl4R3PmElvPUJq+B32gtbO77CgyXvka2dYAK+WDu+JDzY2VW8nV33Q63i7exS8M4nuOiRi7WzS8KD98iF7OwqZGdXITu7CtnZVaydXcG30GLt+AoPFrxHLtZOMAkP3iMXayeYhAfvkYu1E0zCk09wayeYhAfvkYu1E0zCg/fIxdoJJuHJPfJOjq9i7fgKDxY85S5kJ1ghO8GKtxNMwZOn3NZOMAlPPsHJTrBCdoIVshOskJ1ghewEK9ZOMAm/05Tb2vEVHix5yk12ghWyE6x4O8EUPHnKbe0Ek/DkE5zsBCtkJ1ghO8EK2QlWyE6wYu0Ek/Dg11LF2tkl4cGvpYq1s0vBWzu7JDz4tVSxdnZJePBrqWLt7JLw4NdSxdrZJeF32gtbO77CgyXvka2dYBKevEcmO7uKt7NLDLW8nV0KntwjWzu7JDx5j0x2dhWys6uQnV2F7Owq1s6u6FuoteMrPFjrE1zcnaydYBKevEe2doJJePIe2doJpuCtnWDqELR2gkl48h7Z2gkm4Z1PWAlP7pGtnWASfqcpt7XjKzxY8JS7kp1glewEq95OMAUPnnLXl/MJLuHBJ3glO8Eq2QlWyU6wSnaCVbITrFo7wST8RlPuau34Cg/W+gQXdyeyE6ySnWDV2wmm4MFT7mrtBFPwZCdYJTvBKtkJVslOsEp2glWyE6xaO8EkPPi1VLV2dkl48Gupau3skvCU11Jv4cGvpaq1s0vCO5+w4s1OtXZ2SXjwa6lq7eyS8Bvthau14ys6WGsnmBqtWDvBJDx5j0x2dlVvZ5cYank7uxQ8uUe2dnZJePIemezsqmRnVyU7uyrZ2VWtnV3Rt1Brx1d4sOQ9srUTTMKT98jWTjAJT94jWzvBJDz5BLd2gkl48h7Z2gkm4cl7ZGsnmIQn98g7Ob6qteMrOliyE6ySnWCV7ASr3k4wBe98gqtbq7UTTMKTT3CyE6ySnWCV7ASrZCdYJTvBqrUTTMLvNOW2dnyFB0uecpOdYJXsBKveTjAFT55yWzvBJDz5BCc7wSrZCVbJTrBKdoJVshOsWjvBJDz5tZS1s0vAH9bOLgkPfi11WDu7JDz4tdTxcj5hJTz4tdRh7eyS8ODXUoe1s0vCb7QXPqwdX+HBgvfIh7UTTMKD98gH2dl1eDu77odah7ezS8GDe+TD2tkl4cF75IPs7DrIzq6D7Ow6yM6uw9rZFX0LtXZ8hQcL3iMf1k4wCQ/eIx/WTjAFb+0EU7dWayeYhCef4NZOMAnvfIJLePAe+bB2gkl4co9s7QST8DtNua0dX+HBkqfcZCfYQXaCHd5OMAVPnnJbO8EkPPkEJzvBDrIT7CA7wQ6yE+wgO8EOayeYhHc+YaNvodaOr/BgyVNushPsIDvBDm8nmIAnO8EOayeYhCef4GQn2EF2gh1kJ9hBdoIdZCfYYe0Ek/Dk11LWzi4JT34tZe3skvCU11Jv4Z1PWPVaytrZJeHJr6WsnV0SnvxaytrZpeCtnV3RQyprx1d4sOQ9srUTTMI7n+ASHuzsOrydXWKo5e3sUvDkHtna2aXgrZ1dEp68RyY7uw6ys+sgO7sOa2dX9C3U2vEVHix5j2ztBJPw4D1ys3aCSXjwHrlZO8EkPPgEby/wCd6snWASHrxHbtZOMAkP7pGbtRNMwe/k+GrWjq/wYMFT7kZ2gjWyE6x5O8EUPHjK3aydYBKefIKTnWCN7ARrZCdYIzvBGtkJ1qydYBJ+oyl3s3Z8hQcLnnI3shOskZ1gzdsJpuDJU25rJ5iEJ5/gZCdYIzvBGtkJ1shOsEZ2gjVrJ5iCt3Z8iWcvzdrZJeHBr6WatbNLwjufsBIe/FqqWTu7JDz4tVSzdnZJePBrqWbt7JLwO+2FrR1f4cGS98jWTjAJT94jk51dzdvZJYZa3s4uBU/uka2dXRKevEcmO7sa2dnVyM6uRnZ2NWtnV/Qt1NrxFR4seY9s7QRT8NZOMAkP/mWKZu0EU7dWayeYhCef4NZOMAlP3iNbO8EkPHmPbO0EU/DWTjAJv9OU29rxFR4secpNdoI1shOseTvBFDx5ym3tBJPw5BOc7ARrZCdYIzvBGtkJ1shOsGbtBJPwO025rR1f4cGSp9xkJ1gnO8G6txNMwYOn3N3aCSbhwSd4JzvBOtkJ1slOsE52gnWyE6xbO8EkPPi1VLd2dkl48Gupbu3skvCU11Jv4cGvpbq1s0vCg19LdWtnl4K3dnZJeOsTVsFvtBfu1o6v8GCdT3A1WrF2gkl48B65k51d3dvZJYZa3s4uAW/t7FI9srWzS8KD98id7OzqZGdXJzu7OtnZ1a2dXdG3UGvHV3iw5D2ytRNMwpP3yNZOMAlP3iNbO8EkPPkEt3aCSXjyHtnaCSbhyXtkayeYhCf3yDs5vrq14ys8WOsTXNydyE6wTnaCdW8nmIInT7mtnWAKnuwE62QnWCc7wTrZCdbJTrBOdoJ1ayeYhN9pym3t+AoPljzlJjvBOtkJ1r2dYAqePOW2doJJePIJTnaCdbITrJOdYJ3sBOtkJ1i3doJJePJrKWtnl4R3PmElPPm1lLWzS8KTX0tZO7skPPm1lLWzS8KTX0tZO7sk/E57YWvHV3iw5D2ytRNMwpP3yGRnV/d2dt0PtYa3s0vBg3vkYe3skvDgPfJ4OZ/IEh48hR5kZ9cgO7uGtbMr+BY6rB1f0cFaO8HE3WlYO8EkPHiPPKydYBLe+QRXt1ZrJ5iEJ5/g1k4wCQ/eIw9rJ5iCt3aCSXhyj2ztBJPwG025h7XjKzxY8JR7kJ1gg+wEG95OMAVPnnJbO8EkPPkEJzvBBtkJNshOsEF2gg2yE2xYO8Ek/E5TbmvHV3SwZCfYIDvBBtkJNrydYAre+QRXt1ZrJ5iEJ5/gZCfYIDvBBtkJNshOsEF2gg1rJ5iEB7+WGtbOLgkPfi01rJ1dEp7yWuotPPi11LB2dil4a2eXeLMzrJ1dEh78WmpYO7skvPMJGz2ksnZ8hQdL3iNbO8EkPHmPTHZ2DW9nlxhqeTu7FDy5R7Z2dkl45xNcwpP3yGRn1yA7uwbZ2TWsnV3Rt1Brx1d4sOQ9srUTTMKT98jWTjAJT94jWzvBJDz5BLd2gkl48h7Z2gkm4cl7ZGsnmIQn98g7Ob6GteMrPFjylJvsBBtkJ9jwdoLdw0+yE2xaO8EkPPgEn2Qn2Hw5n+ASHjzlnmQn2CQ7waa1E0zCbzTlntaOr/BgwVPuSXaCTbITbHo7wRQ8eMo9rZ1gEp58gpOdYJPsBJtkJ9gkO8Em2Qk2rZ1gEt75hBXPXqa1s0vCg19LTWtnl4SnvJZ6Cw9+LTWtnV0SHvxaalo7uyQ8+LXUtHZ2SfiN9sLT2vEVHix4jzytnWASnrxHJju7prezSwy1vJ1dCp7cI1s7uyQ8eY9MdnZNsrNrkp1dk+zsmtbOruhbqLXjKzxY8h7Z2gkm4Z1PcAkP/mWKae0EU7dWayeYhCef4NZOMAVv7QST8OQ9srUTTMKTe2RrJ5iE32nKbe34Cg+WPOUmO8Em2Qk2vZ1gCp485bZ2gkl48glOdoJNshNskp1gk+wEm2Qn2LR2gin4nRxf09rxFR4secpNdoJNshNsejvBFDx5ym3tBJPw5BOc7ASbZCfYJDvBJtkJNslOsGntBJPw5NdS1s4uCU9+LWXt7FJvdqydXQJ+WTu7xKfNsnZ2SfgfPWHr6+sP1/LvWvB/wzm8cJoXTvfCGV440wvnR0+TWo7fcWZ5g3Na4fysE0rjFC+c6oVzeOE0L5zuhTO8cKYXjtencvH6VP5hL1A7f/vDpbf2Bqd44VQvnMMLp3nhdC+c4YUzvXCWF85phXN4fSofXp/Kh9en8uH1qXx4fSofXp/Kh9en8uH1qfzD7pE+2hfOWm9wTiucH/aDSJziheO8uQ3+Itiydn6EB9uMgxVfX1rWjhAJD/41p2XtCJHw1u+T7r84tqwdIQp+J0fI2skRssiOkEV2hCyyI2SRHSGL7AhZZEfIIjtCFtkRssiOkEV2hCyyI2RZO0Ki70LWTpHwYMknuLVTRMKTe3CyI2R5O0LE3cnbEaLgySe4tSNEwoPfPy2yI2SRHSGL7AhZZEfIsnaEqCdE1o4QBW/tCJHw1r8WpeB32lNbOz/Cg3U+wVW/QHaELG9HiIIn98jWjhDVqVk7QhQ82RGyyI6QRXaELLIjZJEdIcvaESLhyT2ytSMk+hZq7RQJDxZswj6tHSQS3tqEreDB3wQ7X9bfBLu/tZ4v5xNcwoNP8PMFPsHPF3jKfb7A3wQ7X+Bvgp0F3COfBdwjn2WjKfdZNppynz/rwgm+OxXwlPss4Cn3WcBT7rOAp9xnAU+5z0o+wSv5BK/gKfdZwVPu84e9RsHw5B65knvkutGU+6wbTbnPSp5yH+Qp90Gech/kKfdBnnL/sAMrGJ58gh/kE/wgT7kP8pT7IE+5G7lHbuQe2do5Jn585rR2iEl45xNWwoN/Leq0doJJePCvRZ3WTjAJT3kt9Q7e2gkm4Smvpd7Ck09Ya2eXhCefsNbOLglPPmGtnV0SnnzCWju7FLy1s0s86T2tnV0Sfqdvau3k+DqtHV9q/k92dp1kZ9dJdnad3s4usXkhO7tOa2eXGuSSnV0n2dl1kp1dJ9nZdZKdXSfZ2XVaO7uib6HWjq/wYMnf1LJ2gkl48je1rJ1gEp78TS1vZ5eCJ5/g1s4uCU/+ppa1s0vCk7+pRXZ2nWRn12nt7Iq+hVo7vsKDtT7Bxd3J2gkm4clTbmsnmIQnT7m9nV238MfL2tl1fwhe8NwT/ILnTrkveO6U+4J3PmElPLdHvuC5PfIFv8+U+wp2nyn3FSx3yn28rJ1gEp475b7guVPuC5475b7gnU9wCU8+wa2dXRKeO+W+4LlT7gueO+U+XmBn1wVP7pGtnV33TwAueO5rqQve+YSV8NzXUhc85bXUPz6+uOApr6Xewlu/llpf9/m63n1UWr+WEvDWTi0Jb/1aSsHvs0e+gt1nj3wF63yCq+mEtbNLwnP3yBc8d498wXP3yBc8eY8MdnZd8OQe2drZJeHJe2RrZ5eEJ0+hrZ1dEn6nPbK14ys8WPIe2doJJuHJe2RrJ5iEJ++RrZ1gEp58gls7wSQ8eY9s7QST8OQ9srUTTMKTe+SNnGBXsDtNucFOsAuePOUGO8EuePKUG+wEu+DJU26wE+yCJ5/gYCfYBU+ecoOdYBc8uUcGO8Eu+J2m3Bs5wa5gyVNusBPsgidPucFOsAuePOUGO8EuePIJDnaCXfDkKTfYCXbBk6fcYCfYBU/uka2dYOrZi7XjS8I7n7ASnvxaytrZJeHJr6WsnV0SHvxaqlg7uyQ8+LVUsXZ2SfiN9sLl5XwihwcL3iMXayeYhAfvkYu140vCg/fIxdvZpeDBPXKxdnZJePAeuVg7uyQ8eApdyM6uQnZ2FWtnV/Qt1NrxFR2stRNM3Z2snWASHrxHLtZOMAnvfIKrW6u1E0zCk09wayeYhAfvkYu1E0zBWzvBJDy5R7Z2gkn4nabc1o6v8GDJU26yE6yQnWDF2wmm4MlTbmsnmIQnn+BkJ1ghO8EK2QlWyE6wQnaCFWsnmITfacpt7fiKDpbsBCtkJ1ghO8GKtxNMwTuf4OrWau0Ek/DkE5zsBCtkJ1ghO8EK2QlWyE6wYu0Ek/Dg11LF2tkl4cGvpYq1s0vCU15LvYUHv5Yq1s4uBW/t7FJvdqydXRKe/FrK2tkl4Z1P2OghlbXjKzxY8h7Z2gkm4cl7ZLKzq3g7u8RQy9vZpeDJPbK1s0vCO5/gEp68RyY7uwrZ2VXIzq5i7eyKvoVaO77CgyXvka2dYBKevEe2doJJePIe2doJJuHJJ7i1E0zCg/fI1doJJuHBe+Rq7QST8OAeub6cT9jgW2i1dnyFBwuecleyE6ySnWDV2wkm4MlOsGrtBJPw5BOc7ASrZCdYJTvBKtkJVslOsGrtBJPwG025q7XjKzxY8JS7kp1glewEq95OMAUPnnJXayeYhCef4GQnWCU7wSrZCVbJTrBKdoJVayeYhHc+YcWzl2rt7JLw4NdS1drZJeEpr6XewoNfS1VrZ5eEB7+WqtbOLgkPfi1VrZ1dEn6nvbC14ys8WPIe2doJJuHJe2Sys6t6O7vEUMvb2aXgyT2ytbNLwpP3yGRnVyU7uyrZ2VXJzq5q7eyKvoVaO77CgyXvka2dYBLe+QSX8OBfpqjWTjB1a7V2gkl48glu7QRT8NZOMAlP3iNbO8EkPLlHtnaCSfidptzWjq/wYMlTbrITrJKdYNXbCabgyVNuayeYhCef4GQnWCU7wSrZCVbJTrBKdoJVayeYgt/J8VWtHV/hwZKn3GQnWCU7waq3E0zBk6fc1k4wCU8+wclOsIPsBDvITrCD7AQ7yE6w4+V8wkp48Gupw9rZJeHBr6UOa2eXhKe8lnoHb+3sEq+lDmtnl4QHv5Y6rJ1dEt75hJXw1iesgt9oL3xYO77CgwXvkQ9rJ5iCt3Z8SXiws+vwdnbdD7UOb2eXgnc+wVWPbO3skvDgPfJBdnYdZGfXQXZ2HWRn12Ht7Iq+hVo7vsKDBe+RD2snmIQH75EPayeYhAfvkQ9rJ5iEJ5/g1k4wCU/eI1s7wSQ8eY9s7QST8OQeeSfH12Ht+AoPljzlJjvBDrIT7PB2gil48pTb2gkm4cknONkJdpCdYAfZCXaQnWAH2Ql2WDvBJPxOU25rx1d4sOQpN9kJdpCdYIe3E0zBk6fc1k4wCU8+wclOsIPsBDvITrCD7AQ7yE6ww9oJJuHJr6WsnV0SnvxaytrZpeCtnV0SnvxaytrZJeHJr6WsnV0SnvxaytrZJeF32gtbO77CgyXvka2dYBKevEcmO7sOb2eXGGp5O7sUPLlHtnZ2SXjyHpns7DrIzq5GdnY1srOrWTu7gm+hzdrxFR6s9Ql+f3dq1k4wCQ/eIzdrJ5iEB++Rm7UTTMFbO8HUIWjtBJPw4D1ys3aCSXjnE1bCg3vkZu0Ek/AbTbmbteMrPFjwlLuRnWCN7ARr3k4wBQ+ecjdrJ5iEJ5/gZCdYIzvBGtkJ1shOsEZ2gjVrJ5iE32nKbe34Cg/W+gQXdyeyE6yRnWDN2wmm4MlTbmsnmIInO8Ea2QnWyE6wRnaCNbITrJGdYM3aCSbhwa+lmrWzS8KDX0s1a2eXhKe8lnoLD34t1aydXRLe+YQVb3aatbNLwoNfSzVrZ5eE32kvbO34ig7W2gmmRivWTjAJT94jk51dzdvZJYZa3s4uBU/uka2dXRKevEcmO7sa2dnVyM6uRnZ2NWtnV/Qt1NrxFR4seY9s7QST8OQ9srUTTMKT98jWTjAJTz7BrZ1gEp68R7Z2gkl48h7Z2gkm4ck98k6Or2bt+IoOluwEa2QnWCM7wZq3E0zBO5/g6tZq7QST8OQTnOwEa2QnWCM7wTrZCdbJTrBu7QST8BtNufvL+UQODxY85e5kJ1gnO8G6txNMwYOn3N3aCSbhySc42QnWyU6wTnaCdbITrJOdYN3aCSbhwa+lurWzS8FbO7skPPi1VLd2dkl48Gupbu3skvDg11Ld2tkl4cGvpbq1s0vCb7QX7taOr/BgwXvkbu0Ek/DgPXInO7u6t7NLDLW8nV0KntwjWzu7JDx5j0x2dnWys6uTnV2d7Ozq1s6u6FuoteMrPFjyHtnaCSbhyXtkayeYgrd2gqlbq7UTTMKTT3BrJ5iEdz7BJTx5j2ztBJPw5B7Z2gkm4Xeacls7vsKDJU+5yU6wTnaCdW8nmIInT7mtnWASnnyCk51gnewE62QnWCc7wTrZCdatnWAS3vmEjb6FWju+woMlT7nJTrBOdoJ1byeYgCc7wbq1E0zCk09wshOsk51gnewE62QnWCc7wbq1E0zCk19LWTu7JDz5tZS1s0vCU15LvYV3PmHVaylrZ5eEJ7+WsnZ2SXjyaylrZ5eAH9bOruAh1bB2fIUHC94jD2snmIR3PsElPNjZNbydXfdDreHt7FLw4B55WDu7FLy1s0vCg/fIg+zsGmRn1yA7u4a1syv6Fmrt+AoPFrxHHtZOMAkP3iMPayeYhAfvkYe1E0zCk09wayeYhAfvkYe1E0zCg/fIw9oJJuHJPfJOjq9h7fgKD5Y85SY7wQbZCTa8nWAKnjzltnaCSXjyCU52gg2yE2yQnWCD7AQbZCfYsHaCSfidptzWjq/wYMlTbrITbJCdYMPbCabgyVNuayeYhCef4GQn2CA7wQbZCTbITrBBdoINayeYgrd2fIlnL8Pa2SXhwa+lhrWzS8I7n7ASHvxaalg7uyQ8+LXUsHZ2SXjyaylrZ5eE32kvbO34Cg+WvEe2doJJePIemezsGt7OLjHU8nZ2KXhyj2zt7JLw5D0y2dk1yM6uQXZ2DbKza1g7u6JvodaOr/BgyXtkayeYgrd2gkl48C9TDGsnmLq1WjvBJDz5BLd2gkl48h7Z2gkm4cl7ZGsnmICf1k4wCb/RlHtaO77CgwVPuefL+QSX8OAp9/R2gil48JR7WjvBJDz5BCc7wSbZCTbJTrBJdoJNshNsWjvBJPxGU+5p7fgKDxY85Z5kJ9gkO8GmtxNMwYOn3NPaCSbhySc42Qk2yU6wSXaCTbITbJKdYNPaCSbhwa+lprWzS8KDX0tNa2eXhKe8lnoLD34tNa2dXRIe/FpqWju7FLy1s0vCW5+wCn6nvbC14ys8WOcTXI1WrJ1gEp68RyY7u6a3s0sMtbydXQLe2tmlemRrZ5eEJ++Ryc6uSXZ2TbKza5KdXdPa2RV9C7V2fIUHS94jWzvBJDx5j2ztBJPw5D2ytRNMwpNPcGsnmIQn75GtnWASnrxHtnaCSXhyj7yT42taO77Cg7U+wcXdiewEm2Qn2PR2gil48pTb2gmm4MlOsEl2gk2yE2ySnWCT7ASbZCfYtHaCSfidptzWjq/wYMlTbrITbJKdYNPbCabgyVNuayeYhCef4GQn2CQ7wSbZCTbJTrBFdoItayeYhAe/llrWzi4J73zCSnjwa6ll7eyS8ODXUsva2SXhwa+llrWzS8KDX0sta2eXhN9oL7ysHV/hwYL3yMvaCSbhwXvkRXZ2LW9n1/1Qa3k7uxQ8uUe2dnZJePAeeZGdXYvs7FpkZ9ciO7uWtbMr+hZq7fiKDtbaCabuTtZOMAkP3iMvayeYhHc+wdWt1doJJuHJJ7i1E0zCg/fIy9oJpuCtnWASntwjWzvBJPxOU25rx1d4sOQpN9kJtshOsOXtBFPw5Cm3tRNMwpNPcLITbJGdYIvsBFtkJ9giO8GWtRNMwu805bZ2fEUHS3aCLbITbJGdYMvbCabgnU9wdWu1doJJePIJTnaCLbITbJGdYIvsBFtkJ9iydoJJePJrKWtnl4Qnv5aydnZJeMprqbfw5NdS1s4uBW/t7FJvdqydXRKe/FrK2tkl4Z1P2OghlbXjKzxY8h7Z2gkm4cl7ZLKza3k7u8RQy9vZpeDJPbK1s0vCO5/gEp68RyY7uxbZ2bXIzq5l7ewKvoWe1o6v8GDBe+TT2gkm4cF75PPlfIJLePAe+bR2gkl48Al+WjvBJDx4j3xaO8EkPHiPfFo7wSQ8uEc+d3J8ndaOr/BgwVPuk+wEO8lOsNPbCSbgyU6w09oJJuHJJzjZCXaSnWAn2Ql2kp1gJ9kJdlo7wST8TlNua8dXeLDkKTfZCXaSnWCntxNMwZOn3NZOMAlPPsHJTrCT7AQ7yU6wk+wEO8lOsNPaCSbhnU9Y8ezltHZ2SXjwa6nT2tkl3uyc1s4uCU8+Ya2dXRL+R0/Y+vr6w7X8uxb833CqF87hhdO8cLoXzvDC+dHTpJbjd5xZ3uAsL5zTCudnrU0ap3jhVC+cwwuneeF0L5zhheP1qfzDFqF2/vaHS2/tDc5phfPDph+JU7xwqhfO4YXTvHC6F87wwpleOF6fytPrU3l5fSovr0/l5fWpvLw+lZfXp/Ly+lT+YVNJH+0LZ73Z9f+we0TiLC+c0wrH2vgR/c0ra0NIeLDkb2pZG0UkfCPDg3/76bQ2iqhvalkbRST8Rr9McW5kIGkvawPJ/QfCBc/9rvUFzz3BL3juCX7BW5/gtx/FFzz3u9YXPPe11AXP/a71Bc/9rvUFz/0mWHuBjSIX/D499RWs84kcHiz5BLc2lkh4bg9+wXONIhc8twe/4K2NIgqefIJbG0UkPPe11AXPfS11wXNfS13wzieshOcaRS54ymupf3yzc8FzX0td8NzXUhc897el2msjQ8gV7E49NdgocsGTe2SwUeSCJ/fIYKPIBU/ukcFGkQue3CODjSIXPLlHBhtFLnhyj2xtFJHw+3iwr2CdT+TwYLne7Aue682+4Lne7PayNpZIeK43+4K37pEVPPkE/1l3SjQ8ecrdyd8E6+RvgnVyj9zJPfLYaco9dppyD/KUe5Cn3D/r2YmGJ0+5B3nKPchT7kE+wQf5BJ/kKfckT7kneco9yT3yDzuTguF3mnLPnabckzzlnuQp9yRPuRd5yr3IU+5FnnIv8gn+w36tYHjylHuRp9yLPOVe5B55kXtka+fY/a+9XPDOJ6yEdz5hJbzzCSvhnU9YCc/9bakLnvvbUhc85bXUW3jKa6m38JTXUm/gi7WzS8KDT9hi7eyS8OATtrzAJ2yxdnZJePAJW6ydXRIe/B65WDu7FLy1syt4k1J2cnwVa8eXmP8XsrOrkJ1dhezsKt7OrvvNSyE7u4q1s0sMcgvZ2VXIzq5CdnYVsrOrkJ1dhezsKtbOruhbqLXjKzxY8De1irUTTMKDv6lVrJ1gEh78Ta3i7exS8OQT3NrZJeHB39Qq1s4uCQ/+plYhO7sK2dlVrJ1d0bdQa8dXeLDkKbe1E0zCO5/gEp485bZ2fKlbq7ezS8GTT3BrZ5eCt3Z2SXjylNva2SXhyT0y2dlVrJ1d0bdQa8dXeLDkKbe1E0zCk6fc1k4wCU+ecns7uxQ8+QS3dnZJePKU29rZJeHJU26ys6uQnV3F2tmlngBYO7skPPm1lLWzS8I7n7Dq8YW1s0vCW7+WWl/3+brefVRav5ZS8NavpRS89WspAW/t1Iqe81g7uMKDJe+RrZ1dEt75BJfw5D2ytbNLzYWsnV0Sntwjk51dxdrZJeHJe2RrZ5eEJ0+hrZ1dEn6nPbK14ys8WPIe2doJJuHBe+Rq7QST8OA9crV2gkl48AleX+ATvFo7wSQ8eI9crZ1gEh7cI1drJ5iC38kJVndyglWyE6ySnWCV7ASrZCdYJTvBKtkJVslOsEp2glWyE6ySnWCV7ASrZCdYJTvB6k5OsLqTE6ySnWCV7ASrZCdYJTvBKtkJVslOsEp2glWyE6ySnWCV7ASrZCdYJTvBKtkJVq2dYOLZS7V2fEl48Gupau3skvDOJ6yEB7+WqtbOLgkPfi1VrZ1dEh78WqpaO7sk/E57YWvHV3iw5D2ytRNMwpP3yNaOLwlP3iN7O7sUPLlHtnZ2SXjyHtna2SXhyVNosrOrkp1d1drZFX0LtXZ8hQdL3iNbO8EUvLUTTMJb75EVPHmPbO0Ek/DkE9zaCSbhyXtkayeYhCfvka2dYAre2gkm4Xeacls7vsKDJU+5yU6wSnaCVW8nmIInT7mtnWASnnyCk51glewEq2QnWCU7wSrZCVatnWASfqcpt7XjKzxY8pSb7AQ7yE6ww9sJpuDBU+7D2gkm4cEn+EF2gh1kJ9hBdoIdZCfYQXaCHdZOMAkPfi11WDu7JDz4tdRh7eyS8JTXUm/hwa+lDmtnl4QHv5Y6rJ1dCt7a2SXhrU9YBb/RXviwdnyFB+t8gqvRirUTTMKD98gH2dl1eDu7xFDL29kl4K2dXapHtnZ2SXjwHvkgO7sOsrPrIDu7DrKz67B2dkXfQq0dX+HBkvfI1k4wCU/eI1s7wSQ8eY9s7QST8OQT3NoJJuHJe2RrJ5iEJ++RrZ1gEp7cI+/k+DqsHV/hwVqf4OLuRHaCHWQn2OHtBFPw5Cm3tRNMwZOdYAfZCXaQnWAH2Ql2kJ1gB9kJdlg7wST8TlNua8dXeLDkKTfZCXaQnWCHtxNMwZOn3NZOMAlPPsHJTrCD7AQ7yE6wg+wEO8hOsMPaCSbhya+lrJ1dEt75hJXw5NdS1s4uCU9+LWXt7JLw5NdS1s4uCU9+LWXt7JLwO+2FrR1f4cGS98jWTjAJT94jk51dh7ez636o1bydXQoe3CM3a2eXhAfvkdvL+USW8OApdCM7uxrZ2dWsnV3Bt9Bm7fiKDtbaCSbuTs3aCSbhwXvkZu0Ek/DOJ7i6tVo7wSQ8+QS3doJJePAeuVk7wRS8tRNMwpN7ZGsnmITfaMrdrB1f4cGCp9yN7ARrZCdY83aCKXjylNvaCSbhySc42QnWyE6wRnaCNbITrJGdYM3aCSbhd5pyWzu+ooMlO8Ea2QnWyE6w5u0EU/DOJ7i6tVo7wSQ8+QQnO8Ea2QnWyE6wRnaCNbITrFk7wSQ8+LVUs3Z2SXjwa6lm7eyS8JTXUm/hwa+lmrWzS8FbO7vEm51m7eyS8ODXUs3a2SXhnU/Y6CGVteMrPFjyHtnaCSbhyXtksrOreTu7xFDL29ml4Mk9srWzS8I7n+ASnrxHJju7GtnZ1cjOrmbt7Iq+hVo7vsKDJe+RrZ1gEp68R7Z2gkl48h7Z2gkm4cknuLUTTMKT98jWTjAJT94jWzvBJDy5R97J8dWsHV/hwZKn3GQnWCM7wZq3E+wevpOdYN3aCSbhwSd4JzvB+sv5BJfw4Cl3JzvBOtkJ1q2dYBJ+oyl3t3Z8hQcLnnJ3shOsk51g3dsJpuDBU+5u7QST8OQTnOwE62QnWCc7wTrZCdbJTrBu7QST8M4nrHj20q2dXRIe/FqqWzu7JDzltdRbePBrqW7t7JLw4NdS3drZJeHBr6W6tbNLwm+0F+7Wjq/wYMF75G7tBJPw5D0y2dnVvZ1dYqjl7exS8OQe2drZJeHJe2Sys6uTnV2d7OzqZGdXt3Z2Rd9CrR1f4cGS98jWTjAJ73yCS3jwL1N0ayeYurVaO8EkPPkEt3aCKXhrJ5iEJ++RrZ1gEp7cI1s7wST8TlNua8dXeLDkKTfZCdbJTrDu7QRT8OQpt7UTTMKTT3CyE6yTnWCd7ATrZCdYJzvBurUTTMHv5Pjq1o6v8GDJU26yE6yTnWDd2wmm4MlTbmsnmIQnn+BkJ1gnO8E62QnWyU6wTnaCdWsnmIQnv5aydnZJePJrKWtnl4SnvJZ6Az+snV3itdSwdnZJePBrqWHt7JLwzieshLc+YRX8RnvhYe34Cg8WvEce1k4wBW/t+JLwYGfX8HZ23Q+1hrezS8E7n+CiRx7Wzi4JD94jD7Kza5CdXYPs7BpkZ9ewdnZF30KtHV/hwYL3yMPaCSbhwXvkYe0Ek/DgPfKwdoJJePIJbu0Ek/DgPfKwdoJJePAeeVg7wSQ8uUfeyfE1rB1f4cGSp9xkJ9ggO8GGtxNMwZOn3NZOMAlPPsHJTrBBdoINshNskJ1gg+wEG9ZOMAm/05Tb2vEVHix5yk12gg2yE2x4O8EUPHnKbe0Ek/DkE5zsBBtkJ9ggO8EG2Qk2yE6wYe0Ek/Dg11LD2tkl4cGvpYa1s0vBWzu7JDz5tZS1s0vCk19LWTu7JDz5tZS1s0vC77QXtnZ8hQdL3iNbO8EkPHmPTHZ2DW9nlxhqeTu7FDy5R7Z2dkl48h6Z7OwaZGfXIDu7BtnZNaydXdG3UGvHV3iw1ie4uDtZO8EkPHmPbO0Ek/DkPbK1E0zAT2snmDgEp7UTTMKD98jT2gkm4Z1PWAkP7pGntRNMwm805Z7Wjq/wYMFT7kl2gk2yE2x6O8EUPHjKPa2dYBKefIKTnWCT7ASbZCfYJDvBJtkJNq2dYBJ+oyn3tHZ8hQdrfYKLuxPZCTbJTrDp7QRT8OAp97R2gil4shNskp1gk+wEm2Qn2CQ7wSbZCTatnWASHvxaalo7uyQ8+LXUtHZ2SXjKa6m38ODXUtPa2SXhnU9Y8WZnWju7JDz4tdS0dnZJ+J32wtaOr+hgrZ1garRi7QST8OQ9MtnZNb2dXWKo5e3sUvDkHtna2SXhyXtksrNrkp1dk+zsmmRn17R2dkXfQq0dX+HBkvfI1k4wCU/eI1s7wSQ8eY9s7QST8OQT3NoJJuHJe2RrJ5iEJ++RrZ1gEp7cI+/k+JrWjq/oYMlOsEl2gk2yE2x6O8EUvPMJrm6t1k4wCU8+wclOsEl2gk2yE2ySnWCT7ASb1k4wCb/TlNva8RUeLHnKTXaCTbITbHo7wRQ8eMq9rJ1gEh58gi+yE2yRnWDr5XwiS3jwlHuRnWDL2gkm4cGvpZa1s0vBWzu7JDz4tdSydnZJePBrqWXt7JLw4NdSy9rZJeHBr6WWtbNLwm+0F17Wjq/wYMF75GXtBJPw4D3yIju7lrezSwy1vJ1dCp7cI1s7uyQ8eI+8yM6uRXZ2LbKza5GdXcva2RV9C7V2fIUHC94jL2snmIQH75GXtRNMwVs7wdSt1doJJuHJJ7i1E0zCO5/gEp68R7Z2gkl4co9s7QST8DtNua0dX+HBkqfcZCfYIjvBlrcTTMGTp9zWTjAJTz7ByU6wRXaCLbITbJGdYIvsBFvWTjAJ73zCRt9CrR1f4cGSp9xkJ9giO8GWtxNMwJOdYMvaCSbhySc42Qm2yE6wRXaCLbITbJGdYMvaCSbhya+lrJ1dEp78Wsra2SXhKa+l3sI7n7DqtZS1s0vCk19LWTu7JDz5tZS1s0vBWzu7oodU1o6v8GDJe2RrJ5iEdz7BJTzY2bW8nV1iqOXt7FLw5B7Z2tkl4E9rZ5eEB++RT7Kz6yQ7u86X8wkr4TfaC5/Wjq/wYMF75NPaCSbhwXvk09oJJuHBe+TT2gkm4cknuLUTTMKD98intRNMwoP3yKe1E0zCk3vknRxfp7XjKzxY8JT7JDvBTrIT7PR2gil48JT7tHaCSXjyCU52gp1kJ9hJdoKdZCfYSXaCndZOMAm/05Tb2vEVHix5yk12gp1kJ9jp7QRT8OQpt7UTTMKTT3CyE+wkO8FOshPsJDvBTrIT7LR2gil4a8eXePZyWju7JDz4tdRp7eyS8M4nrIQHv5Y6rZ1dEh78Wuq0dnZJePBrqdPa2SXhd9oLWzu+woMl75GtnWASnrxHJju7Tm9nlxhqeTu7FDy5R7Z2dkl48h6Z7Ow6yc6uk+zsOsnOrtPa2RV9C7V2fIUHS94jWzvBFLy1E0zCg3+Z4rR2gqlbq7UTTMKTT3BrJ5iEJ++RrZ1gEp68R7Z2gil4ayeYhN9pym3t+AoPljzlJjvBTrIT7PR2gil48pTb2gkm4bkneH+BnWAXPHfKfcFzp9wXPHfKfcE7n7ASntsjX/D7TLmvYPeZcl/BcqfcFzx3yt1fYCfYBc+dcl/w3Cn3Bc+dcl/w5BMc7AS74LlT7gueO+W+4LlT7gue3CNbO8EkPPe11AXPfS11wXNfS13wzieshKe8lnoLz30tdcFbv5ZS8NzXUhc897VUf1k7uyS89Qmr4PfZC1/BOp/I4cE6n+BqtGLtBJPw3D3yBc91dl3w3D3yBW89hRbw1s4u1SNbO7skPHmPDHZ2XfDOJ6yEJ0+hwc6uC36nvbC14ys8WPIe2doJJuHJe2RrJ5iEJ++RrZ1gEp58gls7wSQ8eY9s7QST8OQ9srUTTMKTe+SNHF/X/26nKTfYCXbBk6fcYCfYBU+ecoOdYBc8ecoNdoJd8OQTHOwEu+DJU26wE+yCJ/fI1k4wCb/TlNva8RUeLHnKDXaCXfDkKbe3E0zBk6fc1k4wCU8+wcFOsAuePOUGO8EuePKUG+wEu+DJPbK140s9e7F2dkl45xNWwnN/W+qCJ7+WsnZ2yU8b8gn7s86u+vr6w7X8uxb8X3HKz1q4NE7xwqleOIcXTvPC+dHTpJbjd5xZ3uAML5zphbO8cE4rnJ81K2mc4oVTvXAOL5zmheP1qfzDFqF2/vaHS2/tDc70wlleOKcVzg/beCRO8cKpXjiHF07zwuleOF6fytXrU7l6fSpXr0/lw+tT+fD6VD68PpUPr0/lHzaV9NG+cNZ6g9O9cIYXzvTC2eibV8XaEBIdrLVRRHxfqFgbRSQ8+JtaxdooIuGbM/z9N7WKtVFEwm/0yxRlJwNJsTaQyA8E8HetC9koUshGkeJtFBEfxWSjSLE2iohvxRSyUaSQjSKFbBQpZKNIsTaKRN+FrA0k4cGST3BrY4mEJ/fgZKNI8TaKiLuTt1FEwZNPcGujiIQHv5YqZKNIIRtFCtkoUshGkWJtFBFvdoq1UUTCg19LFWujiITfaU9tbQiJDpZsFClko0ghG0WKt1FEwTuf4KpTszaKSHjylJtsFClko0ghG0UK2ShSyEaRYm0UkfAbebCLtYEkPFiwN7tYG0skPNibXayNJRIe7M2uL+seWcGDT/D6Ap/g9QWecteX84ks4cHfBKsvcI9cX+Aeub42mnLX10ZT7lrAU+5awFPuWsBT7lrAU+76sw6f4FtrAU+5ayGf4IV8ghfwlLsW8JS7VvCUu1Zyj1zJPXLdaMpdf9jf9OFgwVPuWsFT7lrBU+5awVPuWslT7oM85T7IJ/hBPsEP8pT7h91dwfDkKfdB7pEPco9s7RwTv/ZSrR1iCt7aCSbhnU9YCQ/+balq7QST8M4nrISnvJZ6C095LfUWnvJa6i08+YS1dnYpeGtnl4Qnn7DWzi4JTz5hrZ1dEp58wlo7u8ST3mrt7JLwO31TayfHV7V2fKn5P9nZVcnOrkp2dlVvZ5fYvJCdXdXa2aUGuWRnVyU7uyrZ2VXJzq5KdnZVsrOrWju7om+h1o6v8GDJ39SydoJJePI3taydYBKe/E0tb2eXgief4NbOLglP/qaWtbNLwpO/qUV2dlWys6taO7uib6HWjq/oYK2dYOruZO0Ek/DkKbe1E0zCO5/g6tbq7exS8OQT3NrZJeHJU25rZ5eAP6ydXRIe3CMfZGfXYe3sCr6FHi/nEzk8WPCU+7B2gkl48JT7sHaCSXjwlPvwdnYpePIJbu3skvDgKfdh7eyS8OAp90F2dh1kZ9dh7ewSTwAOa2eXgrd2dkl48Gupw9rZJR5fHNbOLgnvfMLW9XWfvzaXb+CtX0speOvXUgre+rWUgt9oj3xYO7iig/V2donphLWzS8KD98iHtbNLwjuf4GouZO3skvDkHpns7DqsnV0SnrxHtnZ2SXjyFNra2SXhd9ojWzu+woMl75GtnWASnrxHtnaCSXjyHtnaCSbhySe4tRNMwpP3yNZOMAlP3iNbO8EkPLlH3skJduzkBDvITrCD7AQ7yE6wg+wEO8hOsIPsBDvITrCD7AQ7yE6wg+wEO8hOsIPsBDvITrBjJyfYsZMT7CA7wQ6yE+wgO8EOshPsIDvBDrIT7CA7wQ6yE+wgO8EOshPsIDvBDrIT7CA7wQ5rJ5h69mLt+FLw1s4uCU9+LWXt7JLw5NdS1s4uCU9+LWXt7JLw5NdS1s4uCb/RXrhZO77CgwXvkZu1E0zCg/fI7eV8gkt48B65eTu7FDy4R27Wzi4JD94jN2tnl4QHT6Eb2dnVyM6uZu3sir6FWju+woMF75GbtRNMwoP3yM3aCabgrZ1g6tZq7QST8OQT3NoJJuGdT3AJD94jN2snmIQn98jWTjAJv9OU29rxFR4secpNdoI1shOseTvBFDx5ym3tBJPw5BOc7ARrZCdYIzvBGtkJ1shOsGbtBJPwzids9C3U2vEVHix5yk12gjWyE6x5O8EEPNkJ1qydYBKefIKTnWCN7ARrZCdYIzvBGtkJ1qydYBIe/FqqWTu7JDz4tVSzdnZJeMprqbfwzieseC3VrJ1dEh78WqpZO7skPPi1VLN2dil4a2dX9JDK2vEVHix5j2ztBJPwzie4hAc7u5q3s0sMtbydXQqe3CNbO7sUvLWzS8KT98hkZ1cjO7sa2dnVrJ1d0bdQa8dXeLDkPbK1E0zCk/fI1k4wCU/eI1s7wSQ8+QS3doJJePIe2doJJuHJe2RrJ5iEB/fIfSfHV7d2fIUHC55yd7ITrL+cT3AJD55yd7ITrFs7wSQ8+ATvZCdYJzvBOtkJ1slOsE52gnVrJ5iE32jK3a0dX+HBgqfcnewE62QnWPd2gil48JS7WzvBJDz5BCc7wTrZCdbJTrBOdoJ1shOsWzvBFLy140s8e+nWzi4JD34t1a2dXRLe+YSV8ODXUt3a2SXhwa+lurWzS8KDX0t1a2eXhN9pL2zt+AoPlrxHtnaCSXjyHpns7Orezi4x1PJ2dil4co9s7eyS8OQ9MtnZ1cnOrk52dnWys6tbO7uib6HWjq/wYMl7ZGsnmIK3doJJePAvU3RrJ5i6tVo7wSQ8+QS3doJJePIe2doJJuHJe2RrJ5iCt3aCSfidptzWjq/wYMlTbrITrJOdYN3bCabgyVNuayeYhCef4GQnWCc7wTrZCdbJTrBOdoJ1ayeYhN9pym3t+AoPljzlJjvBOtkJ1r2dYAqePOW2doJJePIJTnaCdbITrJOdYJ3sBOtkJ9iwdoJJePBrqWHt7JLw4NdS4+V8wkp4ymupt/Dg11LD2tkl4cGvpYa1s0vBWzu7JLz1CavgN9oLD2vHV3iwzie4GK0MayeYhAfvkQfZ2TW8nV33Q63h7ewS8NbOLtUjWzu7JDx4jzzIzq5BdnYNsrNrkJ1dw9rZFX0LtXZ8hQcL3iMPayeYhAfvkYe1E0zCg/fIw9oJJuHJJ7i1E0zCg/fIw9oJJuHJe2RrJ5iEJ/fIOzm+hrXjKzxY6xNc3J3ITrBBdoINbyeYgidPua2dYAqe7AQbZCfYIDvBBtkJNshOsEF2gg1rJ5iE32nKbe34Cg+WPOUmO8EG2Qk2vJ1gCp485bZ2gkl48glOdoINshNskJ1gg+wEG2Qn2LB2gkl48mspa2eXhHc+YSU8+bWUtbNLwpNfS1k7uyQ8+bWUtbNLwpNfS1k7uyT8Tntha8dXeLDkPbK1E0zCk/fIZGfX8HZ2iaGWt7NLwZN7ZGtnl4Qn75HJzq5BdnYNsrNrkJ1dw9rZFX0LtXZ8BQc7rZ1g4u40rZ1gEh68R57WTjAJ73yCi1vrtHaCSXjwCT6tnWASHrxHntZOMAVv7QST8OAeeVo7wST8RlPuae34Cg8WPOWeZCfYJDvBprcTTMGDp9zT2gkm4cknONkJNslOsEl2gk2yE2ySnWDT2gkm4Teack9rx1d0sGQn2CQ7wSbZCTa9nWAK3vkEV7dWayeYhCef4GQn2CQ7wSbZCTbJTrBJdoJNayeYhAe/lprWzi4JD34tNa2dXRKe8lrqLTz4tdS0dnYpeGtnl3izM62dXRIe/FpqWju7JLzzCRs9pLJ2fIUHS94jWzvBJDx5j0x2dk1vZ5cYank7uxQ8uUe2dnZJeOcTXMKT98hkZ9ckO7sm2dk1rZ1d0bdQa8dXeLDkPbK1E0zCk/fI1k4wCU/eI1s7wSQ8+QS3doJJePIe2doJJuHJe2RrJ5iEJ/fIOzm+prXjKzxY8pSb7ASbZCfY9HaCCXiyE2xaO8EkPPkEJzvBJtkJNslOsEl2gk2yE2xaO8Ek/EZT7mXt+AoPFjzlXmQn2CI7wdbL+QSX8OAp97J2gkl48Am+yE6wRXaCLbITbJGdYIvsBFvWTjAJ73zCimcvy9rZJeHBr6WWtbNLwlNeS72FB7+WWtbOLgkPfi21rJ1dEh78WmpZO7sk/EZ74WXt+AoPFrxHXtZOMAkP3iMvsrNreTu7xFDL29ml4Mk9srWzS8KD98iL7OxaZGfXIju7FtnZtaydXdG3UGvHV3iw5D2ytRNMwjuf4BIe/MsUy9oJpm6t1k4wCU8+wa2dYAre2gkm4cl7ZGsnmIQn98jWTjAJv9OU29rxFR4secpNdoItshNseTvBFDx5ym3tBJPw5BOc7ARbZCfYIjvBFtkJtshOsGXtBFPwOzm+lrXjKzxY8pSb7ARbZCfY8naCKXjylNvaCSbhySc42Qm2yE6wRXaCLbITbJGdYMvaCSbhya+lrJ1dEp78Wsra2SXhKa+l3sFbO7vUaylrZ5eEJ7+WsnZ2SXjnE1bCW5+wCn6nvbC14ys8WPIe2doJJuBPa8eXhAc7u05vZ9f9UOv0dnYpeOcTXPTIp7WzS8KD98gn2dl1kp1dJ9nZdZKdXae1syv4FnpaO77CgwXvkU9rJ5iEB++RT2snmIQH75FPayeYhCef4NZOMAkP3iOf1k4wCQ/eI5/WTjAJT+6Rd3J8ndaOr/BgwVPuk+wEO8lOsNPbCabgyVNuayeYhCef4GQn2El2gp1kJ9hJdoKdZCfYae0Ek/A7TbmtHV/hwZKn3GQn2El2gp3eTjAFT55yWzvBJDz5BCc7wU6yE+wkO8FOshPsJDvBTmsnmIQHv5Y6rZ1dEh78Wuq0dnYpeGtnl4QHv5Y6rZ1dEh78Wuq0dnZJePBrqdPa2SXhd9oLWzu+woMl75GtnWASnrxHJju7Tm9nlxhqeTu7FDy5R7Z2dkl48h6Z7Ow6yc6uk+zsOsnOrtPa2RV9C7V2fIUHa32Ci7uTtRNMwpP3yNZOMAlP3iNbO8EUvLUTTB2C1k4wCU/eI1s7wSS88wkr4ck9srUTTMLvNOW2dnyFB8udco8X2Al2wXOn3Bc8d8p9wXOn3Be88wku4bkn+AXPPcEveO6U+4LnTrkveO6Ue7zATrALntsjX/D7TLmvYPeZcl/BWp/g4u4EdoJd8Nwp9wXPnXJf8Nwp9wXPnXKPF9gJdsGTT3CwE+yC5065L3jnE1bCk3tkayeYhOe+lrrgua+lLnjua6nxsnZ2SXjKa6m38NzXUhe89WspBe98wt6/2bngua+lLnjua6kL3vqEVfD77IWvYJ1P5OhgrZ1garRi7QST8OQ9MtjZdcE7n+BqqOXt7FLw5B7Z2tkl4cl7ZLCza7zAzq4LnjyFBju7Lvid9sLWjq/wYMl7ZGsnmIQn75GtnWASnrxHtnaCSXjyCW7tBJPw5D2ytRNMwpP3yNZOMAlP7pE3cnxdwe405QY7wS548pQb7AS74MlTbrAT7IInT7nBTrALnnyCg51gFzx5yg12gl3w5B7Z2gkm4Xeacls7vsKDJU+5wU6wC5485fZ2gil48pTb2gkm4cknONgJdsGTp9xgJ9gFT55yg51gFzy5R7Z2fKlnL9bOLgFfrJ1dEh78WqpYO7skPPi1VHk5n7ASHvxaqlg7uyQ8+LVUsXZ2SfiN9sLF2vEVHix4j1ysnWASHrxHLmRnV/F2dt0PtYq3s0vBg3vkYu3skvDgPXIhO7sK2dlVyM6uQnZ2FWtnV/Qt1NrxFR4seI9crJ1gEh68Ry7WTjAFb+0EU7dWayeYhCef4NZOMAnvfIJLePAeuVg7wSQ8uUe2doJJ+J2m3NaOr/BgyVNushOskJ1gxdsJpuDJU25rJ5iEJ5/gZCdYITvBCtkJVshOsEJ2ghVrJ5iEdz5ho2+h1o6v8GDJU26yE6yQnWDF2wkm4MlOsGLtBJPw5BOc7AQrZCdYITvBCtkJVshOsGLtBJPw5NdS1s4uCU9+LWXt7JLwlNdSb+GdT1j1Wsra2SXhya+lrJ1dEp78Wsra2aXgrZ1d0UMqa8dXeLDkPbK1E0zCO5/gEh7s7Crezi4x1PJ2dil4co9s7exS8NbOLglP3iOTnV2F7OwqZGdXsXZ2Rd9CrR1f4cGS98jWTjAJD94jV2snmIQH75GrtRNMwoNP8PoCn+DV2gkm4cF75GrtBJPw4B65WjvBFPxOjq9q7fgKDxY85a5kJ1glO8GqtxNMwYOn3NXaCSbhySc42QlWyU6wSnaCVbITrJKdYNXaCSbhN5pyV2vHV3iw4Cl3JTvBKtkJVr2dYAqePOW2doJJePIJTnaCVbITrJKdYJXsBKtkJ1i1doIpeGvHl3j2Uq2dXRIe/FqqWju7xJudau3skvDkE9ba2SXhf/SEvTa/v/3hazvX3+AsL5zTCudnTVkap3jhVC+cHz1NrhXq7zizvMFpXjjdC2d44UwvnOWFc1rh/Kz9SOMUL5zqheP1qfzDFqF2/vaHS2/tDU73whleONMLZ3nhnFY4P2zMkTjFC6d64RxeOF6fytPrU3l6fSpPr0/l6fWpPL0+lZfXp/Ly+lT+YVNJH+0LZ73Z9f+we0TiNC+c7oWz0zevrA0h4cGSv6llbRRR8NZGEQkP/u2nam0UUd/UsjaKSPi20UfrTgaSam0gkR8I5O9ak40ilWwUObyNIvcfxQfZKHJYG0XEt2IOslHkeDmf4BIe/E2wg2wUOayNIsF3ocPaQBIeLPkEtzaWSHhwD36QjSKHt1FE3J28jSIKnnyCWxtFJDz4tdRBNoocZKPIQTaKHGSjyGFtFBFvdg5ro4iEdz5hJTz4t6WOnQwhh7UhJDxY8JT7IBtFDrJR5PA2iih48J76sDaKSHjnE1xd/MhGkYNsFDnIRpGDbBQ5yEaRw9ooIuE38mAf1gaS8GDB3uzD2lgi4cHe7MPaWCLhwd7so1n3yAqefIJ38gneyVPuTv4mWCd/E+xnnS/R8OQeue805e47Tbk7ecrdyVPuQZ5yD/KUe5Cn3IM85f5hP1DsITjIJ/ggT7kHeco9yFPuQe6RJ7lHnjtNuedOU+5JnnL/sEsqGJ485Z7kKfckT7kneco9ySf4Ip/gizzlXuQp9yJPuX/YCxYMT+6RrZ1j4tdeDmuHmIR3PmElvPMJq+CtnWASHvzbUoe1E0zCU15LvYV3PmElPOW11Ft48glr7eyS8OQT1trZJeCbtbNLwoNP2Gbt7JLw4BO2vSgn7Jsnvc3a2SXhN/qmVtvJ8dWsHV9i/t/Izq5GdnY1srOreTu77jcvjezsatbOLjHIbWRnVyM7uxrZ2dXIzq5GdnY1srOrWTu7om+h1o6v8GDB39Rq1k4wCQ/+plazdoJJePA3tZq3s0vBk09wa2eXhAd/U6tZO7skPPibWo3s7GpkZ1ezdnZF30KtHV/hwZKn3NZOMAVv7QST8OQpt7XjS91avZ1dCp58gls7uyQ8ecpt7eyS8OQpN9nZ1cjOrmbt7Iq+hVo7vsKDJU+5rZ1gEp485bZ2gkl48pTb29ml4MknuLWzS8KTp9zWzi4JT55yk51djezsatbOLvUEwNrZJeHBr6WatbNLwVs7u9TjC2tnl4S3fi21vu7zdb35qLR2akl45xNWwlu/llLwO+2RrR1c4cGS98jWzi4Fb+3skvDkPbK1s0vNhaydXRLe+QRXbSbZ2dWsnV0SnrxHtnZ2SXjyFNra2SXhd9ojWzu+woMl75GtnWASnrxHtnaCSXjyHtnaCSbhwSd4t3aCSXjwHrlbO8EkPHiP3F/OJ6yEB/fIfScnWN/JCdbJTrBOdoJ1shOsk51gnewE62QnWCc7wTrZCdbJTrBOdoJ1shOsk51gnewE6zs5wfpOTrBOdoJ1shOsk51gnewE62QnWCc7wTrZCdbJTrBOdoJ1shOsk51gnewE62QnWLd2golnL93a8SXhwa+lurWzS8FbO7skPPi1VLd2dkl48Gupbu3skvDg11Ld2tkl4XfaC1s7vsKDJe+RrZ1gEp68R7Z2fEl48h7Z29ml4Mk9srWzS8KT98jWzi4JT55Ck51dnezs6tbOruhbqLXjKzxY6xNc3J2snWASnrxHtnaCSXjyHtnaCabgrZ1g6hC0doJJePIe2doJJuGdT1gJT+6RrZ1gEn6nKbe14ys8WPKUm+wE62QnWPd2gil48pTb2gkm4cknONkJ1slOsE52gnWyE6yTnWDd2gkm4Xeacls7vsKDtT7Bxd2J7ATrZCdY93aCKXjylNvaCSbgB9kJNshOsEF2gg2yE2y8nE9YCQ/ukYe1E0zCg19LDWtnl4QHv5Ya1s4uCU95LfUWHvxaalg7uyS88wkr3uwMa2eXhAe/lhrWzi4Jv9FeeFg7vqKDtXaCidHKsHaCSXjwHnmQnV3D29klhlrezi4FT+6RrZ1dEh68Rx5kZ9cgO7sG2dk1yM6uYe3sir6FWju+woMF75GHtRNMwoP3yMPaCSbhyXtkayeYhCef4NZOMAlP3iNbO8EkPHmPbO0Ek/DkHnknx9ewdnxFB0t2gg2yE2yQnWDD2wmm4J1PcHVrtXaCSXjyCU52gg2yE2yQnWCD7AQbZCfYsHaCSfidptzWjq/wYMlTbrITbJCdYMPbCabgyVNuayeYhCef4GQn2CA7wQbZCTbITrBBdoINayeYhCe/lrJ2dil4a2eXhCe/lrJ2dkl48mspa2eXhCe/lrJ2dkl48mspa2eXhN9pL2zt+AoPlrxHtnaCSXjyHpns7Brezi4x1PJ2dil4co9s7eyS8OA98iQ7uybZ2TXJzq5JdnbNl/MJG3wLndaOr/BgwXvkae0Ek/DgPfK0doIpeGsnmLi1TmsnmIQnn+DWTjAJ73yCS3jwHnlaO8EkPLhHntZOMAm/0ZR7Wju+woMFT7kn2Qk2yU6w6e0EU/DgKfe0doJJePIJTnaCTbITbJKdYJPsBJtkJ9i0doJJeOcTNvoWau34Cg+WPOUmO8Em2Qk2vZ1gAp7sBJvWTjAJTz7ByU6wSXaCTbITbJKdYJPsBJvWTjAJD34tNa2dXRIe/FpqWju7JDzltdRbeOcTVryWmtbOLgkPfi01rZ1dEh78WmpaO7sUvLWzK3pIZe34Cg+WvEe2doJJeOcTXMKDnV3T29klhlrezi4FT+6RrZ1dCt7a2SXhyXtksrNrkp1dk+zsmtbOruhbqLXjKzxY8h7Z2gkm4cl7ZGsnmIQn75GtnWASnnyCWzvBJDx5j2ztBJPw5D2ytRNMwpN75J0cX9Pa8RUeLHnKTXaCTbITbHo7wRQ8ecpt7QST8OQTnOwEW2Qn2CI7wRbZCbbITrD1cj5hJfxGU+5l7fgKDxY85V5kJ9giO8GWtxNMwYOn3MvaCSbhySc42Qm2yE6wRXaCLbITbJGdYMvaCabgrR1f4tnLsnZ2SXjwa6ll7eyS8M4nrIQHv5Za1s4uCQ9+LbWsnV0SHvxaalk7uyT8RnvhZe34Cg8WvEde1k4wCQ/eIy+ys2t5O7vEUMvb2aXgyT2ytbNLwpP3yGRn1yI7uxbZ2bXIzq5l7eyKvoVaO77CgyXvka2dYAre2gkm4cG/TLGsnWDq1mrtBJPw5BPc2gkm4cl7ZGsnmIQn75GtnWAK3toJJuF3mnJbO77CgyVPuclOsEV2gi1vJ5iCJ0+5rZ1gEp58gpOdYIvsBFtkJ9giO8EW2Qm2rJ1gEn6nKbe14ys8WPKUm+wEW2Qn2PJ2gil48pTb2gkm4cknONkJtshOsEV2gi2yE2yRnWDL2gkm4cmvpaydXRKe/FrK2tkl4Smvpd7Ck19LWTu7JDz5tZS1s0vAn9bOLglvfcIq+I32wqe14ys8WOcTXIxWTmsnmIQH75FPsrPr9HZ23Q+1Tm9nl4C3dnaJHvm0dnZJePAe+SQ7u06ys+skO7tOsrPrtHZ2Rd9CrR1f4cGC98intRNMwoP3yKe1E0zCg/fIp7UTTMKTT3BrJ5iEB++RT2snmIQH75FPayeYhCf3yDs5vk5rx1d4sNYnuLg7kZ1gJ9kJdno7wRQ8ecpt7QRT8GQn2El2gp1kJ9hJdoKdZCfYSXaCndZOMAm/05Tb2vEVHix5yk12gp1kJ9jp7QRT8OQpt7UTTMKTT3CyE+wkO8FOshPsJDvBTrIT7LR2gkl48Gup09rZJeGdT1gJD34tdVo7uyQ8+LXUae3skvDk11LWzi4JT34tZe3skvA77YWtHV/hwZL3yNZOMAlP3iOTnV2nt7NLDLW8nV0KntwjWzu7JDx5j0x2dp1kZ9dJdnadZGfXae3sir6FWju+ooO1doKpu5O1E0zCk/fI1k4wCe98gqtbq7UTTMKTT3BrJ5iEJ++RrZ1g9/DzZe0Ek/DcHvmC5/bIF/w+U+4rWOcTOTxY7pT7gudOuS947pT7gudOuS947pR7vqydYBKefIKDnWAXPHfKfcE7n8gSnjvlvuC5PfIFz+2RL/h9ptxXsPtMuecL7AS74LlT7gueO+W+4LlT7gve+QRXt1ZrJ5iEJ5/gYCfYBc+dcl/w5Ck32Al2wZN7ZGsnmITnvpa64J1PWAnPfS11wXNfS13wlNdSb+G5r6UueOvXUgLe2tl1/2bngue+lrrgua+lLnjrE1bBO5+w0UMqa8dXeLDkPbK1E0zCk/fIYGfXfHk7u8RQy9vZpeDJPbK1s0vCO5/gEp68RwY7uy548hQa7Oy64HfaC1s7vsKDJe+RrZ1gEp68R7Z2gkl48h7Z2gkm4cknuLUTTMKT98jWTjAJT94jWzvBJDy5R97I8XUFu9OUG+wEu+DJU26wE+yCJ0+5wU6wC5485QY7wS548gkOdoJd8OQpN9gJdsGTe2RrJ5iE32nKbe34Cg+WPOUGO8EuePKU29sJpuDJU25rJ5iEJ5/gYCfYBQ+echeyE6yQnWCF7AQr1k4wCe98wopnL8Xa2SXhwa+lirWzS8JTXku9hQe/lirWzi4JD34tVaydXRIe/FqqWDu7JPxGe+Fi7fgKDxa8Ry7WTjAJD94jF7Kzq3g7u+6HWsXb2aXgyT2ytbNLwoP3yIXs7CpkZ1chO7sK2dlVrJ1d0bdQa8dXeLDgPXKxdoJJeOcTXMKDf5miWDvB1K3V2gkm4cknuLUTTMFbO8EkPHmPbO0Ek/DkHtnaCSbhd5pyWzu+woMlT7nJTrBCdoIVbyeYgidPua2dYBKefIKTnWCF7AQrZCdYITvBCtkJVqydYAp+J8dXsXZ8hQdLnnKTnWCF7AQr3k4wBU+ecls7wSQ8+QQnO8EK2QlWyE6wQnaCFbITrFg7wSQ8+bWUtbNLwpNfS1k7uyQ85bXUO3hrZ5d6LWXt7JLw5NdS1s4uCe98wkp46xNWwe+0F7Z2fIUHS94jWzvBFLy140vCg51dxdvZJYZa3s4uBe98gqse2drZJeHJe2Sys6uQnV2F7OyqZGdXtXZ2Bd9Cq7XjKzxY8B65vpxPcAkP3iNXayeYhAfvkau1E0zCk09wayeYhAfvkau1E0zCg/fI1doJJuHBPXLdyfFVrR1f4cGCp9yV7ASrZCdY9XaCKXjwlLtaO8EkPPkEJzvBKtkJVslOsEp2glWyE6xaO8Ek/E5TbmvHV3iw5Ck32QlWyU6w6u0EU/DkKbe1E0zCk09wshOskp1glewEq2QnWCU7waq1E0zCg19LVWtnl4QHv5aq1s4uBW/t7JLw4NdS1drZJeHBr6WqtbNLwoNfS1VrZ5eE32kvbO34Cg+WvEe2doJJePIemezsqt7OLjHU8nZ2KXhyj2zt7JLw5D0y2dlVyc6uSnZ2VbKzq1o7u6JvodaOr/BgrU9wcXeydoJJePIe2doJJuHJe2RrJ5iCt3aCqUPQ2gkm4cl7ZGsnmIR3PmElPLlHtnaCSfidptzWjq/wYMlTbrITrJKdYNXbCabgyVNuayeYhCef4GQnWCU7wSrZCVbJTrCD7AQ7rJ1gEn6jKfdh7fgKD9b6BL+/Ox1kJ9hBdoId3k4wBQ+ech/WTjAFT3aCHWQn2EF2gh1kJ9hBdoIdZCfYYe0Ek/Dg11KHtbNLwoNfSx3Wzi4JT3kt9RYe/FrqsHZ2SXjnE1a82TmsnV0SHvxa6rB2dkn4jfbCh7XjKzpYayeYGq1YO8EkPHiPfJCdXYe3s0sMtbydXQqe3CNbO7skPHiPfJCdXQfZ2XWQnV0H2dl1WDu7om+h1o6v8GDJe2RrJ5iEJ++RrZ1gEp68R7Z2gkl48glu7QST8OQ9srUTTMKT98jWTjAJT+6Rd3J8HdaOr+hgyU6wg+wEO8hOsMPbCabgnU9wdWu1doJJePIJTnaCHWQn2EF2gh1kJ9hBdoId1k4wCb/TlNva8RUeLHnKTXaCHWQn2OHtBFPw5Cm3tRNMwpNPcLIT7CA7wQ6yE+wgO8EOshPssHaCSXjyaylrZ5eCt3Z2SXjwb0sd1s4uCU8+Ya2dXRL+R0/Y+vr6w7X8uxb833CGF870wlleOKcTTvtZm5XG+dHTpJbjd5xZ3uBUL5zDC6d54XQvnOGFM71wlhfOaYXzs4YijeP1qfzDFqF2/vaHS2/tDc7hhdO8cLoXzvDCmV44ywvntML5YauNxCleOF6fytXrU7l6fSpXr0/l6vWpXL0+lavXp3L1+lT+YVNJH+0LZ603OMULp3rhHF44P/up/NFvXjVrQ0h4sOBvajVro4iEB39Tq1kbRRS8tVFEfFOrWRtFJPxGv0zRdjKQNGsDifxAAH/XupGNIo1sFGneRhH1UQz+rnWzNoqIb8U0slGkkY0ijWwUaWSjSLM2ikTfhawNJOHBkk9wa2OJhCf34GSjSPM2ioi7k7dRRMGTT3Bro4iEB7+WamSjSCMbRRrZKNLIRpFmbRQRb3aatVFEwoNfSzVro4iEdz5hozsva0NIeLDkKTfZKNLIRpHmbRQR8GSjSLM2ikh48pSbbBRpZKNIIxtFGtko0shGkWZtFJHwG3mwm7WBJDxYsDe7WRtLJDzYm92sjSUSHuzNbqd1j6zgySf4ST7BT/CUu7/A3wTrL/A3wfoL3CP3F7hH7i/nEzb4FtpfG025+ws85e4v8JS7v8BT7v4CT7l7AU+5ewFPuXshn+CFfIL/sHsoGB485e4FPOXuBdwj9wLukXvZaMrd60ZT7l7BU+5ewVPuXsFT7v7DnqpgePCUu1fwlLtX8gleySd4JU+5D/KU+yBPuQ9yj3yQe2Rr55j4tZdu7RCT8M4nrIR3PmElPPi3pbq1E0zBWzvBJDzltdRbeMprqbfwlNdSb+HJJ6y1s0vCk09Ya2eXhCefsNbOLgVv7eyS8OQT1trZJZ70dmtnl4R3PmGjNyk7Ob66teNLzf/Jzq5OdnZ1srOrezu7xOaF7Ozq1s4uNcglO7s62dnVyc6uTnZ2dbKzq5OdXd3a2RV9C7V2fIUHS/6mlrUTTMKTv6ll7QST8ORvank7uxQ8+QS3dnZJePI3taydXRKe/E0tsrOrk51d3drZFX0LtXZ8hQdLnnJbO8EkPHnKbe0EU/DWji91a/V2dil48glu7eyS8M4nuIQnT7mtnV0Sntwjk51d3drZFXwLHdaOr/BgwVPuYe0Ek/DgKfd4OZ/gEh485R7ezi4FDz7Bh7WzS8KDp9zD2tkl4cFT7kF2dg2ys2tYO7vEE4Bh7eyS8ODXUsPa2SXhKa+l3jy+GNbOLgVv7eCq6+s+X9ebj0prp5aEt34tpeCtX0speOcTNnrOY+3gCg8WvEce1s4uCQ/eIw9rZ5eCt3Z2qbmQtbNLwpN7ZLKza1g7uyQ8eI88rJ1dEp48hbZ2dkn4nfbI1o6v8GDJe2RrJ5iEJ++RrZ1gEp68R7Z2gkl48glu7QST8OQ9srUTTMKT98jWTjAJT+6Rd3KCjZ2cYIPsBBtkJ9ggO8EG2Qk2yE6wQXaCDbITbJCdYIPsBBtkJ9ggO8EG2Qk2yE6wsZMTbOzkBBtkJ9ggO8EG2Qk2yE6wQXaCDbITbJCdYIPsBBtkJ9ggO8EG2Qk2yE6wQXaCDWsnmHr2Yu34kvDk11LWzi4JD/5tqWHt7FKvpaydXRKe/FrK2tkl4cmvpaydXRJ+p72wteMrPFjyHtnaCSbhwXvkae34kvDgPfL0dnYpeHCPPF/OJ7iEB++Rp7WzS8KDp9CT7OyaZGfXtHZ2Bd9Cp7XjKzxY8B55WjvBJLzzCS7hrffICh68R57WTjAJTz7BrZ1gCt7aCSbhwXvkae0Ek/DkHtnaCSbhN5pyT2vHV3iw4Cn3JDvBJtkJNr2dYAqePOW2doJJePIJTnaCTbITbJKdYJPsBJtkJ9i0doIp+J0cX9Pa8RUeLHnKTXaCTbITbHo7wRQ8ecpt7QST8OQTnOwEm2Qn2CQ7wSbZCTbJTrBp7QST8ODXUtPa2SXhwa+lprWzS8JTXku9g7d2donXUtPa2SXhwa+lprWzS8I7n7AS3vqEVfA77YWtHV/hwZL3yNZOMAVv7fiS8GBn1/R2domhlrezS8E7n+CqR7Z2dkl48h6Z7OyaZGfXJDu7JtnZNa2dXdG3UGvHV3iw5D2ytRNMwpP3yNZOMAlP3iNbO8EkPPkEt3aCSXjyHtnaCSbhyXtkayeYhCf3yDs5vqa14ys8WPKUm+wEW2Qn2PJ2gil48JR7WTvBJDz4BF9kJ9giO8EW2Qm2yE6wRXaCLWsnmITfaMq9rB1f4cGCp9yL7ARbZCfY8naCKXjwlHtZO8EkPPkEJzvBFtkJtshOsEV2gi2yE2xZO8EkPPi11LJ2dkl48GupZe3sUvDWzi4JD34ttaydXRIe/FpqWTu7JDz4tdSydnZJ+I32wsva8RUeLHmPbO0Ek/DkPTLZ2bW8nV1iqOXt7FLw5B7Z2tkl4cl7ZLKza5GdXYvs7FpkZ9eydnZF30KtHV/hwVqf4OLuZO0Ek/DkPbK1E0zCk/fI1k4wBW/tBFOHoLUTTMKT98jWTjAJ73zCSnhyj2ztBJPwO025rR1f4cGSp9xkJ9giO8GWtxNMwZOn3NZOMAlPPsHJTrBFdoItshNskZ1gi+wEW9ZOMAm/05Tb2vEVHqz1CS7uTmQn2CI7wZa3E0zBk6fc1k4wBU92gi2yE2yRnWCL7ARbZCfYIjvBlrUTTMKTX0tZO7skPPi11Gnt7JLwlNdSb+HBr6VOa2eXhHc+YcWbndPa2SXhwa+lTmtnl4TfaC98Wju+ooO1doKJ0cpp7QST8OA98kl2dp3ezq77odbp7exS8OAe+bR2dkl48B75JDu7TrKz6yQ7u06ys+u0dnZF30KtHV/hwYL3yKe1E0zCg/fIp7UTTMKD98intRNMwpNPcGsnmIQH75FPayeYhAfvkU9rJ5iEJ/fIOzm+TmvHV3SwZCfYSXaCnWQn2OntBFPwzie4urVaO8EkPPkEJzvBTrIT7CQ7wU6yE+wkO8FOayeYhN9pym3t+AoPljzlJjvBTrIT7PR2gil48pTb2gkm4cknONkJdpKdYCfZCXaSnWAn2Ql2WjvBJDz4tdRp7exS8NbOLglPfi1l7eyS8OTXUtbOLglPfi1l7eyS8OTXUtbOLgm/017Y2vEVHix5j2ztBJPw5D0y2dl1eju7xFDL29ml4Mk9srWzS8KT98hkZ9dJdnadZGfXSXZ2ndbOruhbqLXjKzxY8h7Z2gkm4cl7ZGsn2D38elk7we5vrRe8dY+s4Lkn+AXPPcEveOcTXMJz98gXPHePfMFze+QLntsjX/D7TLnXy9rxFR4sd8p9wXOn3Bc8d8p9wTuf4BKeO+W+4LlT7guefIKDnWAXPHfKvV5gJ9gFz51yX/DkHtnaCSbhnU/Y6FuoteMrPFjulPuC5065L3julPuCJ0+5wU6wC5485QY7wS548gkOdoJd8OQpN9gJdsGTe2RrJ5iE576WWi9rZ5eE576WuuC5r6UueMprqbfwzifs/WupC976tZSC576WuuC5r6UueO5rqQve+oQV8NbOrughlbXjKzxY8h7Z2gkm4Z1PcAnPdXZd8OQ9srezS8GTe2RrZ5eCt3Z2SXjyHhns7LrgyVNosLPrgt9pL2zt+AoPlrxHtnaCSXjyHtnaCSbhyXtkayeYhCef4NZOMAlP3iNbO8EkPHmPbO0Ek/DkHnkjx9cV7E5TbrAT7IInT7nBTrALnjzlBjvBLnjylBvsBLvgySc42Al2wZOn3GAn2AVP7pGtnWASfqcpt7XjKzxY8pQb7AS74MFT7uLtBFPw4Cl3sXaCSXjwCV5e4BO8kJ1ghewEK2QnWCE7wYq1E0zBWzu+xLOXYu3skvDg11LF2tkl4Z1PWAkPfi1VrJ1dEh78WqpYO7skPPi1VLF2dkn4jfbCxdrxFR4seI9crJ1gEh68Ry5kZ1fxdnaJoZa3s0vBk3tka2eXhAfvkQvZ2VXIzq5CdnYVsrOrWDu7om+h1o6v8GDBe+Ri7QRT8NZOMAkP/mWKYu0EU7dWayeYhCef4NZOMAlP3iNbO8EkPHmPbO0EU/DWTjAJv9OU29rxFR4secpNdoIVshOseDvBFDx5ym3tBJPw5BOc7AQrZCdYITvBCtkJVshOsGLtBJPwO025rR1f4cGSp9xkJ1ghO8GKtxNMwZOn3NZOMAlPPsHJTrBCdoIVshOskJ1ghewEK9ZOMAlPfi1l7eyS8OTXUtbOLglPeS31Fp78Wsra2SXhya+lrJ1dCt7a2SXhrU9YBb/TXtja8RUerPMJrkYr1k4wCU/eI5OdXcXb2SWGWt7Ornv4au3sEj1ytXZ2SXjwHrmSnV315XzCSnjwFLqSnV3V2tkVfAut1o6v8GDBe+Rq7QST8OA9crV2gkl48B65WjvBJDz5BLd2gkl48B65WjvBJDx4j1ytnWASntwj7+T4qtaOr/BgrU9wcXciO8Eq2QlWvZ1gCh485a7WTjAFT3aCVbITrJKdYJXsBKtkJ1glO8GqtRNMwu805bZ2fIUHS55yk51glewEq95OMAVPnnJbO8EkPPkEJzvBKtkJVslOsEp2glWyE6xaO8EkPPi1VLV2dkl45xNWwoNfS1VrZ5eEB7+WqtbOLgkPfi1VrZ1dEh78WqpaO7sk/E57YWvHV3iw5D2ytRNMwpP3yGRnV/V2domhlrezS8GTe2RrZ5eEJ++Ryc6uSnZ2VbKzq5KdXdXa2RV9C7V2fEUHa+0EU3cnayeYhCfvka2dYBLe+QRXt1ZrJ5iEJ5/g1k4wCU/eI1s7wRS8tRNMwpN7ZGsnmITfacpt7fgKD5Y85SY7wSrZCVa9nWAKHjzlPqydYBIefIIfZCfYQXaCHS/nE1nCg6fcB9kJdlg7wST8RlPuw9rxFR0s2Ql2kJ1gB9kJdng7wRS88wmubq3WTjAJTz7ByU6wg+wEO8hOsIPsBDvITrDD2gkm4cGvpQ5rZ5eEB7+WOqydXRKe8lrqLTz4tdRh7exS8NbOLvFm57B2dkl48Gupw9rZJeGdT9joIZW14ys8WPAe+bB2gkl48B75IDu7Dm9nlxhqeTu7FDy5R7Z2dkl45xNcwpP3yGRn10F2dh1kZ9dh7eyKvoVaO77CgyXvka2dYBKevEe2doJJePIe2doJJuHJJ7i1E0zCk/fI1k4wCU/eI1s7wSQ8uUfeyfF1WDu+woMlT7nJTrCD7AQ7vJ1gAp7sBDusnWASnnyCk51gB9kJdpCdYAfZCXaQnWCHtRNMwu805bZ2fIUHS55yk51gB9kJdng7wRQ8ecpt7QST8OQTnOwEO8hOsIPsBDvITrCD7AQ7rJ1gEt75hFXPXqydXRKe/FrK2tkl4Smvpd7Cg19LNWtnl4QHv5Zq1s4uCQ9+LdVe1iesgt9oL9ysHV/hwYL3yM3aCSbhwXvkRnZ2NW9n1/1Qq3k7uxQ8uEdu1s4uCQ/eIzeys6uRnV2N7OxqZGdXs3Z2Rd9CrR1f4cGC98jN2gkm4Z1PcAkP/mWKZu0EU7dWayeYhCef4NZOMAVv7QST8OA9crN2gkl4co9s7QST8DtNua0dX+HBkqfcZCdYIzvBmrcTTMGTp9zWTjAJTz7ByU6wRnaCNbITrJGdYI3sBGvWTjAFv5Pjq1k7vsKDJU+5yU6wRnaCNW8nmIInT7mtnWASnnyCk51gjewEa2QnWCM7wRrZCdasnWASHvxaqlk7uyQ8+LVUs3Z2SXjKa6l38NbOLvVaytrZJeHJr6WsnV0S3vmElfDWJ6yC32kvbO34Cg+WvEe2doIpeGvHl4QHO7uat7NLDLW8nV0K3vkEVz2ytbNLwpP3yGRnVyM7uxrZ2dXIzq5m7eyKvoVaO77CgyXvka2dYBKevEe2doJJePIe2doJJuHBJ3i3doJJePAeuVs7wSQ8eI/cX84nrIQH98h9J8dXt3Z8hQcLnnJ3shOsk51g3dsJpuDBU+5u7QST8OQTnOwE62QnWCc7wTrZCdbJTrBu7QST8BtNubu14ys8WPCUu5OdYJ3sBOveTjAFD55yd2snmIQnn+BkJ1gnO8E62QnWyU6wTnaCdWsnmIQHv5bq1s4uCQ9+LdWtnV3izU63dnZJePIJa+3skvA/esLW19cfruXfteD/htO8cLoXzvDCmV44ywvnR0+TWo7fcWb5R5yfNU5pnOKFU71wDi+c5oXTvXCGF870wlleOF6fyj9sEWrnb3+4XFetNzjFC6d64RxeOM0Lp3vhDC+c6YWzvHBOK5zp9ak8vT6Vp9en8vT6VJ5en8rT61N5en0qT69P5R82lVw3iC+c9WbX/8PuEYXzwzYRiVO8cHb65pW1ISQ82GYcrPq+kLVRRMKTv6llbRSR8ORvalkbRRS8tVEk+qN1JwNJtzaQqA8EslGkk40inWwU6d5GEfVRTP6utbVRRH0rhmwUGWSjyCAbRQbZKDKsjSLBd6Hxcj6Rw4MFn+DD2lgi4cE9+CAbRYa3UeT+7jS8jSIKnnyCWxtFJDz4tdQgG0UG2SgyyEaRQTaKDGujiHizM6yNIgre2igi4cG/LTV2MoQMa0NIeLDOJ7jqF8hGkUE2igxvo4iCB++ph7VRRMGTjSKDbBQZZKPIIBtFBtkoMshGkWFtFJHwG3mwh7WBJDxYsDd7WBtLJDzYmz2sjSUSHuzNHj/rN4mGJ5/gjXyCN/KUu4G/CTYa+Ztgndwjd3KP3Heacvedptw/68IJvjt18pS7k6fcnTzl7uQpdydPuQf5BB/kE3yQp9yDPOX+Ya9RMDy5Rx7kHnnsNOUeO025B3nKPclT7kmeck/ylHuSp9w/7MAKhief4JN8gk/ylHuSp9yTPOVe5B55kXtka+eY+LWXYe0Qk/DOJ6yEdz5hJTz4t6WGtRNMwoN/W2pYO8EUvLUTTMJTXku9hSefsNbOLglPPmGtnV0SnnzCWju7JDz5hLV2dgn4ae3sEk96p7WzS8Jv9E2tuZPja76cT3Ax/59kZ9ckO7sm2dk1vZ1d95uXSXZ2TWtnlxjkTrKza5KdXZPs7JpkZ9ckO7sm2dk1rZ1d0bdQa8dXeLDgb2pNayeYhAd/U2taO8EkPPibWtPb2aXgySe4tbNLwoO/qTWtnV0SHvxNrUl2dk2ys2taO7uib6HWjq/wYK1PcHF3snaCSXjylNvaCSbhyVNub2eXgLd2dqlD0NrZJeHJU25rZ5eEdz5hJTy5RyY7u6a1syv6Fmrt+AoPljzltnaCSXjylNvaCSbhyVNub2eXgief4NbOLglPnnJbO7skPHnKTXZ2TbKza1o7u9QTAGtnl4R3PmElPPi11LR2dqnHF9bOLglv/Vpqfd3n63r3UWn9WkrAWzu1JLz1aykFv9Me2drBFR6s8wmuphPWzi4JT94jWzu7JDx5j2zt7FLwZGfXJDu7prWzS8KT98jWzi4JT55CWzu7JPxOe2Rrx1d4sOQ9srUTTMKT98jWTjAJT94jWzvBJDz5BLd2gkl48h7Z2gkm4cF75GXtBJPw4B557eQEWzs5wdbL+gS/vzstshNskZ1gi+wEW2Qn2CI7wRbZCbbITrBFdoItshNskZ1gi+wEW2Qn2NrJCbZ2coItshNskZ1gi+wEW2Qn2CI7wRbZCbbITrBFdoItshNskZ1gi+wEW2Qn2CI7wZa1E0w8e1nWji8J73zCSnjwa6ll7eyS8ODXUsva2SXhwa+llrWzS8KDX0sta2eXhN9pL2zt+AoPlrxHtnaCSXjyHtna8SXhyXtkb2eXgif3yNbOLglP3iNbO7skPHkKTXZ2LbKza1k7u6JvodaOr+hgrZ1g6u5k7QST8OQ9srUTTMI7n+Dq1mrtBJPw5BPc2gkm4cl7ZGsnmIK3doJJeHKPbO0Ek/A7TbmtHV/hwZKn3GQn2CI7wZa3E0zBk6fc1k4wCU8+wclOsEV2gi2yE2yRnWCL7ARb1k4wCb/TlNva8RUdLNkJtshOsEV2gi1vJ5iCdz7B1a3V2gkm4cknONkJtshOsEV2gp1kJ9hJdoKd1k4wCQ9+LXW+nE9YCQ9+LXVaO7skPOW11Ft48Gup09rZpeCtnV3izc5p7eyS8ODXUqe1s0vCO5+wwUOq09rxFR4seI98WjvBJDx4j3ySnV2nt7Prfqh1eju7FDy5R7Z2dkl45xNcwoP3yCfZ2XWSnV0n2dl1Wju7om+h1o6v8GDBe+TT2gkm4cF75NPaCSbhwXvk09oJJuHJJ7i1E0zCk/fI1k4wCU/eI1s7wSQ8uUfeyfF1Wju+woMlT7nJTrCT7AQ7vZ1gAp7sBDutnWASnnyCk51gJ9kJdpKdYCfZCXaSnWCntRNMwu805bZ2fIUHS55yk51gJ9kJdno7wRQ8ecpt7QST8OQTnOwEO8lOsJPsBDvJTrCT7AQ7rZ1gEt75hFXPXqydXRKe/FrK2tkl4Smvpd7Ck19LWTu7JDz5tZS1s0vCk19LWTu7JPxOe2Frx1d4sOQ9srUTTMKT98hkZ9fp7ewSQy1vZ5eCJ/fI1s4uCU/eI5OdXSfZ2XWSnV0n2Nl1vqydXbG30CtY5xM5PFjuHvmC5+6RL3jnE1zCc3+Z4oLn7pEveOseWcFzT/ALnnyCWzvBJDx3j3zBc/fIFzy3R77gnU9YCb/PlPsKdp8p9xUsd8p9wXOn3Bc8d8p9vrydYAqeO+W+4LlT7guefIKDnWAXPHfKfcFzp9wXPHfKfcGTe2RrJ5iC38jxdQW705Qb7AS74MlTbrAT7IInT7nBTrALnjzlBjvBLnjyCQ52gl3w5Ck32Al2wZN7ZGsnmITnvpa64LmvpS547mupC577WuqCp7yWegdv7ey6fy11wVu/llLw3NdSFzz3tdQF73zCSnjrE1bB77QXtnZ8hQdL3iNbO8EUvLXjS8JznV0XPHmP7O3sUvDOJ7jqka2dXRKevEcGO7suePIUGuzsOl9gZ9cFv9Ne2NrxFR4seY9s7QST8OQ9srUTTMKT98jWTjAJTz7BrZ1gEp68R7Z2gkl48h7Z2gkm4ck98kaOryvYnabcYCfYBU+ecoOdYBc8ecoNdoJd8OQpN9gJdsGTT3CwE+yCJ0+5wU6wCx7cIxdrJ5iE32jKXawdX+HBgqfc5eV8gkt48JS7eDvBFDx4yl2snWASnnyCk51ghewEK2QnWCE7wQrZCVasnWASHvxaqlg7uyQ8+LVUsXZ2KXhrZ5eEB7+WKtbOLgkPfi1VrJ1dEh78WqpYO7sk/EZ74WLt+AoPFrxHLtZOMAkP3iMXsrOreDu7xFDL29ml4Mk9srWzS8KD98iF7OwqZGdXITu7CtnZVaydXdG3UGvHV3iw1ie4uDtZO8EkPHmPbO0Ek/DkPbK1E0zBWzvB1CFo7QST8OQ9srUTTMI7n7ASntwjWzvBJPxOU25rx1d4sOQpN9kJVshOsOLtBFPw5Cm3tRNMwpNPcLITrJCdYIXsBCtkJ1ghO8GKtRNMwu805bZ2fIUHa32Ci7sT2QlWyE6w4u0EU/DkKbe1E0zBk51ghewEK2QnWCE7wQrZCVbITrBi7QST8OTXUtbOLglPfi1l7eyS8JTXUm/hya+lrJ1dEt75hFVvdqydXRKe/FrK2tkl4XfaC1s7voKDrdZOMDFaqdZOMAkP3iNXsrOrvpxPcDHUqt7OLgUP7pGrtbNLwoP3yJXs7KpkZ1clO7sq2dlVrZ1d0bdQa8dXeLDgPXK1doJJePAeuVo7wSQ8eI9crZ1gEp58gls7wSQ8eI9crZ1gEh68R67WTjAJT+6Rd3J8VWvHV3SwZCdYJTvBKtkJVr2dYAre+QRXt1ZrJ5iEJ5/gZCdYJTvBKtkJVslOsEp2glVrJ5iE32nKbe34Cg+WPOUmO8Eq2QlWvZ1gCp485bZ2gkl48glOdoJVshOskp1glewEq2QnWLV2gkl48Gupau3sUvDWzi4JD34tVa2dXRIe/FqqWju7JDz4tVS1dnZJePBrqWrt7JLwO+2FrR1f4cGS98jWTjAJT94jk51d1dvZJYZa3s4uBU/uka2dXRKevEcmO7sq2dlVyc6uSnZ2VWtnV/Qt1NrxFR4seY9s7QST8OQ9srUTTMFbO8HUrdXaCSbhySe4tRNMwjuf4BKevEe2doJJeHKPbO0Ek/AbTbkPa8dXeLDgKfdBdoIdZCfY8XI+wSU8eMp9WDvBJDz4BD/ITrCD7AQ7yE6wg+wEO8hOsMPaCSbhnU/Y6FuoteMrPFjwlPsgO8EOshPs8HaCCXiyE+ywdoJJePIJTnaCHWQn2EF2gh1kJ9hBdoId1k4wCQ9+LXVYO7skPPi11GHt7JLwlNdSb+GdT1jxWuqwdnZJePBrqcPa2SXhwa+lDmtnl4K3dnZFD6msHV/hwZL3yNZOMAnvfIJLeLCz6/B2domhlrezS8GTe2RrZ5eCt3Z2SXjyHpns7DrIzq6D7Ow6rJ1d0bdQa8dXeLDkPbK1E0zCk/fI1k4wCU/eI1s7wSQ8+QS3doJJePIe2doJJuHJe2RrJ5iEJ/fIOzm+DmvHV3iw5Ck32Ql2kJ1gh7cTTMGTp9zWTjAJTz7ByU6wg+wEO8hOsIPsBDvITrDD2gkm4Xeacls7vsKDJU+5yU6wg+wEO7ydYAqePOW2doJJePIJTnaCHWQn2EF2gh1kJ9hBdoId1k4wAd+sHV/i2UuzdnZJePBrqWbt7JLwzieshAe/lmrWzi4JD34t1aydXRIe/FqqWTu7JPxGe+Fm7fgKDxa8R27WTjAJD94jN7Kzq3k7u+6HWs3b2aXgyT2ytbNLwoP3yI3s7GpkZ1cjO7sa2dnVrJ1d0bdQa8dXeLDgPXKzdoIpeGsnmIQH/zJFs3aCqVurtRNMwpNPcGsnmIQH75GbtRNMwoP3yM3aCabgrZ1gEn6nKbe14ys8WPKUm+wEa2QnWPN2gil48pTb2gkm4cknONkJ1shOsEZ2gjWyE6yRnWDN2gkm4Xeacls7vsKDJU+5yU6wRnaCNW8nmIInT7mtnWASnnyCk51gjewEa2QnWCM7wRrZCdasnWASnvxaytrZJeHJr6WsnV0SnvJa6i08+bWUtbNLwpNfS1k7uxS8tbNLwlufsAp+p72wteMrPFjnE1yNVqydYBKevEcmO7uat7NLDLW8nV0C3trZpXpka2eXhCfvkcnOrkZ2djWys6uRnV3N2tkVfQu1dnyFBwveI3drJ5iEB++Ru7UTTMKD98j95XyCS3jwCd6tnWASHrxH7tZOMAkP3iN3ayeYhAf3yH0nx1e3dnyFB2t9gou7E9kJ1slOsO7tBFPw4Cl3t3aCKXiyE6yTnWCd7ATrZCdYJzvBOtkJ1q2dYBJ+oyl3t3Z8hQdLnnKTnWCd7ATr3k4wBU+ecls7wSQ8+QQnO8E62QnWyU6wTnaCdbITrFs7wSQ8+LVUt3Z2SXjnE1bCg19LdWtnl4QHv5bq1s4uCQ9+LdWtnV0SHvxaqls7uyT8Tntha8dXeLDkPbK1E0zCk/fIZGdX93Z2iaGWt7NLwZN7ZGtnl4Qn75HJzq5OdnZ1srOrk51d3drZFX0LtXZ8RQdr7QRTdydrJ5iEJ++RrZ1gEt75BFe3VmsnmIQnn+DWTjAJT94jWzvBFLy1E0zCk3tkayeYhN9pym3t+AoPljzlJjvBOtkJ1r2dYAqePOW2doJJePIJTnaCdbITrJOdYJ3sBOtkJ1i3doJJ+J2m3NaOr+BgB9kJNshOsEF2gg1vJ5iCdz7Bxa11WDvBJDz4BB9kJ9ggO8EG2Qk2yE6wQXaCDWsnmIQHv5Ya1s4uCQ9+LTWsnV0SnvJa6i08+LXUsHZ2KXhrZ5d4szOsnV0SHvxaalg7uyS88wkbPaSydnyFBwveIw9rJ5iEB++RB9nZNbydXWKo5e3sUvDkHtna2SXhnU9wCQ/eIw+ys2uQnV2D7Owa1s6u6FuoteMrPFjyHtnaCSbhyXtkayeYhCfvka2dYBKefIJbO8EkPHmPbO0Ek/DkPbK1E0zCk3vknRxfw9rxFR4secpNdoINshNseDvBBDzZCTasnWASnnyCk51gg+wEG2Qn2CA7wQbZCTasnWASfqcpt7XjKzxY8pSb7AQbZCfY8HaCKXjylNvaCSbhySc42Qk2yE6wQXaCDbITbJCdYMPaCSbhnU9Y9ezF2tkl4cmvpaydXerNjrWzS8KTT1hrZ5eE/9ETtr6+/nAt/64F/zec6oVzeOE0L5zuhTO8cH70NKnl+B1nljc4ywvndMKZP2tt0jjFC6d64RxeOM0Lp3vhDC8cq0/l+bMWoaO+2m9/uL76G5zTCudnTT/XPxi//eHezjc4xQuneuEcXjg/+ql8jNfx2x8e5R1O/9nszPWF01STWK4//RtHOV6v+gZ/sPEnG3+x8U9r/LHu8euLjV+M8Y9XL7/jj3f4lY1/sPEbG9/51D1eX1eYf8U/5H/VZ/sKt85R1L/vY379+z7Wu/Q4n+oG6XG+NRikx/lW8k9Pz3Ut+ErPPN609tX51vP59BzOtyqD9Hjf2v7Z6Wnj9/S8O9gP71vhx9Pjfev8eHpapucuPVvfmnV6tr416/RsfWvW6dn71rx+byrm+S49e9+aVXra3rdmmZ69b80yPVvfmtdrfqVn1fYmPVvfmnV6WqbnLj1b35p1era+Nev0bH1r1unZ+ta82vF7evq79Gx9a5bp6VvfmnV6tr416/TsfWse5+/pWeNNeva+Ncv0tEzPXXr2vjXL9Ox9a5bp2fvWLNOz961ZpmfvW7Pqucbet2aZnvyGxm+z5nd7rpHf0LhNz8/emtXzlJ+1imqcZ90Kj+MPxXPK4lHiwTmedSsMT8+zboXh6XnWrTA8Pc+6Ff5iekr5fYdc6j8KIOd81q0wPD3PuhWGp+dZt8JfTc/8fdRczteb9DxrlhqenpbpuUvP1rdm/dmTt+a7e8/P+oVlC/izxmCN430rXO2reIqUApZWXl+j0VZa/8dwl/ctLzxc71vbr4Y7/hDuevO4bHnfwsLD9b5VhYfb9grX+9bzq+H+rjS4wtX//tpiff37892Sa3nfej6eHu9Z4cfT4z0r/Oemp79q+/3OfLy7NzzrVhidnvNZt8jw9Dzr1vmr6Vn99/Scbz57zmfdUsPT86xbbXh6WqbnLj0735p7ab9/uaf0N7PCc+db8zfSs/Ot+Rvp2frWrNKzXtYn17U7+D09/fUG3/pk0fg//Mnfv/5wn/0Nzs9+0o7xezZXe4MzvXB+9pNkla8/vNp4g3Na4fywH17iFC+cn+2f1tfvUl3/J+YbnMMLp3nhdC+c4YUzvXCWF85phfPDvnSJU7xwvD6Vq9encvX6VK5en8rV61O5en0qV69P5er1qXx4fSofXp/Kh9en8uH1qXx4fSofXp/Kh9en8uH1qXx4fSofXp/KzetTuXl9KjevT+Xm9ancvD6Vm9encvP6VG5en8rN61O5eX0qd69P5e71qdy9PpV/1j/WXuO3bWgr9XiD07xwuhfO8MKZXjjLC+e0wvlZH5HGKV441QvH61N5eH0qD69P5eH1qTy8PpWH16fy8PpUnl6fyj/r32jl+O3VdqsvqQWbf1ASzvN4qX//mv3rkfdrzjff8fhZn8bnwz32CrftFW5/Urjr9+c/r2v88ybcsVe4c69w117hno8Kt4/fwx1vwv1ZP8bnw33UrUqH+6hb1Tq/zD+v8/Uu3EfdqnS47Unhnkf5PdxW3oT7qFuVDvdRtyod7qNuVefvz1Zf5/nmtdB61K1Kh/uoW5UM93zUrUqH+6Rrxr8evL/9++v/1TfhPuma8Y1w23PDPd+E+6RrxjfCfdI14xvhPuma8Y1wn3TN+Ea4T7pmyHDP15OuGd8I90nDm2+E++Bb1btwH3yrehdu2yvcrW5V52urW9X52upWdb62ulWdr71uVWWvW1V57q2q9jfhPupW9QelWSlvNoBnedStSofbnhRu7V8KtFLnu2J+1K1Kh/uoW5UO91G3Kh3uo25VOtxH3apkuPVRt6rj9fXdjHKU9SbcR92q9H+6j7pV6XAfdavS4ba9wn3UrUp/VO11q6p73arqXrequtet6tjrVnXsdas69rpVHXvdqn5WRvf5cPe6VR173aqOvW5Vx163qmOvW1Xb61bV9rpVtb1uVW2vW9XPyiQ/H+5et6q2162q7XWranvdqtpet6q+162q73Wr6nvdqvpet6oflsF+PNy9blV9r1tV3+tW1fe6VfW9blVjr1vV2OtWNfa6VY29blU/LHP+eLh73arGXreqsdetaux1qxp73armXreqR8nGv/Gf7l63qkfJxr8Rbtsr3L1uVY+SjX/jP929blWPko1/I9y9blWPko3rj6pHyca/8Z/uXreqR8nGvxFu2yvcvW5V3rLxi+83/PUah/r39fX60oTU1zsJjLdsPD5c61vVr4Zbjq+fX6qltzfhWt+qwsP1lo3Hh2t9q4oP1/pW9avh1t//fT2Oqf790ctXeo7emvr3fbavX8Tpc9Q36bS+tfHS2TKdkem0vnXy0vmoW+3n0/moW/Pn0/moW/nn0/moW/8/O53rNb/Sueo/3DvL6+X94wLAfD6qbzHIZzZGsfnMzig2ny3zGZrP7I1+JZ+/bwj6WuNdPrM5is1ndkex+cz2KDaf2R+F5tP7Z0KA+XxWf9S+7jO19vku3mf1LzreZ/UXOt62Wbxb38/b/P3zsJ1vP9+2vm9/Iz9b35+/kZ+t78PfyM/W99s2XiI/3j/AYpCfrefz38jP1vP2b+Rn7/n5Uf7QDx7v8tMyP7f52Xu+rfOz97xa5yfnz78wjxrzK599rPounzl/js1nzp9D8+n90z92Xx+rX/e3Po/yLp/5/ZzYfOb3c2Lzmd/Pic1ny3z+Qj7X7+fRPN+eR/n9nNh85vdzYvOZ/VFsPrM/+oV8rvb17/vq777f6P0bW7x8ev+IFzCf2R/F5jP7o1/Jp/z+mPfvnPG+b+/9Q2rAfGZ/9Cv3z/vnnv+az+yPYvO5kxPpX+N9VP/yjXi37i9G+fr3xzje1b/3z9MZ5Gfr+/838rP1ff4b+XnU/fyYv38f/jjffR/D+yfz/gnxPup++414H3X//Ea8z5qfl6/9YK3aoNqv68HX/fk13s0fvH9mzyA/z7p/hufH+4f8DPKz2ftQ75/++yfEu9n7UO8f//snxJvvQ//WH71/P+L9c4EG+cn3off5yfeh9/nZ+32ozI/3Tx4a5Cffh97nJ9+H3udn6+8nfCM/LfNzm598H/q3/Lx//+j9w5AG+dn7+886P3t/n1nnJ7+f/JWfiPeb3j+GCcxnfj85Np/5/eRfyKd+b+j9e6HAfLbMZ2g+8/vJsfnM7yf/Sj7le8Nn/WarQT7z/WZsPrM/Cs3ns37W9vPvDZ/1u7kG+cz+KDaf2R/F5rNlPn8hn/J9cf427y/lU76HzR/nDc5n9ke/cv+U72Hz53mD8/mo/ki+ty3P+v3cb8Sb70P/9t+Xt+8fy96/V/uN/Gx9//9Gflrm5zY/z7qfrz+8x2ztXbzPuj/reJ91v9XxPuv+qeN91vxcxvuw3w/V8T7qfijfy5dn/b7nN+Ldy+9RnvX7nt+I91n3q+j36eVhv+8Zn5/0h9znJ/0h9/lJf8htfh72+57KJ1Ae9nudOt69fCDlYb+nqeNt+f763+Z7b98/lr1/H/Mb+Ul/yH1+0h9yn5/0h9znJ/0ht/nZ+/co5fv9svfvS34jP+kPuc9P+kPu89Py/f6/5eft+/2y+e8z6vykP+Q+P+kPuc9Pfl/0Kz8B/oGSv4cYm8/8PcTgfOZ7ul/Ip3wvX/L3EIPzme/pYvPZMp+h+cz3dL+ST/VevuTvIQbnM9/TxeYz+6PYfGZ/9Av5lO/ly96///hPyGf2R7H5zP4oNp/ZH/1KPpUfozzr9y4/7nMoz/o9TYN8Zn/0K/dP5XMoD/s90M/nc6/foy/P+j1QHe/Dft8z/P3+w37fMz4/6Q+5z0/6Q+7z0/Z6b/6w3xvV8W7mA3nY74HqeDfzgTzs9zplvM/6/U3tE3jW72l+I97NfCDP+r3Lb8Tb8n36v8033r9Pf9jvV8bnJ/0h9/lJf8h9ftIfcp+fZ90npU/gYb8vqePdzAfysN9n1PHu/f5Rvr/e+/cQv5Gf9Ifc5yf9Iff52dsfIt9f7/17gt/Iz97+EJmfvX/v7xv52fv7tPL99ea/x6fzs/f3XXV+WubnNj/5fdSv/ES8H8/fvwvOZ34fNTaf+V7vF/Kp3zs/6/fvPp7P+qzf1zPIZ77Xi81nvtf7lXyq9851798H/Cfks2U+Q/OZ/VFsPrM/+oV8yvfO9WG/n/j5fGZ/FJvP7I9C8/mw35f8tN+gPuv3Kz/+Hr8+6/cxDfKZ/dGv3D/Ve/z6rN/3NMjno/oj+d6/Puv3QL8R79b9hXx/XR/2+57x+dn6/q/z87Df94zPz7Pu5+q9cH3Y74HqeJ91v9Xxts3i3cvXUR/2e5063kfdD9vxe7xtvt7F+6j73jfifdT9rdf6FW8/1pt4n/V7l9+I91H3q2/E+6j71TfifdT9qv/B19HPd59Xz/q9yD4OFe+j7lffqOdH3a++Ee+j7lffiPdR96tvxPus+5X8fH7W7xXqz+dn/Z6grudn/d7fN+J91v1Kx9s2i/dZ9yv9+fys+5X+fN7sfvWs32v7Rrybza+e9Xtn34j3Wfcr+fn8rN8L05/Pz/o9r2/Uc9ss3s3mV8/6vapvxPus+5X+fH7W/Up/Pm92v3rW7z19I97N5lfP+j2mb8S72X7wWb+XpD+fn/V7Sd+o583uV8/6vaRvxLvZ/OpZv5ekP5+f9XtJ+vP5Wb+XpOv5Wb+X9I14N5tfPev3kr4R72b7wWf9ntE3Pp83u1896/eGvhHvZvOrZ/1+0Dfi3Ww/+KzfD9Kfz8/6/aBv1HPbLN7N5lfP+r2eb8S72X7wWb+n843P583uV8/6vZtvxLvZ/OpZv0fzjXg32w8+6/di9Ofzs37/5Rv1vNn96lm/n/KNeDebXz3r90fk5/PxrN8HkZ/Px7N+v0PW8/Gs39f4Rrx7za+OV9ss3r32g8ezft/hG5/Pe92vjmf9PsI34t1rfnU86/cFvhHvXvvB41l+fv35bO3PX3W2r3ivq9E7/gbnd77/rOP4A/883vE732e+w+98P1nH2b/4W3n7+ex83/gOv/P9YbU/1E/rb34f5/hhP3kt9Yu/Vck/y+/5n7284y9w/grnP+D8Dc7f4fwDzj/h/AvOfzrzr/b7+XsFIP79OL9+rmec5Q+/rnG++cerfv3tVf/4003n3zJzWJ/sH82M9Z3ho5mxvo18NDPW95yPZqZlZv4kM9Z3s49mxvrW99HMWN8nP5oZ65vqRzOTd+A/yUzLO/CfZSbvwH+WmbwD/1lm8g78Z5lpmZk/yUzegf8sM3kH/rPM5B34zzKTd+A/y0zegf8kMz3vwH+WmbwD/1lm8g78Z5nJO/CfZaZlZv4kM3kH/rPM5B34zzKTd+A/y0zegf8sM3kH/pPMjLwD/1lm8g78Z5nJO/CfZSbvwH+WmZaZ+ZPM5B34zzKTd+A/y0zegf8sM3kH/rPM5B34TzIz8w78Z5nJO/CfZSbvwH+WmbwD/1lmWmbmTzKTd+A/y0zegf8sM3/5DjzHb/8X2jrO+8yUMr8eXJXzD+zl9TYzf0jMPP/wr9+FWsf6Let1vv7gcijrt1jXY2Jd9bdyrKv3v4v1H/91n79ZLvofIvy9BM7npOUr0nr+8fn6/520/PVfurBJy1nPr7TM/ua/GX/9Vy44nwJ//RcuHvkp8Nd/COOZnwJto0+BvtGnwMhPgXfl/pzrYOinwHNujvpT4DnXQfkpcD7njhf5KXA+5zoY+SlwPufmKD8FzudcB/WnQMtPgXfl/pzrYOinwHNujvpTYKPp4JnTwbflntPBN2lpr32mg+21z3SwvXI6+Lbcczr4Ni1to0+BfaaD7ZXTwbflntPBt2nZZzrYXvtMB1vJ6eC7ci85HXybln2mg63sMx1sf/0XVJ75KZDTwbdp2Wc62Mo+08FWcjr4ttxzOvguLXWj6WDdaDpYczr4ttxzOvg2LW2jT4GNpoM1p4Nvyz2ng2/TstF0sG40HTxyOviu3I+cDr5Ny0bTwWOj6eBf/3WiZ34K5HTwbVo2mg4eG00Hj5wOvi33nA6+S0vbaDrYNpoOtpwOvi33nA6+TUvb6FNgo+lgy+ng23LP6eDbtGw0HWw/ex2s87c/XI7XELHW1/j6D/U1lvjXq//2IbDm+ru8/Fuk/bVNpOUpkZ6v9bd//HdWrd8jrdtEemwTadsm0v6YSL8OpfPv7iRfkY5tIp3bRLq2ifQxd6TzmF+RjjeRjsfckWSkj7kjqdvgeMwdSUb6mDvSHyJdb6u3bRPpc+5I4jY4nnNHUpE+546kIn3OHUlF+pw7krgNzufckVSkz5kjqUifM0dSkT5njiRu+H/9NykwkT7mjqRu+PMxdyQZ6WPuSOqGPx9zR5KRPueOJG6D6zl3JBXpNru2tc2ubT3njiRugz/8SwqfjHSbXdvaZte2njNHEjf89Zw5kop0m+8jndt8H+l84q7t7Q3/fOKu7X2k23wf6Yd/ieCTkW6zazu32bWd23wf6dzm+0jnLru2/tpl19Zfz5kj3d/w++s5cyQV6RO/j/Tuht9fbZtIn7hrW2+r94m7tveR7vJ9pP7a5ftI/bXLrq2XXXZtvezyfaRedvk+Ui+77Nr6DzvrPxnpc+ZI4oZfnjNHUpE+8ftIb2/45YnfR3of6RN3bW9v+PWJu7b3ke7yfaRed/k+Uq+77Nr6D9vZPxnpLt9H6nWX7yP1usuurddddm297vL2vx+7vP3vxy5v//uxy9v/fuzy9r//sN38k5Hu8n2kfuzyfaR+bLNrO7bZtR3bfB+pbfN9pLbNrq1ts2tru7z97z/s8f5kpLu8/e9tl7f/ve3y9r+3Xd7+9+d4ttVt8DmebRnpNru2bTzb/UGebXEbfJBnW0W6za5tG892f5BnW9zwH+TZVpHu8va/P8ezLSPd5e1/f6Rn+32k23wf6TmebRnpNru2bTzb/UGebXEbfJBnW0W6za5tG892f5BnW9zwH+TZVpFu8/b/OZ5tGek2b/8f6dl+H+k230d6jmdbRrrNrm0bz3Z/kGdb3AYf5NlWkW6za9vGs90f5NkWN/wHebZVpNu8/X+OZ1tGus3b/0d6tt9Hus33kZ7j2ZaRbrNr28az3R/k2Ra3wQd5tlWk2+zatvFs9wd5tu9v+ONBnm0V6S5v/8dzPNsy0l3e/o9X2ybSXb6PNJ7j2ZaR7rJrG9t4tseDPNv3t8HxIM+2inSXXdvYxrM9HuTZFjf8B3m2VaS7vP0fz/Fsy0h3efs/HunZfh/pLt9HGs/xbMtId9m1jW082+NBnm1xG3yQZ1tFusuubWzj2R4P8myLG/6DPNsq0l3e/o/neLZlpLu8/R+P9Gy/j3SX7yON53i2ZaTb7Nq28WyPB3m2xW3wQZ5tFek2u7ZtPNvjQZ5tccN/kGdbRbrL2//xHM+2jHSXt//jkZ7t95Fu832k53i2ZaTb7Nq28WyPB3m2xW3wQZ5tFek2u7ZtPNvjQZ5tccN/kGdbRbrL2//xHM+2jHSXt//jkZ7t95Fu832k53i2ZaTb7Nq28WyPB3m2xW3wQZ5tFek2u7ZtPNvjQZ5tccN/kGdbRbrN2//neLZlpNu8/X+kZ/t9pNt8H+k5nm0Z6Ta7tm082+NBnm1xG3yQZ1tFus2ubRvP9niQZ1vc8B/k2VaRbvP2/zmebRnpNm//H+nZfh/pNt9Heo5nW0a6za5tG8/2eJBnW9wGH+TZVpFus2vbxrM9HuTZFjf8B3m2VaS7vP2fz/Fsy0h3efs/H+nZfh/pLt9Hmq+2TaS77NrmNp7t+SDP9v1tcD7Is60i3WXXNrfxbM8Hebbvb/jzQZ5tFekub//nczzbMtJd3v7PR3q230e6y/eR5nM82zLSXXZtcxvP9nyQZ1vcBh/k2VaR7rJrm9t4tueDPNvihv8gz7aKdJe3//M5nm0Z6S5v/+cjPdvvI93l+0jzOZ5tGek2u7ZtPNvzQZ5tcRt8kGdbRbrNrm0bz/Z8kGdb3PAf5NlWke7y9n8+x7MtI93l7f98pGf7faTbfB/pOZ5tGek2u7ZtPNvzQZ5tcRt8kGdbRbrNrm0bz/Z8kGdb3PAf5NlWke7y9n8+x7MtI93l7f98pGf7faTbfB/pOZ5tGek2u7ZtPNvzQZ5tcRt8kGdbRbrNrm0bz/Z8kGdb3PAf5NlWkW7z9v85nm0Z6TZv/x/p2X4f6TbfR3qOZ1tGus2ubRvP9nyQZ1vcBh/k2VaRbrNr28azPR/k2RY3/Ad5tlWk27z9f45nW0a6zdv/R3q230e6zfeRnuPZlpFus2vbxrM9H+TZFrfBB3m2VaTb7Nq28WzPB3m2xQ3/QZ5tFek2b/+f49mWke7y9n890rP9PtJdvo+0nuPZlpHusmtbr7ZNpLt8H2k9yLOtIt1l17a28WyvB3m272/460GebRXpLm//13M82zLSXd7+r0d6tt9Husv3kdZzPNsy0l12bWsbz/Z6kGdb3AYf5NlWke6ya1vbeLbXgzzb4ob/IM+2inSXt//rOZ5tGekub//XIz3b7yPd5ftI6zmebRnpNru2bTzb60GebXEbfJBnW0W6za5tG8/2epBnW9zwH+TZVpHu8vZ/PcezLSPd5e3/eqRn+32k23wf6TmebRnpNru2bTzb60GebXEbfJBnW0W6za5tG8/2epBnW9zwH+TZVpHu8vZ/PcezLSPd5e3/eqRn+32k23wf6TmebRnpNru2bTzb60GebXEbfJBnW0W6za5tG8/2epBnW9zwH+TZVpHu8vZ/PcezLSPd5u3/Iz3b7yPd5vtIz/Fsy0i32bVt49leD/Jsi9vggzzbKtJtdm3beLbXgzzb4ob/IM+2inSbt//P8WzLSLd5+/9Iz/b7SLf5PtJzPNsy0m12bdt4tteDPNviNvggz7aKdJtd2zae7fUgz7a44T/Is60i3ebt/3M82zLSbd7+P9Kz/T7SXb6PdD7Hsy0j3WXXdm7j2T4f5Nm+vw2er7ZNpLvs2s5tPNvngzzb9zf880GebRXpLm//z+d4tmWku7z9Px/p2X4f6S7fRzqf49mWke6yazu38WyfD/Jsi9vggzzbKtJddm3nNp7t80GebXHDf5BnW0W6y9v/8zmebRnpLm//z0d6tt9Husv3kc7neLZlpNvs2rbxbJ8P8myL2+CDPNsq0m12bdt4ts8HebbFDf9Bnm0V6S5v/8/neLZlpLu8/T8f6dl+H+k230d6jmdbRrrNrm0bz/b5IM+2uA0+yLOtIt1m17aNZ/t8kGdb3PAf5NlWkf7lO9L1X4DfIj1PEWmtffzGXscfaux4x176a/XfEtPL8Uf+8u7fX1f712//fq3yh9y8jt/irU+Kd83fSqGcr38l+EO87+qsl9+q8qq50f7w79tv+Tl2zs852+//Raz97/LzNp/9i6f2pf5+/6Lpf0jM7/9VbJn6T6W+Z+o/lfqRqf9U6mem/lOpX5n6T6X+zNR/KPV/Xc2fqf+/m/pH9Xms1G/dcn429dnNfiz1LVP/qdRnN/ux1Gc3+7HUZzf7sdRnN/ux1Gc3+6nUz+xmfyH14wv/+p/X+oup37mbHef6SuV81SJSr1K5c3c6S/2q4ln6+RdTuXO3GZzKlqmMSuXO3WBwKnfu7oJTuXO3FpzKnbuv4FTu3E3FpnLt3B0Fp3Lnbic4ldnthKUyu52wVLZMZVQqs9sJS2V2O2GpzG4nLJXZ7YSlMrudqFSe2e2EpTK7nbBUZrcTlsrsdsJS2TKVUanMbicsldnthKUyu52wVGa3E5bK7HZiUller+x2wlKZ3U5YKrPbCUtldjthqWyZyqhU7tztrFa/JFGr/Wt4f0jl3/Kzcwuz2qxf+bn+j/3FUtu5hflOqe3clwSX2s59yTdKrezcbMSWWtm52fhOqe3cQQSX2s4dxHdKrWWpRZVatgX3pZZtQVipZVtwX2rZFoSVWrYFt6VWsy2IKrWabcF9qWVbEFZq2Rbcl1rLUosqtWwL7kst24KwUsu24L7Usi0IK7VsC25L7ci2IKrUjmwL7kst24KwUsu24L7UWpZaVKllW3BfatkWhJVatgX3pZZtQVipZVtwW2ot24KoUmvZFtyXWrYFYaWWbcF9qbUstahSy7bgvtSyLQgrtWwL7kst24KwUsu24LbUerYFUaXWsy24L7VsC8JKLduC+1JrWWpRpZZtwX2pZVsQVmrZFtyXWrYFYaWWbcFtqW39O/Wxpbb1785/p9SyLQgrtWwL7kutZalFlVq2Bfellm1BWKllW3BfatkWhJVatgW3pbb1D37HltrWP+D9nVLLtiCs1LZuC2ZfX6mca74rtfaj+Tm+/rOt7VXC8zPX6yveVdbf5edv8fYnxfuL9VB7+RKy1jnau3oYO+fnnF/5OV61i4+eK5/9i6f2pf6++qiamfpPpX5l6j+V+jNT/6HU//CPdGfq/5D6kqn/VOprpv5TqT8y9Z9KfcvUfyr1W7ecn019drMfS312sx9LfXazH0t9drOfSv2Z3ezHUp/d7MdSn93sx1Kf3ewvpH58bUav/3mtv5j6tnHqx7m+UjlftYjUq1Tu3J3G/kLluXO3GZzKnbvH4FTu3A0Gp3Ln7i40leW1c7cWnMqdu6/gVO7cTQWncufuKDiVLVMZlcrsdsJSmd1OWCqz2wlLZXY7YanMbicqlSW7nbBUZrcTlsrsdsJSmd1OWCpbpjIqldnthKUyu52wVGa3E5bK7HbCUpndTlQqa3Y7YanMbicsldnthKUyu52wVLZMZVQqs9sJS2V2O2GpzG4nLJU7dztaG1bqzi1MqDbsiiFL7a7Ujp37kuBS27kv+U6p7dxsBJday1K7LbWdO4jgUtu5g/hOqe3cFgSXWrYF96WWbUFUqbVsC25LrWVbEFZq2Rbcl1q2BWGl1rLUbkst24KwUsu24L7Usi0IK7VsC+5LLduCqFLr2RbcllrPtiCs1LItuC+1bAvCSq1lqd2WWrYFYaWWbcF9qWVbEFZq2Rbcl1q2BVGlNrItuC21kW1BWKllW3BfatkWhJVay1K7LbVsC8JKLduC+1LLtiCs1LItuC+1bAuiSm1mW3BbajPbgrBSy7bgvtSyLQgrtZaldltq2RaElVq2Bfellm1BWKllW3BfatkWRJXayrbgttRWtgVhpZZtwX2pZVsQVmotS+221LItCCu1bAvuSy3bgrBSy7bgvtSyLYgqta1/1vwbpbb1b48Hl1q2Bfellm1BWKm1LLXbUsu2IKzUtm4LZl9fqZxrviu1n20L2jG+8jN6eH7men3Fu8r6u/z8Ld71pHh/sR5qL19C1jpHe1cP5875OedXfo5X7eKj58pn/+Kpfam/f/9RVX/4R7Ez9X9IfcnUfyr1NVP/qdQfmfpPpb5l6j+V+p6p/1TqR6b+U6l/VJ/HSv3WLednU5/d7KdSX7Kb/Vjqs5v9WOqzm/1Y6rOb/VjqW6b+U6nPbvZjqc9u9hdSP/r4Sv1Y6y+mfududpzrK5XzVYtIvUrlzt1p6C9U1rJztxmbyrpz9xicyp27weBU7tzdBady524tOJUtUxmVyp27qeBU7twdBady524nOJXZ7YSlMrudqFQe2e2EpTK7nbBUZrcTlsrsdsJS2TKVUanMbicsldnthKUyu52wVGa3E5bK7HaiUtmy2wlLZXY7YanMbicsldnthKWyZSqjUpndTlgqs9sJS2V2O2GpzG4nLJXZ7USlsme3E5bKnbsdrQ2rfecWJlQbVvvOLcx3Sq1lqUWV2s59yXdKbedmI7jUdm42vlNqO3cQwaW2cwfxjVIbO7cFsaU2si24L7VsC8JKLduC+1JrWWpRpZZtwX2pZVsQVmrZFtyXWrYFYaWWbcFtqc1sC6JKbWZbcF9q2RaElVq2Bfel1rLUokot24L7Usu2IKzUsi24L7VsC8JKLduC21Jb2RZEldrKtuC+1LItCCu1bAvuS61lqUWVWrYF96WWbUFYqWVbcF9q2RaElVq2BbeldmZbEFVqZ7YF96WWbUFYqWVbcF9qLUstqtSyLbgvtWwLwkot24L7Usu2IKzUsi24K7XjlW1BUKkdr2wL7kst24KwUsu24L7UWpZaVKllW3BfatkWhJVatgX3pZZtQVipZVtwW2pb/yJ7bKlt/Qvr3ym1bAvCSi3bgvtSa1lqUaWWbcF9qWVbEFZq2Rbcl1q2BWGltnVbMPv6SuVc802p/fBPbffX67f89HqG52eu11e8q6y/y8/f4i1PivcX66H28iVkrXO0d/VQd87POb/ycy03uvjo+Vd74xdP7Uv9ffFR9cM/ip2p/0PqW6b+U6nvmfpPpX5k6j+V+pmp/1TqV6b+U6k/M/UfSv3xqD6PlfqtW87Ppj672Y+lPrvZj6W+Zeo/lfrsZj+W+uxmP5b67GY/lvrsZj+W+uxmfyH1o4+v1I+1/lrq287d7DjXVyrnqxaRepXKnbvT0F+oPNrO3WZwKnfuHoNT2TKVUancubsLTuXO3VpwKnfuvoJTuXM3FZzKnbuj2FT2nbud4FRmtxOWyux2wlKZ3U5YKlumMiqV2e2EpTK7nbBUZrcTlsrsdsJSmd1OVCpHdjthqcxuJyyV2e2EpTK7nbBUtkxlVCqz2wlLZXY7YanMbicsldnthKUyu52oVM7sdsJSmd1OWCqz2wlLZXY7YalsG6fyG9qwuXMLE6sNmzu3MN8ptZ37kuBS27kv+U6p7dxsxJba2rnZ+EaprZ07iOBS27mD+E6p7dwWBJday1K7LbVsC8JKLduC+1LLtiCs1LItuC+1bAuiSu3MtuC21M5sC8JKLduC+1LLtiCs1FqW2m2pZVsQVmrZFtyXWrYFYaWWbcF9qWVbEFRq7ZVtwV2ptVe2BWGllm3BfallWxBWai1L7bbUsi0IK7VsC+5LLduCsFLLtuC+1LItiCq1km3BbamVbAvCSi3bgvtSy7YgrNRaltptqWVbEFZq2Rbcl1q2BWGllm3BfallWxBVajXbgttSq9kWhJVatgX3pZZtQViptSy121LLtiCs1LItuC+1bAvCSi3bgvtSy7YgqtS2/t35b5Ta1j8OH1xq2Rbcl1q2BWGl1rLUbkst24KwUsu24L7Usi0IK7VsC+5LLduCqFLb+ge8v1FqW/8qd3Cpbd0WzL6+UjnXfFdqP9wWjP6Vn7OF52eu11e8q6y/y8/f4m1PivcX66H28iVkrXO0d/XQd87POb/yc7xqFx89Vz77F0/tS/199VE1MvWfSv3M1H8q9StT/6nUn5n6D6X+p3/UO1P/e+pLpv5Tqa+Z+k+l/lF9Hiv1LVP/qdRnN/ux1Gc3+7HUZzf7sdRnN/ux1Gc3+6nUj+xmP5b67GY/lvrsZn8h9aOPr9SPtf5i6nfuZse5vlI5X7WI1KtUto1TGfoLlW3s3G0Gp3Ln7jE4lTt3g8Gp3Lm7C07lzt1abCrnzt1XcCp37qaCU7lzdxScyp27neBUtkxlVCqz2wlLZXY7YanMbicsldnthKUyu52oVK7sdsJSmd1OWCqz2wlLZXY7YalsmcqoVGa3E5bK7HbCUpndTlgqs9sJS2V2O1GpPLPbCUtldjthqcxuJyyV2e2EpbJlKqNSmd1OWCqz2wlL5c7dzje0YefOLUysNuzcuYXRpdZfO/cloaXWXzv3Jd8ptZ2bjeBS27nZ+E6ptSy1qFLbuYP4Tqnt3BYEl1q2Bfellm1BWKllW3BbaiXbgqhSK9kW3JdatgVhpZZtwX2ptSy1qFLLtuC+1LItCCu1bAvuSy3bgrBSy7bgttRqtgVRpVazLbgvtWwLwkot24L7UmtZalGllm3BfallWxBWatkW3JdatgVhpZZtwW2pHdkWRJXakW3BfallWxBWatkW3Jday1KLKrVsC+5LLduCsFLLtuC+1LItCCu1bAtuS61lWxBVai3bgvtSy7YgrNSyLbgvtZalFlVq2Rbcl1q2BWGllm3BfallWxBWatkW3JZaz7YgqtR6tgX3pZZtQVipZVtwX2otSy2q1LItuC+1bAvCSi3bgvtSy7YgrNSyLbgtta1/ezy21Lb+LfHvlFq2BWGllm3Bfam1LLWoUtu6LZh9faVyrvmu1H62LRjH67f8jD8KQYPyM9frK95V1t/l52/xzifF+4v1UHv5ErLWOdq7elg75+ecX/k5XrWLj54rn/2Lp/al/r76qDoz9R9K/Q//iHam/g+pL5n6T6W+Zuo/lfojU/+p1LdM/adS3zP1n0r9o/o8Vuq3bjk/m/rsZj+W+uxmP5X6ld3sx1Kf3ezHUp/d7MdSn93sx1LfMvWfSn12s7+Q+tHHV+rHWn8x9Tt3s+NcX6mcr1pE6lUqd+5OQ3+hsq+du83gVO7cPcam8ty5GwxO5c7dXXAqd+7WglO5c/cVnMqWqYxK5c7dUXAqd+52glOZ3U5YKrPbCUtldjtBqRyv7HbCUpndTlgqs9sJS2V2O2GpbJnKqFRmtxOWyux2wlKZ3U5YKrPbCUtldjtRqSzZ7YSlMrudsFRmtxOWyux2wlLZMpVRqcxuJyyV2e2EpTK7nbBUZrcTlsrsdqJSWXfudrQ2bNSdW5hQbdioO7cw3ym1nfuS4FJrWWq3pbZzsxFcajs3G98ptZ07iOBS27mD+E6p7dwWxJbakW3Bbakd2RaElVq2Bfellm1BWKm1LLXbUsu2IKzUsi24L7VsC8JKLduC+1LLtiCq1Fq2Bbel1rItCCu1bAvuSy3bgrBSa1lqt6WWbUFYqWVbcF9q2RaElVq2Bfellm1BVKn1bAtuS61nWxBWatkW3JdatgVhpday1G5LLduCsFLLtuC+1LItCCu1bAvuSy3bgqhSG9kW3JbayLYgrNSyLbgvtWwLwkqtZandllq2BWGllm3BfallWxBWatkW3JdatgVRpTazLbgttZltQVipZVtwX2rZFoSVWstSuy21bAvCSi3bgvtSy7YgrNSyLbgvtWwLokpt619Y/0apbf0z6MGllm3BfallWxBWai1L7bbUsi0IK7VsC+5LLduCsFLbui2YfX2lcq75rtR+uC04fwu4ztrC8zPX6yveVdbf5eff4v3p38P+58b7i/VQe/kSstY52pt6+OkfufbKzzm/8nO8ahcfPVc++xdP7Uv9ffFR9dM/ip2p/z31R6b+U6lvmfpPpb5n6j+V+pGp/1TqZ6b+U6lfmfpPpf5RfR4p9fO1dcv52dRnN/ux1Gc3+7HUZzf7sdS3TP2nUp/d7MdSn93sx1Kf3ezHUp/d7C+kfvTxlfprK/sXU79zN3uNUb5SeV2zi0i9SGXZuTsN/YXKWXbuNoNTuXP3GJzKnbvB4FS2TGVUKnfu1oJTuXP3FZzKnbup4FTu3B0Fp3Lnbic2lTW7nbBUZrcTlsrsdsJSmd1OWCpbpjIqldnthKUyu52wVGa3E5bK7HbCUpndTlQqj+x2wlKZ3U5YKrPbCUtldjthqWyZyqhUZrcTlsrsdsJSmd1OWCqz2wlLZXY7Uals2e2EpTK7nbBUZrcTlsqdux2tDZutbZ2fQG3YbDu3MN8ptZ37kuBS27kv+U6p7dxsBJfazs3GN0qt79xBxJZa37mD+E6p7dwWBJdatgX3pday1KJKLduC+1LLtiCs1LItuC+1bAvCSi3bgttSG9kWRJXayLbgvtSyLQgrtWwL7kutZalFlVq2Bfellm1BWKllW3BfatkWhJVatgW3pTazLYgqtZltwX2pZVsQVmrZFtyXWstSiyq1bAvuSy3bgrBSy7bgvtSyLQgrtWwLbkttZVsQVWor24L7Usu2IKzUsi24L7WWpRZVatkW3JdatgVhpZZtwX2pZVsQVmrZFtyW2pltQVSpndkW3JdatgVhpZZtwX2ptSy1qFLLtuC+1LItCCu1bAvuSy3bgrBSy7bgrtTW1j8OH1pqa+sfe/9OqWVbEFZq2Rbcl1rLUosqtWwL7kst24KwUsu24L7Usi0IK7VsC25Lbetf5Y4tta1/lXvNvr5Sea2D35Xaz7YFc5Sv/Jyv8PzM9fqKd5X1d/n5W7zHk+L9xXqovXwJWS+09q4e2s75OedXfo5X7eKj58pn/+Kpfam/rz6qeqb+U6kfmfpPpX5m6j+V+pWp/1Tqz0z9h1L/wz8Cnqn/Q+pLpv5TqX9Un8dK/dYt52dT3zL1n0p9drMfS312sx9LfXazH0t9drMfS312s59K/ZHd7MdSn93sL6R+9PGV+rHWX0z9zt3sONdXKuerFpF6lcqdu9PQX6hcP/wj8o9O5c7dY3Aqd+4Gg1O5c3cXnMqdu7XgVO7cfcWmsu3cTQWncufuKDiVO3c7wanMbicslS1TGZXK7HbCUpndTlgqs9sJS2V2O2GpzG4nKpU9u52wVGa3E5bK7HbCUpndTlgqW6YyKpXZ7YSlMrudsFRmtxOWyux2wlKZ3U5UKkd2O2GpzG4nLJXZ7YSlMrudsFS2TGVUKrPbCUvlzt3ON7RhY+cWJlYbNnZuYb5Tajv3JbGlNnfuS75RanPnZiO41HZuNr5Tajt3EMGl1rLUbktt57YguNSyLbgvtWwLwkot24L7Usu2IKrUVrYFt6W2si0IK7VsC+5LLduCsFJrWWq3pZZtQVipZVtwX2rZFoSVWrYF96WWbUFUqZ3ZFtyW2pltQVipZVtwX2rZFoSVWstSuy21bAvCSi3bgvtSy7YgrNSyLbgvtWwLgkrtfGVbcFdq5yvbgrBSy7bgvtSyLQgrtZaldltq2RaElVq2Bfellm1BWKllW3BfatkWRJVaybbgttRKtgVhpZZtwX2pZVsQVmotS+221LItCCu1bAvuSy3bgrBSy7bgvtSyLYgqtZptwW2pbf079cGllm3BfallWxBWai1L7bbUsi0IK7VsC+5LLduCsFLLtuC+1LItiCq1rX9L/BultvUPfgeXWrYF96WWbUFYqbWdUzn7+krlXPNdqf1sW7Dq/C0/q4/w/Mz1+op3lfV3+flbvONJ8f5iPdRevoSsV6m2d/Uwd87POb/yc7xqFx89Vz77F0/tS/199VG1MvWfSv2Zqf9Q6n/4R7cz9X9IfcnUfyr1NVP/qdQfmfpPpb5l6j+V+kf1eazUb91yfjb12c1+LPXZzX4s9dnNfir1PbvZj6U+u9mPpT672Y+lPrvZj6W+Zeq/n/rRx1fqx1p/MfU7d7PjXF+pnK9aROpVKnfuTkN/ofLsO3ebwancuXsMTuXO3WBsKsfO3V1wKnfu1oJTuXP3FZzKnbup4FS2TGVUKnfudoJTmd1OWCqz2wlLZXY7YanMbicqlTO7nbBUZrcTlsrsdsJSmd1OWCpbpjIqldnthKUyu52wVGa3E5bK7HbCUpndTlQqV3Y7YanMbicsldnthKUyu52wVLZMZVQqs9sJS2V2O2GpzG4nLJXZ7YSlcudu5xvasHPnFiZWG3bu3MJ8p9R27kuCS23nvuQ7pday1KJKbedm4zultnMHEVxqO3cQ3ym1nduC4FLLtuCm1OrrlW1BTKldqcy24L7Usi0IK7VsC+5LrWWpRZVatgX3pZZtQVipZVtwX2rZFoSVWrYFt6VWsi2IKrWSbcF9qWVbEFZq2Rbcl1rLUosqtWwL7kst24KwUsu24L7Usi0IK7VsC25LrWZbEFVqNduC+1LLtiCs1LItuC+1lqUWVWrZFtyXWrYFYaWWbcF9qWVbEFZq2RbcltqRbUFUqR3ZFtyXWrYFYaWWbcF9qbUstahSy7bgvtSyLQgrtWwL7kst24KwUsu24LbUWrYFUaXWsi24L7VsC8JKLduC+1JrWWpRpZZtwX2pZVsQVmrZFtyXWrYFYaWWbcFtqW39M+ixpbb1z5p/p9SyLQgrtWwL7kutZalFlVq2Bfellm1BWKlt3RbMvr5SOdd8V2o/3BacvwVQz1rD8zPX6yveVdbf5edv8Z5PivcX66H28iVkrXO0N/Xw0z9y7ZWfc37l53jVLj56rnz2L57al/r74qPqp38UO1P/e+prpv5TqT8y9Z9KfcvUfyr1PVP/qdSPTP2nUj8z9Z9K/aP6PFbqt245P5r6md3sx1Kf3ezHUp/d7MdSn93sx1LfMvWfSn12sx9LfXazH0t9drO/kPrRx1fqx1p/MfU7d7PjXF+pnK9aROpVKnfuTiN/obK+1s7dZnAqd+4eg1O5czcYnMqdu7vgVLZMZVQqd+6+glO5czcVnMqdu6PgVO7c7QSnMrudqFSe2e2EpTK7nbBUZrcTlsrsdsJS2TKVUanMbicsldnthKUyu52wVGa3E5bK7HaCUlle2e2EpTK7nbBUZrcTlsrsdsJS2TKVUanMbicsldnthKUyu52wVGa3E5bK7HaiUlmy2wlLZXY7YancudvR2rBSdm5hQrVhpbQstdtS27kvCS61nfuS75Tazs1GcKnt3Gx8p9R27iBiS63u3EF8o9Tqzm1BcKllW3BfatkWhJVay1K7LbVsC8JKLduC+1LLtiCs1LItuC+1bAuiSu3ItuC21I5sC8JKLduC+1LLtiCs1FqW2m2pZVsQVmrZFtyXWrYFYaWWbcF9qWVbEFVqLduC21Jr2RaElVq2Bfellm1BWKm1LLXbUsu2IKzUsi24L7VsC8JKLduC+1LLtiCq1Hq2Bbel1rMtCCu1bAvuSy3bgrBSa1lqt6WWbUFYqWVbcF9q2RaElVq2Bfellm1BVKmNbAtuS21kWxBWatkW3JdatgVhpday1G5LLduCsFLLtuC+1LItCCu1bAvuSy3bgqhS2/rH3r9Ralv/IntwqWVbcF9q2RaElVrLUrsttWwLwkot24L7Usu2IKzUsi24L7VsC6JKbetf5V6zr69UzjXflNoP/9T2OV5f+VlneH7men3Fu8r6u/z8Ld76pHh/sR5qL19C1jpHe1cPx875OedXfo5X7eKj58pn/+Kpfam/rz6qWqb+U6nvmfpPpX5k6j+V+pmp/1TqV6b+U6k/M/UfSv0P/2h4pv4PqX9Un8dK/dYt52dTn93sx1LfMvWfSn12sx9LfXazH0t9drMfS312sx9LfXazH0p9fWU3+wupH318pX6s9RdTv3M3O871lcr5qkWkXqVy5+409Bcq62vnbjM4lS1TGZXKnbvB4FTu3N0Fp3Lnbi04lTt3X8Gp3Lmbik1l2bk7Ck7lzt1OcCqz2wlLZXY7YalsmcqoVGa3E5bK7HbCUpndTlgqs9sJS2V2O1GprNnthKUyu52wVGa3E5bK7HbCUtkylVGpzG4nLJXZ7YSlMrudsFRmtxOWyux2olJ5ZLcTlsrsdsJSmd1OWCqz2wlLZctURqVy525Ha8PqsXMLE6oNq8fOLcx3Sm3nviS41HbuS75Ram3nZiO21NrOzcZ3Sm3nDiK41HbuIL5Tai1LLarUsi24L7VsC8JKLduC+1LLtiCs1LItuC21nm1BVKn1bAvuSy3bgrBSy7bgvtRallpUqWVbcF9q2RaElVq2Bfellm1BWKllW3BbaiPbgqhSG9kW3JdatgVhpZZtwX2ptSy1qFLLtuC+1LItCCu1bAvuSy3bgrBSy7bgttRmtgVRpTazLbgvtWwLwkot24L7UmtZalGllm3BfallWxBWatkW3JdatgVhpZZtwW2prWwLokptZVtwX2rZFoSVWrYF96XWstSiSi3bgvtSy7YgrNSyLbgvtWwLwkot24LbUtv6d+pjS23r353/TqllWxBWatkW3Jday1KLKrVsC+5LLduCsFLLtuC+1LItCCu1bAvuSu3Y+ge/Q0vt2PoHvL9TatkWhJXa1m3B7OsrlXPNd6XWfjI/V2XP3/7wq4/w/Mz1+op3lfV3+flbvP1J8f5iPdRevoSsdY72rh7Gzvk551d+LrQuPnqufPYvntqX+vvqo2pm6j+V+pWp/1Tqz0z9h1L/sz/Snan/Y+pLpv5Tqa+Z+k+l/sjUfyr1LVP/qdRv3XJ+NvXZzX4s9dnNfiz12c1+LPXZzX4q9TW72Y+lPrvZj6U+u9mPpT672V9I/ejjK/Vjrb+Y+rZx6se5vlI5X7WI1KtU7tydhv5C5VF37jaDU7lz9xicyp27weBU7tzdxaby2LlbC07lzt1XcCp37qaCU7lzdxScypapjEpldjthqcxuJyyV2e2EpTK7nbBUZrcTlcqW3U5YKrPbCUtldjthqcxuJyyVLVMZlcrsdsJSmd1OWCqz2wlLZXY7YanMbicqlT27nbBUZrcTlsrsdsJSmd1OWCpbpjIqldnthKUyu52wVGa3E5bKnbudb2jD+s4tTKw2bOzcwnyj1MbOfUlwqe3cl3yn1HZuNoJLrWWp3Zbazh1EcKnt3EF8p9R2bguCSy3bgvtSy7YgqtRmtgW3pTazLQgrtWwL7kst24KwUmtZarellm1BWKllW3BfatkWhJVatgX3pZZtQVSprWwLbkttZVsQVmrZFtyXWrYFYaXWstRuSy3bgrBSy7bgvtSyLQgrtWwL7kst24KoUjuzLbgttTPbgrBSy7bgvtSyLQgrtZaldltq2RaElVq2Bfellm1BWKllW3BfatkWBJVae2VbcFdq7ZVtQVipZVtwX2rZFoSVWstSuy21bAvCSi3bgvtSy7YgrNSyLbgvtWwLokqtZFtwW2ol24KwUsu24L7Usi0IK7WWpXZbatkWhJVatgX3pZZtQVipZVtwX2rZFkSV2tY/a/6NUtv6t8eDSy3bgvtSy7YgrNRaltptqWVb8H+yd3fJkSM5kICvlPEfcf+LLWVbpa62FRLZNlgSXu5v8yBrIzEeAsCiPoZFjXotWGN/l3Lt9VPUbl4Lzm8RtJXawuuz9uv7fnfZ/6rPr/vdf9P9/sc81FG+Qda6Zv8pD4e5Pmd91+c6ysP51XPVc3xfTx3b++87v6ru/ii2Sv9P6YtK/1Tpq0r/VOmbSv9U6btK/1Tph0r/VOmnSv9U6f+qPQ+r9NQr57Ol1zb7VOm7ttnHSq9t9rHSa5t9rPTaZh8rfVfpnyq9ttnHSq9t9j+Ufo75Xfq59/9YeuZtdp79Xcr1qsUpvVdK5u009AuVvTNvm7GlHMzbY3ApmbfB4FIyb3fBpWTe1oJL2VXKqFIyb1PBpWTejoJLybztBJdS205YKbXtRJVyatsJK6W2nbBSatsJK6W2nbBSdpUyqpTadsJKqW0nrJTadsJKqW0nrJTadqJKubTthJVS205YKbXthJVS205YKbtKGVVKbTthpdS2E1ZKbTthpdS2E1ZKbTtRpdzadsJKybztfMCGbeYVJpYN28wrzCdR64paVNSY95JPosa8bARHjXnZ+CRqzBtEcNSYN4gPonaY14LYqB2tBe+jprUgLGpaC95HrStqUVHTWvA+aloLwqKmteB91LQWhEVNa8G7qI2X1oKgqI2X1oL3UdNaEBY1rQXvo9YVtaioaS14HzWtBWFR01rwPmpaC8KiprXgbdSK1oKoqBWtBe+jprUgLGpaC95HrStqUVHTWvA+aloLwqKmteB91LQWhEVNa8HbqFWtBVFRq1oL3kdNa0FY1LQWvI9aV9Sioqa14H3UtBaERU1rwfuoaS0Ii5rWgrdRa1oLoqLWtBa8j5rWgrCoaS14H7WuqEVFTWvB+6hpLQiLmtaC91HTWhAWNa0Fb6NG/UX22KhRf2H9k6hpLQiLmtaC91HrilpU1LQWvI+a1oKwqGkteB81rQVhUaNeC9bY36Vce/0QtZs/tV1m+a7PeYXXZ+3X9/3usv9Vn1/3W/6m+/2Pefh66fr3z9c1+095qMz1Oeu7Pu1Vh/Or56tc39dTx/b++86vqps/iq3S/1H6rtI/Vfqh0j9V+qnSP1X6pdI/Vfqt0j9V+qPSP1T6+VfteVilp145ny29ttnHSq9t9rHSd5X+qdJrm32s9NpmHyu9ttnHSq9t9rHSa5v9D6WfY36Xfu79v5V+MW+z8+zvUq5XLU7pvVIyb6ehX6gci3nbDC4l8/YYXMquUkaVknm7Cy4l87YWXErm7Su4lMzbVHApmbej2FJu5m0nuJTadsJKqW0nrJTadsJK2VXKqFJq2wkrpbadsFJq2wkrpbadsFJq24kq5dG2E1ZKbTthpdS2E1ZKbTthpewqZVQpte2ElVLbTlgpte2ElVLbTlgpte0ElXK+tO2ElVLbTlgpte2ElVLbTlgpO3EpfTZsvphXmFA2bL6YV5hPosa8lwRHjXkv+SRqzMtGbNQK87LxQdQK8wYRHDXmDeKTqDGvBcFR64ra26hpLQiLmtaC91HTWhAWNa0F76OmtSAqalVrwduoVa0FYVHTWvA+aloLwqLWFbW3UdNaEBY1rQXvo6a1ICxqWgveR01rQVTUmtaCt1FrWgvCoqa14H3UtBaERa0ram+jprUgLGpaC95HTWtBWNS0FryPmtaCqKh1rQVvo9a1FoRFTWvB+6hpLQiLWlfU3kZNa0FY1LQWvI+a1oKwqGkteB81rQVRURtaC95GbWgtCIua1oL3UdNaEBa1rqi9jZrWgrCoaS14HzWtBWFR01rwPmpaC6KiRv3d+Q+iRv1x+OCoaS14HzWtBWFR64ra26hpLQiLmtaC91HTWhAWNa0F76OmtSAqatQf8P4gatRf5Q6OGvVasMb+LuXa66eo3bsW1O/stzp2eH3Wfn3f7y77X/X5db/9b7rf/5iHOso3yFrX7D/lYTDX56zv+rRXHc6vnque4/t6vr7j6Pz3vV9VU6V/qvRLpX+q9Fulf6r0R6V/qPQ3f9Rbpf+j9EWlf6r0VaV/qvR/1Z6HVfqu0j9Vem2zj5Ve2+xjpdc2+1jptc0+Vnpts0+V/mibfaz02mYfK7222f9Q+jnmd+mvNvk/lp55m51nf5dyvWpxSu+VshOXMvYLlYd52wwuJfP2GFxK5m0wuJTM211wKZm3tdBSrhfz9hVcSuZtKriUzNtRcCmZt53gUnaVMqqU2nbCSqltJ6yU2nbCSqltJ6yU2naiSlm07YSVUttOWCm17YSVUttOWCm7ShlVSm07YaXUthNWSm07YaXUthNWSm07UaWs2nbCSqltJ6yU2nbCSqltJ6yUXaWMKqW2nbBSatsJKyXztuOzYasyrzChbNiqzCvMB1FrzHtJbNQa817ySdSYl43gqDEvG59ErStqUVFj3iA+iRrzWhAcNa0F76OmtSAsaloL3katay2IilrXWvA+aloLwqKmteB91LqiFhU1rQXvo6a1ICxqWgveR01rQVjUtBa8jdrQWhAVtaG14H3UtBaERU1rwfuodUUtKmpaC95HTWtBWNS0FryPmtaCsKhpLXgbtam1ICpqU2vB+6hpLQiLmtaC91HrilpU1LQWvI+a1oKwqGkteB81rQVhUdNa8DZqS2tBVNSW1oL3UdNaEBY1rQXvo9YVtaioaS14HzWtBWFR01rwPmpaC8KiprXgbdS21oKoqG2tBe+jprUgLGpaC95HrStqUVHTWvA+aloLwqKmteB91LQWhEVNa8HbqFF/ezw2atTfEv8kaloLwqKmteB91LqiFhU16rVgjf1dymts/SlqN68FZ/3+D7c6w+tzPSb8vt9d9r/q8+t+1990v/8xD3WUb5D161XFn/Kwmetz1nd92qsO51fPVc/xfT3Xcff++96vqqPSP1P6ffdHtFX6f0pfVPqnSl9V+qdK31T6p0rfVfqnSj9U+qdK/1fteVilp145ny29ttnHSq9t9qnSF22zj5Ve2+xjpdc2+1jptc0+Vvqu0j9Vem2z/6H0c8zv0s+9/8fSM2+z8+zvUq5XLU7pvVIyb6ehX6jchXnbDC4l8/YYW8rKvA0Gl5J5uwsuJfO2FlxK5u0ruJRdpYwqJfN2FFxK5m0nuJTadsJKqW0nrJTadqJK2bTthJVS205YKbXthJVS205YKbtKGVVKbTthpdS2E1ZKbTthpdS2E1ZKbTtRpezadsJKqW0nrJTadsJKqW0nrJRdpYwqpbadsFJq2wkrpbadsFJq2wkrpbadqFIO5m3HZ8P2YF5hQtmwPZhXmE+ixryXBEetK2pvo8a8bARHjXnZ+CRqzBtEcNSYN4hPosa8FsRGbWoteBu1qbUgLGpaC95HTWtBWNS6ovY2aloLwqKmteB91LQWhEVNa8H7qGktiIra0lrwNmpLa0FY1LQWvI+a1oKwqHVF7W3UtBaERU1rwfuoaS0Ii5rWgvdR01oQFbWtteBt1LbWgrCoaS14HzWtBWFR64ra26hpLQiLmtaC91HTWhAWNa0F76OmtSAqakdrwduoHa0FYVHTWvA+aloLwqLWFbW3UdNaEBY1rQXvo6a1ICxqWgveR01rQVDUzktrwbuonZfWgrCoaS14HzWtBWFR64ra26hpLQiLmtaC91HTWhAWNa0F76OmtSAqatRfWP8gatSfQQ+OmtaC91HTWhAWta6ovY2a1oKwqGkteB81rQVhUaNeC9bY36Vce/0UtXvXgnZ+f7y+9TLC67P26/t+d9n/qs//vd+bv4f9//l+/2Me6ijfIGtds/+Qh5s/cp2sPmd916e96nB+9Vz1HN/XU8f2/vvOr6qbP4qt0v9R+qbSP1X6rtI/Vfqh0j9V+qnSP1X6pdI/Vfqt0j9V+r9qz4MqfaNeOZ8tvbbZx0qvbfax0mubfaz0XaV/qvTaZh8rvbbZx0qvbfax0mub/Q+ln2N+l37u/T+WnnmbnWd/l3K9anFK75SyM2+noV+oPJ152wwuJfP2GFxK5m0wuJRdpYwqJfO2FlxK5u0ruJTM21RwKZm3o+BSMm87saUc2nbCSqltJ6yU2nbCSqltJ6yUXaWMKqW2nbBSatsJK6W2nbBSatsJK6W2nahSTm07YaXUthNWSm07YaXUthNWyq5SRpVS205YKbXthJVS205YKbXthJVS205UKZe2nbBSatsJK6W2nbBSMm87H7Bhq1PXJ5INW8wrzCdRY95LgqPGvJd8EjXmZSM4aszLxgdR28wbRGzUNvMG8UnUmNeC4KhpLXgfta6oRUVNa8H7qGktCIua1oL3UdNaEBY1rQVvo3a0FkRF7WgteB81rQVhUdNa8D5qXVGLiprWgvdR01oQFjWtBe+jprUgLGpaC95Erb1eWgtionaVUmvB+6hpLQiLmtaC91HrilpU1LQWvI+a1oKwqGkteB81rQVhUdNa8DZqRWtBVNSK1oL3UdNaEBY1rQXvo9YVtaioaS14HzWtBWFR01rwPmpaC8KiprXgbdSq1oKoqFWtBe+jprUgLGpaC95HrStqUVHTWvA+aloLwqKmteB91LQWhEVNa8HbqFF/HD42atQfe/8kaloLwqKmteB91LqiFhU1rQXvo6a1ICxqWgveR01rQVjUtBa8jRr1V7ljo0b9Ve69xv4u5drrp6jduxaM/vv/2zbmcuozaym/fnrWUb3q/JGbfl5/3Ov8KTa9vX7npvf5Z3D+3x9ep/yuxzpt/ZCypioGVLGrigFVHKpiQBWnqhhQxaUqBlRxq4oBVTyq4v9exZs/of23VrGoigFV1O4SUUXtLhFV7KpiQBW1u0RUUbtLRBW1u0RUUbtLRBW1uwRUcWp3iaiidpeIKmp3iaiidpeIKnZVMaCK2l0iqqjdJaKK2l0iqqjdJaKK2l0Cqri0u0RUUbtLRBW1u0RUUbtLRBW7qhhQRe0uEVXU7hJRRe0uEVXU7hJRRe0uAVXc2l0iqqjdJaKK2l0iqqjdJaKKXVUMqKJ2l4gqaneJqKJ2l4gqaneJqKJ2l4AqHu0uEVXU7hJRRe0uEVXU7hJRxa4qBlRRu0tEFbW7RFRRu0tEFbW7RFRRu8v/XsXy0u4SUUXtLhFV1O4SUUXtLhFV7KpiQBW1u0RUUbtLRBW1u0RU8e/ZXeb3rZbZy71V/Ht2lwerWP6e3eXJKv49u8uTVfx7dpcnq/j37C5PVrGrigFV/Ht2lyer+PfsLk9W8e/ZXZ6sonaXiCpqdwmoYtXuElFF7S4RVdTuElFF7S4RVez3VnH9/rhSm837FtOY30V81X/97K9rH8DXPoGvfQFf+wa+9oN77Td/VTv22gvwtVfga2/A1w7cVxtwX23AfbUB99UG3FcbcF/twH21A/fVDtxXO3Bfvft7pKHXDtxXO3Bf7cB9tQP31Q7cVwdwXx3AfXUA99UB3Ffv/lZe6LUD99WRuK+u+fsfGvar/3Ttifuqe+2J+6p77Yn7qnftM3Ffda89cV91rz1xX3WvPXFfda89cV91rz1xX3WvHbivTuC+OoH76gTuqwu4ry7gvrqA++oC7qt3f2Mk9NoT99Vdf//wHj/tqytxXy3Xb5JfP13KH//pP64+cWf94OoT99YPrj5xd/Wvfifurx9cfeIO+8HVJ+6xH1x94i77wdUn7rMfXH3iTvvB1UP32g3dazd0r93QvfZA99oD3WsPdK890L32br85+Oqhe+2B7rUHutce6F57kHttfSH32vpC7rX1hdxr6wu519YXcq+tL+ReW1/Ivba+kHttfSH32vqC7rUFutcW6F5boHttge61d/t4wVcP3WsLdK8t0L22QPfaAt1rK3SvrdC9tkL32grdazN7Th9cPXSvzWw6fXD10L02s+v0wdVD99rMttMHVw/dazP7Th9cPXSvzWw8fXD10L02s/P0wdVD99rM1tMHVw/dazN7Tx9cPXSvzWw+fXD10L02s/v0wdVD99rM9tMHVw/dazP7Tx9cPXSvzWxAfXD10L02swP1wdVD99rMFtQHVw/dazN7UB9cPXSvzWxCfXD10L02swv1wdVD99rMNtQHVw/dazP7UB9cPXSvzWxEfXD10L02sxP1wdVD99rMVtQHVw/dazN7UR9cPXSvzWxGfXD10L0W2o2q0G5UhXajKrQbVaHdqArtRlVoN6pCu1EV2o2q0G5UhXajKrQbVaHdqArtRlVoN6pCu1EV2o2q0G5UhXajKrQbVaHdqArtRlVoN6pCu1EN2o1q0G5Ug3ajGrQb1V7IvbZBu1EN2o1q0G5Ug3ajGrQb1aDdqAbtRjVoN6pBu1EN2o1q0G5Ug3ajGrQb1aDdqAbtRjVoN6pBu1EN2o1q0G5Ug3ajGrQb1aDdqAbtRjVoN6pBu1EN2o1q0G5Ug3ajGrQb1aDdqAbtRjVoN6pBu1EN2o1q0G5Ug3ajGrQb1aDdqAbtRjVoN6pBu1EN2o1q0G5Ug3ajGrQb1aDdqAbtRjVoN6pBu1EN2o1q0G5Ug3ajGrQb1aDdqAbtRjVoN6pBu1EN2o1q0G5Ug3ajGrQb1aDdqAbtRjVoN6pBu1EN2o1q0G5Ug3ajGrQb1aDdqAbtRjVoN6pBu1EttRtVd/199e21f7r6zL227fX76ntpP1z9z25U77//L+uzvL/60cfvCxp9Ole/V/t9q3ut158//OtySq7Lqbkup+W6nJ7rckauy5m5Lmflupyd63JOqss5uX4rn1y/lU+u38on12/lk+u38sn1W/nk+q18cv1WPrl+K59Uv5X7K9Vv5f5K9Vu5v1L9Vu6vVL+V+yvVb+X+SvVbub9S/Vbur1S/lfsr1W/l/sr1W7nk+q1ccv1WLrl+K5dcv5VLrt/KJddv5ZLrt3LJ9Vu55PqtXHL9Vq65fivXXL+Va67fyjXXb+Wa67dyzfVbueb6rVxz/VauuX4r11y/lVuu38ot12/lluu3csv1W7nl+q3ccv1Wbrl+K7dcv5Vbrt/KLddv5Z7rt3LP9Vu55/qt3HP9Vu65fiv3XL+Ve67fyj3Xb+We67dyz/VbeeT6rTxy/VYeuX4rj1y/lUeu38oj12/lkeu38sj1W3nk+q08cv1Wnrl+K89cv5Vnrt/KM9dv5Znrt/LM9Vt55vqtPHP9Vp65fivPXL+VV67fyivXb+WV67fyyvVbeeX6rbxy/VZeuX4rr1y/lVeu38or12/lXH/b13P9bV+/92/7zuv7h89rzfc/XGotvy/++t9z/XD1DfrqO/TVD+irn9BXv6CvfkNf/UG++nv/pvI/Xn05f179/uHqS+ran3+uvv909bl7rXf10L323r8HDb966F57oHvtge61B7rXHuReO16Ze61/9Zl7rTcpjBdyrx2v3L3Wu3rkXjteyL12vJB77Xgh99rxQu614wXdawt0ry2591rv6jP3WndSKNC99t6/3Q6/euheW6B7bYHutQW61xboXluhe22F7rUV+d9rR83ca91J4d6/yI/utTV3r/WuHrrXVuheW6F7bYXutQ261zboXtuge21D/vfaca+zED0pNOhe23L3Wu/qoXttg+61DbrXduhe26F7bYfutR26196rZ4RffeZe604KHbrX9ty91rt66F7boXvtgO61A7rXDuheO6B77b0mSvjVQ/977cjca91JYUD32pG713pXD91rJ3SvndC9dkL32gnda++VbsKvHrrXTuh/r52Ze607KUzoXjtz91rn6hd0r13QvXZB99oF3Wvv9YvCrx661y7oXrug/712Ze617qSwoHvtzt1rvauH7rXQbtSAdqMGtBs1oN2oAe1GDWg3akC7USO1G+VOCqndKLfXQrtRI7kb5eQe2o0a0G7UgHajBrQbNaDdqAHtRg1oN2qmdqO8SWGmdqO8Xjuh3aiZ3I3yco/caye0GzWh3agJ7UZNaDdqQrtRE9qNmqndKHdSSO1Gub0W2o2ayd0oL/fQvRbajZrQbtSEdqMmtBs1od2oCe1GzdRulDsppHaj3F4L7UbN5G6Ul3voXgvtRk1oN2pCu1ET2o2a0G7UhHajZmo3yp0UUrtRbq+FdqNmcjfKyz10r4V2oya0GzWh3agJ7UZNaDdqQrtRM7Ub5U4Kqd0ot9dCu1EzuRvl5R6610K7URPajZrQbtSEdqMmtBs1od2omdqNcieF1G6U22uh3aiZ3I3ycg/da6HdqAntRk1oN2pCu1ET2o2a0G7UTO1GuZNCajfK7bXQbtRM7kY5uYd2oya0GzWh3agJ7UZNaDdqQrtRE9qNmqndKHdSSO1Gub0W2o2ayd0oJ/fQbtSEdqMmtBs1od2oCe1GTWg3akK7UTO1G+VOCqndKLfXQrtRM7kb5eQe2o2a0G7UhHajJrQbNaHdqAntRk1oN2qmdqO8SWGldqO8Xrug3aiV3I16n/sF7UatF3KvXdBu1IJ2oxa0G7Wg3agF7Uat1G6UOymkdqPcXgvtRq3kbpSXe+heC+1GLWg3akG7UQvajVrQbtSCdqNWajfKnRRSu1Fur4V2o1ZyN8rLPXSvhXajFrQbtaDdqAXtRi1oN2pBu1ErtRvlTgqp3Si310K7USu5G+XlHrrXQrtRC9qNWtBu1IJ2oxa0G7Wg3aiV2o1yJ4XUbpTba6HdqJXcjfJyD91rod2oBe1GLWg3akG7UQvajVrQbtRK7Ua5k0JqN8rttdBu1EruRnm5h+610G7UgnajFrQbtaDdqAXtRi1oN2qldqPcSSG1G+X2Wmg3aiV3o7zcQ/daaDdqQbtRC9qNWtBu1IJ2oxa0G7VSu1HupJDajXJ7LbQbtZK7UU7uod2oBe1GLWg3akG7UQvajVrQbtSCdqNWajfKnRRSu1Fur4V2o1ZyN8rJPbQbtaDdqAXtRi1oN2pBu1EL2o1a0G7USu1GuZNCajfK67Ub2o3ayd2o97nf0G7Uhnaj9gu5125oN2pDu1Eb2o3a0G7UTu1GeZPCTu1Gub0W2o3ayd0oJ/fQbtSGdqM2tBu1od2oDe1GbWg3akO7UTu1G+VOCqndKLfXQrtRO7kb5eUeutdCu1Eb2o3a0G7UhnajNrQbtaHdqJ3ajXInhdRulNtrod2ondyN8nIP3Wuh3agN7UZtaDdqQ7tRG9qN2tBu1E7tRrmTQmo3yu210G7UTu5GebmH7rXQbtSGdqM2tBu1od2oDe1GbWg3aqd2o9xJIbUb5fZaaDdqJ3ejvNxD91poN2pDu1Eb2o3a0G7UhnajNrQbtVO7Ue6kkNqNcnsttBu1k7tRXu6hey20G7Wh3agN7UZtaDdqQ7tRG9qN2qndKHdSSO1Gub0W2o3ayd0oL/fQvRbajdrQbtSGdqM2tBu1od2oDe1G7dRulDsppHaj3F4L7Ubt5G6Uk3toN2pDu1Eb2o3a0G7UhnajNrQbtaHdqJ3ajXInhdRulNtrod2ok9yNep/7A+1GHWg36kC7UeeF3GsPtBt1oN2oA+1GndRulDcpnNRulNtrod2ok9yNcnIP7UYdaDfqQLtRB9qNOtBu1IF2ow60G3VSu1HupJDajXJ7LbQbdZK7UU7uod2oA+1GHWg36kC7UQfajTrQbtSBdqNOajfKnRRSu1Fur4V2o05yN8rLPXSvhXajDrQbdaDdqAPtRh1oN+pAu1EntRvlTgqp3Si310K7USe5G+XlHrrXQrtRB9qNOtBu1IF2ow60G3Wg3aiT2o1yJ4XUbpTba6HdqJPcjfJyD91rod2oA+1GHWg36kC7UQfajTrQbtRJ7Ua5k0JqN8rttdBu1EnuRnm5h+610G7UgXajDrQbdaDdqAPtRh1oN+qkdqPcSSG1G+X2Wmg36iR3o7zcQ/daaDfqQLtRB9qNOtBu1IF2ow60G3VSu1HupJDajXJ7LbQbdZK7UV7uoXsttBt1oN2oA+1GHWg36kC7UQfajTqp3Sh3UkjtRrm9FtqNOsndqLe57y9kN+q6euBee109cK+9rh64115XD9xrr6sH7rXX1QP/e+119cBG43X1wL32unpgN6q/krtRTu6R3ajr6qF7LbIbdV09dK9FdqOuq4futchu1HX1wEbjdfXQvRbZjbquHrrXIrtR19VD91pkN+q6euhei+xGXVcP3WuR3ajr6oGNxv5K7Ua5vRbZjbquHrrXIrtR19VD91pkN+q6euhei+xGXVcP3WuR3aj+Su1GuZNCajfK7bXIbtR19dC9FtmNuq4eutciu1HX1UP3WmQ36rp66F6L7EZdVw9sNF5XD91rkd2o6+qhey2yG3VdPXSvRXajrquH7rXIblR/IbtR19VD/3ttajfKnRRSu1Fur0V2o66rh+61yG7UdfXQvRbZjbquHrrXIrtR19VD91pkN+q6emCj8bp66F6L7EZdVw/da5HdqOvqoXstshvVX8hu1HX10L0W2Y26rh7632tTu1HupJDajXJ7LbIbdV09dK9FdqOuq4futchu1HX10L0W2Y26rh661yK7UdfVAxuN19VD91pkN+q6euheC+1GFWg3qkC7UQXajSrQblR5IffaAu1GldRulDcplNRulNdrC7QbVZK7UU7uod2oAu1GFWg3qkC7UQXajSrQblSBdqNKajfKnRRSu1Fur4V2o0pyN8rJPbQbVaDdqALtRhVoN6pAu1EF2o0q0G5USe1GuZNCajfK7bXQblRJ7kY5uYd2owq0G1Wg3agC7UYVaDeqQLtRBdqNKqndKHdSSO1Gub0W2o0qyd0oJ/fQblSBdqMKtBtVoN2oAu1GFWg3qkC7USW1G+VOCqndKLfXQrtRJbkb5eUeutdCu1EF2o0q0G5UgXajCrQbVaDdqJLajXInhdRulNtrod2oktyN8nIP3Wuh3agC7UYVaDeqQLtRBdqNKtBuVEntRrmTQmo3yu210G5USe5GebmH7rXQblSBdqMKtBtVoN2oAu1GFWg3qqR2o9xJIbUb5fZaaDeqJHejvNxD91poN6pAu1EF2o0q0G5UgXajCrQbVVK7Ue6kkNqNcnsttBtVkrtRXu6hey20G1Wh3agK7UZVaDeqQrtR9ZW51/pXj2w01tRulNdrK7QbVZO7UV7uoXsttBtVod2oCu1GVWg3qkK7URXajaqp3Sh3UkjtRrm9FtqNqsndKCf30G5UhXajKrQbVaHdqArtRlVoN6pCu1E1tRvlTgqp3Si310K7UTW5G+XkHtqNqtBuVIV2oyq0G1Wh3agK7UZVaDeqpnaj3EkhtRvl9lpoN6omd6Oc3EO7URXajarQblSFdqMqtBtVod2oCu1G1dRulDsppHaj3F4L7UbV5G6Uk3toN6pCu1EV2o2q0G5UhXajKrQbVaHdqJrajXInhdRulNtrod2omtyN8nIP3Wuh3agK7UZVaDeqQrtRFdqNqtBuVE3tRrmTQmo3yu210G5UTe5GebmH7rXQblSFdqMqtBtVod2oCu1GVWg3qqZ2o9xJIbUb5fZaaDeqJnejvNxD91poN6pCu1EV2o2q0G5UhXajKrQbVVO7Ue6kkNqNcnsttBtVk7tRXu6hey20G1Wh3agG7UY1aDeqQbtRDdqNaq/MvdabFFpqN8rrtQ3ajWrJ3Sgv98i9tkG7UQ3ajWrQblSDdqMatBvVoN2oltqNcieF1G6U22uh3aiW3I3ycg/da6HdqAbtRjVoN6pBu1EN2o1q0G5US+1GuZNCajfK7bXQblRL7kY5uYd2oxq0G9Wg3agG7UY1aDeqQbtRDdqNaqndKHdSSO1Gub0W2o1qyd0oJ/fQblSDdqMatBvVoN2oBu1GNWg3qkG7US21G+VOCqndKLfXQrtRLbkb5eQe2o1q0G5Ug3ajGrQb1aDdqAbtRjVoN6qldqPcSSG1G+X2Wmg3qiV3o5zcQ7tRDdqNatBuVIN2oxq0G9Wg3agG7Ua11G6UOymkdqPcXgvtRrXkbpSXe+heC+1GNWg3qkG7UQ3ajWrQblSDdqNaajfKnRRSu1Fur4V2o1pyN8rLPXSvhXajGrQb1aDdqAbtRjVoN6pBu1EttRvlTgqp3Si310K7US25G+XlHrrXQrtRDdqNatBuVId2ozq0G9Wh3aie2o3yJoX+Qu61HdqN6sndKC/3yL22Q7tRHdqN6tBuVId2ozq0G9Wh3aie2o1yJ4XUbpTba6HdqJ7cjfJyD91rod2oDu1GdWg3qkO7UR3ajerQblRP7Ua5k0JqN8rttdBuVE/uRnm5h+610G5Uh3ajOrQb1aHdqA7tRnVoN6qndqPcSSG1G+X2Wmg3qid3o5zcQ7tRHdqN6tBuVId2ozq0G9Wh3agO7Ub11G6UOymkdqPcXgvtRvXkbpSTe2g3qkO7UR3ajerQblSHdqM6tBvVod2ontqNcieF1G6U22uh3aie3I1ycg/tRnVoN6pDu1Ed2o3q0G5Uh3ajOrQb1VO7Ue6kkNqNcnsttBvVk7tRTu6h3agO7UZ1aDeqQ7tRHdqN6tBuVId2o3pqN8qdFFK7UW6vhXajenI3yss9dK+FdqM6tBvVod2oDu1GdWg3qkO7UT21G+VOCqndKLfXQrtRPbkb5eUeutdCu1Ed2o3q0G5Uh3ajBrQbNaDdqJHajfImhZHajfJ67Xjl7rXe1SP32gHtRg1oN2pAu1ED2o0a0G7UgHajBrQbNVK7Ue6kkNqNcnsttBs1krtRXu6hey20GzWg3agB7UYNaDdqQLtRA9qNGqndKHdSSO1Gub0W2o0ayd0oL/fQvRbajRrQbtSAdqMGtBs1oN2oAe1GjdRulDsppHaj3F4L7UaN5G6Ul3voXgvtRg1oN2pAu1ED2o0a0G7UgHajRmo3yp0UUrtRbq+FdqNGcjfKyT20GzWg3agB7UYNaDdqQLtRA9qNGtBu1EjtRrmTQmo3yu210G7USO5GObmHdqMGtBs1oN2oAe1GDWg3akC7UQPajRqp3Sh3UkjtRrm9FtqNGsndKCf30G7UgHajBrQbNaDdqAHtRg1oN2pAu1EjtRvlTgqp3Si310K7USO5G+XkHtqNGtBu1IB2owa0GzWg3agB7UYNaDdqpHaj3EkhtRvl9lpoN2okd6O83EP3Wmg3akC7UQPajRrQbtSAdqMmtBs1U7tR3qQwU7tRXq+d0G7UfCH32gntRk1oN2pCu1ET2o2a0G7UhHajJrQbNVO7Ue6kkNqNcnsttBs1k7tRXu6hey20GzWh3agJ7UZNaDdqQrtRE9qNmqndKHdSSO1Gub0W2o2ayd0oL/fQvRbajZrQbtSEdqMmtBs1od2oCe1GzdRulDsppHaj3F4L7UbN5G6Ul3voXgvtRk1oN2pCu1ET2o2a0G7UhHajZmo3yp0UUrtRbq+FdqNmcjfKyz10r4V2oya0GzWh3agJ7UZNaDdqQrtRM7Ub5U4Kqd0ot9dCu1EzuRvl5B7ajZrQbtSEdqMmtBs1od2oCe1GTWg3aqZ2o9xJIbUb5fZaaDdqJnejnNxDu1ET2o2a0G7UhHajJrQbNaHdqAntRs3UbpQ7KaR2o9xeC+1GzeRulJN7aDdqQrtRE9qNmtBu1IR2oya0GzWh3aiZ2o1yJ4XUbpTba6HdqJncjXJyD+1GTWg3akK7URPajZrQbtSEdqMmtBu1UrtR3qSwUrtRXq9d0G7USu5GeblH7rUL2o1a0G7UgnajFrQbtaDdqAXtRq3UbpQ7KaR2o9xeC+1GreRulJd76F4L7UYtaDdqQbtRC9qNWtBu1IJ2o1ZqN8qdFFK7UW6vhXajVnI3yss9dK+FdqMWtBu1oN2oBe1GLWg3akG7USu1G+VOCqndKLfXQrtRK7kb5eUeutdCu1EL2o1a0G7UgnajFrQbtaDdqJXajXInhdRulNtrod2oldyN8nIP3Wuh3agF7UYtaDdqQbtRC9qNWtBu1ErtRrmTQmo3yu210G7USu5GebmH7rXQbtSCdqMWtBu1oN2oBe1GLWg3aqV2o9xJIbUb5fZaaDdqJXejnNxDu1EL2o1a0G7UgnajFrQbtaDdqAXtRq3UbpQ7KaR2o9xeC+1GreRulJN7aDdqQbtRC9qNWtBu1IJ2oxa0G7Wg3aiV2o1yJ4XUbpTba6HdqJXcjXJyD+1GLWg3akG7UQvajVrQbtSCdqMWtBu1UrtR3qSwU7tRXq/d0G7UTu5Gvc/9hnaj9gu5125oN2pDu1Eb2o3a0G7Uhnajdmo3yp0UUrtRbq+FdqN2cjfKyz10r4V2oza0G7Wh3agN7UZtaDdqQ7tRO7Ub5U4Kqd0ot9dCu1E7uRvl5R6610K7URvajdrQbtSGdqM2tBu1od2ondqNcieF1G6U22uh3aid3I3ycg/da6HdqA3tRm1oN2pDu1Eb2o3a0G7UTu1GuZNCajfK7bXQbtRO7kZ5uYfutdBu1IZ2oza0G7Wh3agN7UZtaDdqp3aj3EkhtRvl9lpoN2ond6O83EP3Wmg3akO7URvajdrQbtSGdqM2tBu1U7tR7qSQ2o1yey20G7WTu1Fe7qF7LbQbtaHdqA3tRm1oN2pDu1Eb2o3aqd0od1JI7Ua5vRbajdrJ3Sgn99Bu1IZ2oza0G7Wh3agN7UZtaDdqQ7tRO7Ub5U4Kqd0ot9dCu1E7uRvl5B7ajdrQbtSGdqM2tBu1od2oDe1GbWg3aqd2o9xJIbUb5fXaA+1GneRu1PvcH2g36kC7UeeF3GsPtBt1oN2oA+1GHWg36qR2o7xJ4aR2o9xeC+1GneRulJN7aDfqQLtRB9qNOtBu1IF2ow60G3Wg3aiT2o1yJ4XUbpTba6HdqJPcjfJyD91rod2oA+1GHWg36kC7UQfajTrQbtRJ7Ua5k0JqN8rttdBu1EnuRnm5h+610G7UgXajDrQbdaDdqAPtRh1oN+qkdqPcSSG1G+X2Wmg36iR3o7zcQ/daaDfqQLtRB9qNOtBu1IF2ow60G3VSu1HupJDajXJ7LbQbdZK7UV7uoXsttBt1oN2oA+1GHWg36kC7UQfajTqp3Sh3UkjtRrm9FtqNOsndKC/30L0W2o060G7UgXajDrQbdaDdqAPtRp3UbpQ7KaR2o9xeC+1GneRulJd76F4L7UYdaDfqQLtRB9qNOtBu1IF2o05qN8qdFFK7UW6vhXajTnI3ysk9tBt1oN2oA+1GHWg36kC7UQfajTrQbtRJ7Ua5k0JqN8rttchu1Hgld6Pe5v66euBee109cK+9rh64115XD9xrr6sH7rXX1QP32uvqgf+99rp6YKPxunroXovsRl1XD91rkd2o6+qhey2yG3VdPXSvRXajrquH7rXIbtR19cBG43ildqPcXovsRl1XD91rkd2o6+qhey2yG3VdPXSvRXajrquH7rXIbtR4pXaj3EkhtRvl9lpkN+q6euhei+xGXVcP3WuR3ajr6qF7LbIbdV09dK9FdqOuqwc2Gq+rh+61yG7UdfXQvRbZjbquHrrXIrtR19VD91pkN2q8kN2o6+qh/702tRvlTgqp3Si31yK7UdfVQ/daZDfqunroXovsRl1XD91rkd2o6+qhey2yG3VdPbDReF09dK9FdqOuq4futchu1HX10L0W2Y0aL2Q36rp66F6L7EZdVw/977Wp3Sh3UkjtRrm9FtmNuq4eutciu1HX1UP3WmQ36rp66F6L7EZdVw/da5HdqOvqgY3G6+qhey2yG3VdPXSvRXajxgvZjbquHrrXIrtR19VD91pkN+q6euh/r03tRrmTQmo3yu21yG7UdfXIvbZAu1EF2o0q0G5UgXajygu51xZoN6pAu1EltRvlTQoltRvl9doC7UaV5G6Uk3toN6pAu1EF2o0q0G5UgXajCrQbVaDdqJLajXInhdRulNtrod2oktyNcnIP7UYVaDeqQLtRBdqNKtBuVIF2owq0G1VSu1HupJDajXJ7LbQbVZK7UU7uod2oAu1GFWg3qkC7UQXajSrQblSBdqNKajfKnRRSu1Fur4V2o0pyN8rLPXSvhXajCrQbVaDdqALtRhVoN6pAu1EltRvlTgqp3Si310K7USW5G+XlHrrXQrtRBdqNKtBuVIF2owq0G1Wg3aiS2o1yJ4XUbpTba6HdqJLcjfJyD91rod2oAu1GFWg3qkC7UQXajSrQblRJ7Ua5k0JqN8rttdBuVEnuRnm5h+610G5UgXajCrQbVaDdqALtRhVoN6qkdqPcSSG1G+X2Wmg3qiR3o7zcQ/daaDeqQLtRBdqNKtBuVIF2owq0G1VSu1HupJDajXJ7LbQbVZK7UV7ukXtthXajKrQbVaHdqArtRtUXcq+t0G5UTe1GeZNCTe1Geb22QrtRNbkb5eQe2o2q0G5UhXajKrQbVaHdqArtRlVoN6qmdqPcSSG1G+X2Wmg3qiZ3o5zcQ7tRFdqNqtBuVIV2oyq0G1Wh3agK7UbV1G6UOymkdqPcXgvtRtXkbpSTe2g3qkK7URXajarQblSFdqMqtBtVod2omtqNcieF1G6U22uh3aia3I1ycg/tRlVoN6pCu1EV2o2q0G5UhXajKrQbVVO7Ue6kkNqNcnsttBtVk7tRXu6hey20G1Wh3agK7UZVaDeqQrtRFdqNqqndKHdSSO1Gub0W2o2qyd0oL/fQvRbajarQblSFdqMqtBtVod2oCu1G1dRulDsppHaj3F4L7UbV5G6Ul3voXgvtRlVoN6pCu1EV2o2q0G5UhXajamo3yp0UUrtRbq+FdqNqcjfKyz10r4V2oyq0G1Wh3agK7UZVaDeqQrtRNbUb5U4Kqd0ot9dCu1E1uRvl5R6610K7UQ3ajWrQblSDdqMatBvVXpl7rX/1yEZjS+1Geb22QbtRLbkb5eUeutdCu1EN2o1q0G5Ug3ajGrQb1aDdqJbajXInhdRulNtrod2oltyNcnIP7UY1aDeqQbtRDdqNatBuVIN2oxq0G9VSu1HupJDajXJ7LbQb1ZK7UU7uod2oBu1GNWg3qkG7UQ3ajWrQblSDdqNaajfKnRRSu1Fur4V2o1pyN8rJPbQb1aDdqAbtRjVoN6pBu1EN2o1q0G5US+1GuZNCajfK7bXQblRL7kY5uYd2oxq0G9Wg3agG7UY1aDeqQbtRDdqNaqndKHdSSO1Gub0W2o1qyd0oL/fQvRbajWrQblSDdqMatBvVoN2oBu1GtdRulDsppHaj3F4L7Ua15G6Ul3voXgvtRjVoN6pBu1EN2o1q0G5Ug3ajWmo3yp0UUrtRbq+FdqNacjfKyz10r4V2oxq0G9Wg3agG7UY1aDeqQbtRLbUb5U4Kqd0ot9dCu1EtuRvl5R6610K7UQ3ajerQblSHdqM6tBvVod2o/srca71Joad2o7xe26HdqJ7cjfJyj9xrO7Qb1aHdqA7tRnVoN6pDu1Ed2o3qqd0od1JI7Ua5vRbajerJ3Sgv99C9FtqN6tBuVId2ozq0G9Wh3agO7Ub11G6UOymkdqPcXgvtRvXkbpSTe2g3qkO7UR3ajerQblSHdqM6tBvVod2ontqNcieF1G6U22uh3aie3I1ycg/tRnVoN6pDu1Ed2o3q0G5Uh3ajOrQb1VO7Ue6kkNqNcnsttBvVk7tRTu6h3agO7UZ1aDeqQ7tRHdqN6tBuVId2o3pqN8qdFFK7UW6vhXajenI3ysk9tBvVod2oDu1GdWg3qkO7UR3ajerQblRP7Ua5k0JqN8rttdBuVE/uRnm5h+610G5Uh3ajOrQb1aHdqA7tRnVoN6qndqPcSSG1G+X2Wmg3qid3o7zcQ/daaDeqQ7tRHdqN6tBuVId2ozq0G9VTu1HupJDajXJ7LbQb1ZO7UV7uoXsttBvVod2oDu1GDWg3akC7UQPajRqp3ShvUhgv5F47oN2okdyN8nKP3GsHtBs1oN2oAe1GDWg3akC7UQPajRqp3Sh3UkjtRrm9FtqNGsndKC/30L0W2o0a0G7UgHajBrQbNaDdqAHtRo3UbpQ7KaR2o9xeC+1GjeRulJd76F4L7UYNaDdqQLtRA9qNGtBu1IB2o0ZqN8qdFFK7UW6vhXajRnI3ysk9tBs1oN2oAe1GDWg3akC7UQPajRrQbtRI7Ua5k0JqN8rttdBu1EjuRjm5h3ajBrQbNaDdqAHtRg1oN2pAu1ED2o0aqd0od1JI7Ua5vRbajRrJ3Sgn99Bu1IB2owa0GzWg3agB7UYNaDdqQLtRI7Ub5U4Kqd0ot9dCu1EjuRvl5B7ajRrQbtSAdqMGtBs1oN2oAe1GDWg3aqR2o9xJIbUb5fZaaDdqJHejvNxD91poN2pAu1ED2o0a0G7UgHajBrQbNVK7Ue6kkNqNcnsttBs1krtRXu6hey20GzWg3agB7UYNaDdqQrtRE9qNmqndKG9SmKndKK/XzlfuXutdPXKvndBu1IR2oya0GzWh3agJ7UZNaDdqQrtRM7Ub5U4Kqd0ot9dCu1EzuRvl5R6610K7URPajZrQbtSEdqMmtBs1od2omdqNcieF1G6U22uh3aiZ3I3ycg/da6HdqAntRk1oN2pCu1ET2o2a0G7UTO1GuZNCajfK7bXQbtRM7kZ5uYfutdBu1IR2oya0GzWh3agJ7UZNaDdqpnaj3EkhtRvl9lpoN2omd6Oc3EO7URPajZrQbtSEdqMmtBs1od2oCe1GzdRulDsppHaj3F4L7UbN5G6Uk3toN2pCu1ET2o2a0G7UhHajJrQbNaHdqJnajXInhdRulNtrod2omdyNcnIP7UZNaDdqQrtRE9qNmtBu1IR2oya0GzVTu1HupJDajXJ7LbQbNZO7UU7uod2oCe1GTWg3akK7URPajZrQbtSEdqNmajfKnRRSu1Fur4V2o2ZyN8rLPXSvhXajJrQbNaHdqAntRk1oN2pBu1ErtRvlTQortRvl9doF7UatF3KvXdBu1IJ2oxa0G7Wg3agF7UYtaDdqQbtRK7Ub5U4Kqd0ot9dCu1EruRvl5R6610K7UQvajVrQbtSCdqMWtBu1oN2oldqNcieF1G6U22uh3aiV3I3ycg/da6HdqAXtRi1oN2pBu1EL2o1a0G7USu1GuZNCajfK7bXQbtRK7kZ5uYfutdBu1IJ2oxa0G7Wg3agF7UYtaDdqpXaj3EkhtRvl9lpoN2old6O83EP3Wmg3akG7UQvajVrQbtSCdqMWtBu1UrtR7qSQ2o1yey20G7WSu1FO7qHdqAXtRi1oN2pBu1EL2o1a0G7UgnajVmo3yp0UUrtRbq+FdqNWcjfKyT20G7Wg3agF7UYtaDdqQbtRC9qNWtBu1ErtRrmTQmo3yu210G7USu5GObmHdqMWtBu1oN2oBe1GLWg3akG7UQvajVqp3Sh3UkjtRrm9FtqNWsndKCf30G7UgnajFrQbtaDdqAXtRi1oN2pBu1E7tRvlTQo7tRvl9doN7Ubt5G6Ul3vkXruh3agN7UZtaDdqQ7tRG9qN2tBu1E7tRrmTQmo3yu210G7UTu5GebmH7rXQbtSGdqM2tBu1od2oDe1GbWg3aqd2o9xJIbUb5fZaaDdqJ3ejvNxD91poN2pDu1Eb2o3a0G7UhnajNrQbtVO7Ue6kkNqNcnsttBu1k7tRXu6hey20G7Wh3agN7UZtaDdqQ7tRG9qN2qndKHdSSO1Gub0W2o3ayd0oL/fQvRbajdrQbtSGdqM2tBu1od2oDe1G7dRulDsppHaj3F4L7Ubt5G6Ul3voXgvtRm1oN2pDu1Eb2o3a0G7Uhnajdmo3yp0UUrtRbq+FdqN2cjfKyT20G7Wh3agN7UZtaDdqQ7tRG9qN2tBu1E7tRrmTQmo3yu210G7UTu5GObmHdqM2tBu1od2oDe1GbWg3akO7URvajdqp3Sh3UkjtRrm9FtqN2sndKCf30G7UhnajNrQbtaHdqA3tRm1oN2pDu1E7tRvlTQontRvl9doD7Uad5G7U+9wfaDfqvJB77YF2ow60G3Wg3agD7UYdaDfqpHaj3EkhtRvl9lpoN+okd6O83EP3Wmg36kC7UQfajTrQbtSBdqMOtBt1UrtR7qSQ2o1yey20G3WSu1Fe7qF7LbQbdaDdqAPtRh1oN+pAu1EH2o06qd0od1JI7Ua5vRbajTrJ3Sgv99C9FtqNOtBu1IF2ow60G3Wg3agD7Uad1G6UOymkdqPcXgvtRp3kbpSXe+heC+1GHWg36kC7UQfajTrQbtSBdqNOajfKnRRSu1Fur4V2o05yN8rLPXSvhXajDrQbdaDdqAPtRh1oN+pAu1EntRvlTgqp3Si310K7USe5G+XlHrrXQrtRB9qNOtBu1IF2ow60G3Wg3aiT2o1yJ4XUbpTba6HdqJPcjXJyD+1GHWg36kC7UQfajTrQbtSBdqMOtBt1UrtR7qSQ2o1yey20G3WSu1FO7qHdqAPtRh1oN+pAu1EH2o060G7UgXajTmo3yp0UUrtRTq+dL2Q36rp64F57XT1wr72uHrjXXlcP3GuvqwfutdfVA/fa6+qBe+119cD/XntdPbDROF+p3Si31yK7UdfVQ/daZDfqunroXovsRl1XD91rkd2o6+qhey2yGzVfqd0od1JI7Ua5vRbZjbquHrrXIrtR19VD91pkN+q6euhei+xGXVcP3WuR3ajr6oGNxuvqoXstsht1XT10r0V2o66rh+61yG7UdfXQvRbZjZovZDfqunrof69N7Ua5k0JqN8rttchu1HX10L0W2Y26rh661yK7UdfVQ/daZDfqunroXovsRl1XD2w0XlcP3WuR3ajr6qF7LbIbdV09dK9FdqPmC9mNuq4eutciu1HX1UP/e21qN8qdFFK7UW6vRXajrquH7rXIbtR19dC9FtmNuq4eutciu1HX1UP3WmQ36rp6YKPxunroXovsRl1XD91rkd2o+UJ2o66rh+61yG7UdfXQvRbZjbquHvrfa1O7Ue6kkNqNcnstsht1XT10r0V2o66rh+61yG7UdfXQvRbZjbquHrrXIrtR19UDG43X1UP3Wmg3qiR3o97nvkC7UQXajSrQblR5IffaAu1GFWg3qkC7USW1G+VNCiW1G+X2Wmg3qiR3o5zcQ7tRBdqNKtBuVIF2owq0G1Wg3agC7UaV1G6UOymkdqPcXgvtRpXkbpSTe2g3qkC7UQXajSrQblSBdqMKtBtVoN2oktqNcieF1G6U22uh3aiS3I3ycg/da6HdqALtRhVoN6pAu1EF2o0q0G5USe1GuZNCajfK7bXQblRJ7kZ5uYfutdBuVIF2owq0G1Wg3agC7UYVaDeqpHaj3EkhtRvl9lpoN6okd6O83EP3Wmg3qkC7UQXajSrQblSBdqMKtBtVUrtR7qSQ2o1yey20G1WSu1Fe7qF7LbQbVaDdqALtRhVoN6pAu1EF2o0qqd0od1JI7Ua5vRbajSrJ3Sgv99C9FtqNKtBuVIF2owq0G1Wg3agC7UaV1G6UOymkdqPcXgvtRpXkbpSXe+heC+1GFWg3qkC7UQXajSrQblSBdqNKajfKnRRSu1Fur4V2o0pyN+p97iu0G1Wh3agK7UZVaDeqvpB7bYV2oyq0G1VTu1HepFBTu1Fer63QblRN7kY5uYd2oyq0G1Wh3agK7UZVaDeqQrtRFdqNqqndKHdSSO1Gub0W2o2qyd0oJ/fQblSFdqMqtBtVod2oCu1GVWg3qkK7UTW1G+VOCqndKLfXQrtRNbkb5eQe2o2q0G5UhXajKrQbVaHdqArtRlVoN6qmdqPcSSG1G+X2Wmg3qiZ3o7zcQ/daaDeqQrtRFdqNqtBuVIV2oyq0G1VTu1HupJDajXJ7LbQbVZO7UV7uoXsttBtVod2oCu1GVWg3qkK7URXajaqp3Sh3UkjtRrm9FtqNqsndKC/30L0W2o2q0G5UhXajKrQbVaHdqArtRtXUbpQ7KaR2o9xeC+1G1eRulJd76F4L7UZVaDeqQrtRFdqNqtBuVIV2o2pqN8qdFFK7UW6vhXajanI3yss9dK+FdqMqtBtVod2oCu1GVWg3qkK7UTW1G+VOCqndKLfXQrtRNbkb5eUeudc2aDeqQbtRDdqNatBuVHsh99oG7Ua11G6UNym01G6U12sbtBvVkrtRTu6h3agG7UY1aDeqQbtRDdqNatBuVIN2o1pqN8qdFFK7UW6vhXajWnI3ysk9tBvVoN2oBu1GNWg3qkG7UQ3ajWrQblRL7Ua5k0JqN8rttdBuVEvuRjm5h3ajGrQb1aDdqAbtRjVoN6pBu1EN2o1qqd0od1JI7Ua5vRbajWrJ3Sgn99BuVIN2oxq0G9Wg3agG7UY1aDeqQbtRLbUb5U4Kqd0ot9dCu1EtuRvl5R6610K7UQ3ajWrQblSDdqMatBvVoN2oltqNcieF1G6U22uh3aiW3I3ycg/da6HdqAbtRjVoN6pBu1EN2o1q0G5US+1GuZNCajfK7bXQblRL7kZ5uYfutdBuVIN2oxq0G9Wg3agG7UY1aDeqpXaj3EkhtRvl9lpoN6old6O83EP3Wmg3qkG7UQ3ajWrQblSDdqMatBvVUrtR7qSQ2o1yey20G9WSu1Fe7qF7LbQb1aHdqA7tRnVoN6pDu1H9lbnX+lePbDT21G6U12s7tBvVk7tRXu6hey20G9Wh3agO7UZ1aDeqQ7tRHdqN6qndKHdSSO1Gub0W2o3qyd0oJ/fQblSHdqM6tBvVod2oDu1GdWg3qkO7UT21G+VOCqndKLfXQrtRPbkb5eQe2o3q0G5Uh3ajOrQb1aHdqA7tRnVoN6qndqPcSSG1G+X2Wmg3qid3o5zcQ7tRHdqN6tBuVId2ozq0G9Wh3agO7Ub11G6UOymkdqPcXgvtRvXkbpSTe2g3qkO7UR3ajerQblSHdqM6tBvVod2ontqNcieF1G6U22uh3aie3I3ycg/da6HdqA7tRnVoN6pDu1Ed2o3q0G5UT+1GuZNCajfK7bXQblRP7kZ5uYfutdBuVId2ozq0G9Wh3agO7UZ1aDeqp3aj3EkhtRvl9lpoN6ond6O83EP3Wmg3qkO7UR3ajerQblSHdqM6tBvVU7tR7qSQ2o1yey20G9WTu1Fe7qF7LbQb1aHdqAHtRg1oN2pAu1ED2o0ar8y91psURmo3yuu1A9qNGsndKC/3yL12QLtRA9qNGtBu1IB2owa0GzWg3aiR2o1yJ4XUbpTba6HdqJHcjfJyD91rod2oAe1GDWg3akC7UQPajRrQbtRI7Ua5k0JqN8rttdBu1EjuRjm5h3ajBrQbNaDdqAHtRg1oN2pAu1ED2o0aqd0od1JI7Ua5vRbajRrJ3Sgn99Bu1IB2owa0GzWg3agB7UYNaDdqQLtRI7Ub5U4Kqd0ot9dCu1EjuRvl5B7ajRrQbtSAdqMGtBs1oN2oAe1GDWg3aqR2o9xJIbUb5fZaaDdqJHejnNxDu1ED2o0a0G7UgHajBrQbNaDdqAHtRo3UbpQ7KaR2o9xeC+1GjeRulJd76F4L7UYNaDdqQLtRA9qNGtBu1IB2o0ZqN8qdFFK7UW6vhXajRnI3yss9dK+FdqMGtBs1oN2oAe1GDWg3akC7USO1G+VOCqndKLfXQrtRI7kb5eUeutdCu1ED2o0a0G7UhHajJrQbNaHdqJnajfImhflC7rUT2o2ayd0oL/fIvXZCu1ET2o2a0G7UhHajJrQbNaHdqJnajXInhdRulNtrod2omdyN8nIP3Wuh3agJ7UZNaDdqQrtRE9qNmtBu1EztRrmTQmo3yu210G7UTO5GebmH7rXQbtSEdqMmtBs1od2oCe1GTWg3aqZ2o9xJIbUb5fZaaDdqJnejnNxDu1ET2o2a0G7UhHajJrQbNaHdqAntRs3UbpQ7KaR2o9xeC+1GzeRulJN7aDdqQrtRE9qNmtBu1IR2oya0GzWh3aiZ2o1yJ4XUbpTba6HdqJncjXJyD+1GTWg3akK7URPajZrQbtSEdqMmtBs1U7tR7qSQ2o1yey20GzWTu1FO7qHdqAntRk1oN2pCu1ET2o2a0G7UhHajZmo3yp0UUrtRbq+FdqNmcjfKyz10r4V2oya0GzWh3agJ7UZNaDdqQrtRM7Ub5U4Kqd0ot9dCu1EzuRvl5R6610K7URPajZrQbtSEdqMWtBu1oN2oldqN8iaFldqN8nrteuXutd7VI/faBe1GLWg3akG7UQvajVrQbtSCdqMWtBu1UrtR7qSQ2o1yey20G7WSu1Fe7qF7LbQbtaDdqAXtRi1oN2pBu1EL2o1aqd0od1JI7Ua5vRbajVrJ3Sgv99C9FtqNWtBu1IJ2oxa0G7Wg3agF7Uat1G6UOymkdqPcXgvtRq3kbpSXe+heC+1GLWg3akG7UQvajVrQbtSCdqNWajfKnRRSu1Fur4V2o1ZyN8rJPbQbtaDdqAXtRi1oN2pBu1EL2o1a0G7USu1GuZNCajfK7bXQbtRK7kY5uYd2oxa0G7Wg3agF7UYtaDdqQbtRC9qNWqndKHdSSO1Gub0W2o1ayd0oJ/fQbtSCdqMWtBu1oN2oBe1GLWg3akG7USu1G+VOCqndKLfXQrtRK7kb5eQe2o1a0G7UgnajFrQbtaDdqAXtRi1oN2qldqPcSSG1G+X2Wmg3aiV3o7zcQ/daaDdqQbtRC9qNWtBu1IJ2oza0G7VTu1HepLBTu1Fer93QbtR+IffaDe1GbWg3akO7URvajdrQbtSGdqM2tBu1U7tR7qSQ2o1yey20G7WTu1Fe7qF7LbQbtaHdqA3tRm1oN2pDu1Eb2o3aqd0od1JI7Ua5vRbajdrJ3Sgv99C9FtqN2tBu1IZ2oza0G7Wh3agN7Ubt1G6UOymkdqPcXgvtRu3kbpSXe+heC+1GbWg3akO7URvajdrQbtSGdqN2ajfKnRRSu1Fur4V2o3ZyN8rLPXSvhXajNrQbtaHdqA3tRm1oN2pDu1E7tRvlTgqp3Si310K7UTu5G+XkHtqN2tBu1IZ2oza0G7Wh3agN7UZtaDdqp3aj3EkhtRvl9lpoN2ond6Oc3EO7URvajdrQbtSGdqM2tBu1od2oDe1G7dRulDsppHaj3F4L7Ubt5G6Uk3toN2pDu1Eb2o3a0G7UhnajNrQbtaHdqJ3ajXInhdRulNtrod2ondyNcnIP7UZtaDdqQ7tRG9qN2tBu1IZ2oza0G3VSu1HepHBSu1Ferz3QbtRJ7kZ5uUfutQfajTrQbtSBdqMOtBt1oN2oA+1GndRulDsppHaj3F4L7Uad5G6Ul3voXgvtRh1oN+pAu1EH2o060G7UgXajTmo3yp0UUrtRbq+FdqNOcjfKyz10r4V2ow60G3Wg3agD7UYdaDfqQLtRJ7Ub5U4Kqd0ot9dCu1EnuRvl5R6610K7UQfajTrQbtSBdqMOtBt1oN2ok9qNcieF1G6U22uh3aiT3I3ycg/da6HdqAPtRh1oN+pAu1EH2o060G7USe1GuZNCajfK7bXQbtRJ7kZ5uYfutdBu1IF2ow60G3Wg3agD7UYdaDfqpHaj3EkhtRvl9lpoN+okd6Oc3EO7UQfajTrQbtSBdqMOtBt1oN2oA+1GndRulDsppHaj3F4L7Uad5G6Uk3toN+pAu1EH2o060G7UgXajDrQbdaDdqJPajXInhdRulNtrod2ok9yNcnIP7UYdaDfqQLtRB9qNOtBu1IF2ow60G3VSu1HOpLBeqd0op9deVw/sRl1XD9xrr6sH7rXX1QP32uvqgXvtdfXAvfa6euBee109cK+9rh7432vXK7Ub5U4Kqd0ot9ciu1HX1UP3WmQ36rp66F6L7EZdVw/da5HdqOvqoXstsht1XT2w0XhdPXSvRXajrquH7rXIbtR19dC9FtmNuq4eutciu1HrhexGXVcP/O+119UDG43X1UP3WmQ36rp66F6L7EZdVw/da5HdqOvqoXstsht1XT10r0V2o66rBzYar6uH7rXIbtR19dC9FtmNuq4eutciu1HrhexGXVcP3WuR3ajr6qH/vTa1G+VOCqndKLfXIrtR19VD91pkN+q6euhei+xGXVcP3WuR3ajr6qF7LbIbdV09sNF4XT10r0V2o66rh+61yG7UeiG7UdfVQ/daZDfqunroXovsRl1XD/3vtandKHdSSO1Gub0W2Y26rh661yK7UdfVQ/daZDfqunroXovsRl1XD91rkd2o6+qBjcbr6qF7LbIbtV7J3Sgn98hu1HX10L0W2Y26rh661yK7UdfVQ/daZDfqunpgo/G6euReW6DdqJLcjXqf+wLtRhVoN6q8kHttgXajCrQbVaDdqALtRpXUbpQ3KZTUbpTba6HdqJLcjXJyD+1GFWg3qkC7UQXajSrQblSBdqMKtBtVUrtR7qSQ2o1yey20G1WSu1Fe7qF7LbQbVaDdqALtRhVoN6pAu1EF2o0qqd0od1JI7Ua5vRbajSrJ3Sgv99C9FtqNKtBuVIF2owq0G1Wg3agC7UaV1G6UOymkdqPcXgvtRpXkbpSXe+heC+1GFWg3qkC7UQXajSrQblSBdqNKajfKnRRSu1Fur4V2o0pyN8rLPXSvhXajCrQbVaDdqALtRhVoN6pAu1EltRvlTgqp3Si310K7USW5G+XlHrrXQrtRBdqNKtBuVIF2owq0G1Wg3aiS2o1yJ4XUbpTba6HdqJLcjfJyD91rod2oAu1GFWg3qkC7UQXajSrQblRJ7Ua5k0JqN8rttdBuVEnuRjm5h3ajCrQbVaDdqALtRhVoN6pAu1EF2o0qqd0od1JI7Ua5vRbajarJ3aj3ua/QblSFdqMqtBtVX8i9tkK7URXajarQblRN7UZ5k0JN7Ua5vRbajarJ3Sgn99BuVIV2oyq0G1Wh3agK7UZVaDeqQrtRNbUb5U4Kqd0ot9dCu1E1uRvl5B7ajarQblSFdqMqtBtVod2oCu1GVWg3qqZ2o9xJIbUb5fZaaDeqJnejvNxD91poN6pCu1EV2o2q0G5UhXajKrQbVVO7Ue6kkNqNcnsttBtVk7tRXu6hey20G1Wh3agK7UZVaDeqQrtRFdqNqqndKHdSSO1Gub0W2o2qyd0oL/fQvRbajarQblSFdqMqtBtVod2oCu1G1dRulDsppHaj3F4L7UbV5G6Ul3voXgvtRlVoN6pCu1EV2o2q0G5UhXajamo3yp0UUrtRbq+FdqNqcjfKyz10r4V2oyq0G1Wh3agK7UZVaDeqQrtRNbUb5U4Kqd0ot9dCu1E1uRvl5R6610K7URXajarQblSFdqMqtBtVod2omtqNcieF1G6U22uh3aia3I16n/sG7UY1aDeqQbtRDdqNai/kXtug3agG7Ua11G6UNym01G6U12sbtBvVkrtRTu6h3agG7UY1aDeqQbtRDdqNatBuVIN2o1pqN8qdFFK7UW6vhXajWnI3ysk9tBvVoN2oBu1GNWg3qkG7UQ3ajWrQblRL7Ua5k0JqN8rttdBuVEvuRjm5h3ajGrQb1aDdqAbtRjVoN6pBu1EN2o1qqd0od1JI7Ua5vRbajWrJ3Sgv99C9FtqNatBuVIN2oxq0G9Wg3agG7Ua11G6UOymkdqPcXgvtRrXkbpSXe+heC+1GNWg3qkG7UQ3ajWrQblSDdqNaajfKnRRSu1Fur4V2o1pyN8rLPXSvhXajGrQb1aDdqAbtRjVoN6pBu1EttRvlTgqp3Si310K7US25G+XlHrrXQrtRDdqNatBuVIN2oxq0G9Wg3aiW2o1yJ4XUbpTba6HdqJbcjfJyD91rod2oBu1GNWg3qkG7UQ3ajWrQblRL7Ua5k0JqN8rttdBuVEvuRnm5R+61HdqN6tBuVId2ozq0G9VfyL22Q7tRPbUb5U0KPbUb5fXaDu1G9eRulJN7aDeqQ7tRHdqN6tBuVId2ozq0G9Wh3aie2o1yJ4XUbpTba6HdqJ7cjXJyD+1GdWg3qkO7UR3ajerQblSHdqM6tBvVU7tR7qSQ2o1yey20G9WTu1FO7qHdqA7tRnVoN6pDu1Ed2o3q0G5Uh3ajemo3yp0UUrtRbq+FdqN6cjfKyT20G9Wh3agO7UZ1aDeqQ7tRHdqN6tBuVE/tRrmTQmo3yu210G5UT+5GebmH7rXQblSHdqM6tBvVod2oDu1GdWg3qqd2o9xJIbUb5fZaaDeqJ3ejvNxD91poN6pDu1Ed2o3q0G5Uh3ajOrQb1VO7Ue6kkNqNcnsttBvVk7tRXu6hey20G9Wh3agO7UZ1aDeqQ7tRHdqN6qndKHdSSO1Gub0W2o3qyd0oL/fQvRbajerQblSHdqM6tBvVod2oDu1G9dRulDsppHaj3F4L7Ub15G6Ul3voXgvtRg1oN2pAu1ED2o0a0G7UeGXutf7VIxuNI7Ub5fXaAe1GjeRulJd76F4L7UYNaDdqQLtRA9qNGtBu1IB2o0ZqN8qdFFK7UW6vhXajRnI3ysk9tBs1oN2oAe1GDWg3akC7UQPajRrQbtRI7Ua5k0JqN8rttdBu1EjuRjm5h3ajBrQbNaDdqAHtRg1oN2pAu1ED2o0aqd0od1JI7Ua5vRbajRrJ3Sgn99Bu1IB2owa0GzWg3agB7UYNaDdqQLtRI7Ub5U4Kqd0ot9dCu1EjuRvl5B7ajRrQbtSAdqMGtBs1oN2oAe1GDWg3aqR2o9xJIbUb5fZaaDdqJHejvNxD91poN2pAu1ED2o0a0G7UgHajBrQbNVK7Ue6kkNqNcnsttBs1krtRXu6hey20GzWg3agB7UYNaDdqQLtRA9qNGqndKHdSSO1Gub0W2o0ayd0oL/fQvRbajRrQbtSAdqMGtBs1oN2oAe1GjdRulDsppHaj3F4L7UaN5G6Ul3voXgvtRg1oN2pCu1ET2o2a0G7UhHaj5itzr/UmhZnajfJ67YR2o2ZyN8rLPXKvndBu1IR2oya0GzWh3agJ7UZNaDdqpnaj3EkhtRvl9lpoN2omd6O83EP3Wmg3akK7URPajZrQbtSEdqMmtBs1U7tR7qSQ2o1yey20GzWTu1FO7qHdqAntRk1oN2pCu1ET2o2a0G7UhHajZmo3yp0UUrtRbq+FdqNmcjfKyT20GzWh3agJ7UZNaDdqQrtRE9qNmtBu1EztRrmTQmo3yu210G7UTO5GObmHdqMmtBs1od2oCe1GTWg3akK7URPajZqp3Sh3UkjtRrm9FtqNmsndKCf30G7UhHajJrQbNaHdqAntRk1oN2pCu1EztRvlTgqp3Si310K7UTO5G+XlHrrXQrtRE9qNmtBu1IR2oya0GzWh3aiZ2o1yJ4XUbpTba6HdqJncjfJyD91rod2oCe1GTWg3akK7URPajZrQbtRM7Ua5k0JqN8rttdBu1EzuRnm5h+610G7UhHajJrQbtaDdqAXtRi1oN2qldqO8SWG9kHvtgnajVnI3yss9cq9d0G7UgnajFrQbtaDdqAXtRi1oN2qldqPcSSG1G+X2Wmg3aiV3o7zcQ/daaDdqQbtRC9qNWtBu1IJ2oxa0G7VSu1HupJDajXJ7LbQbtZK7UV7uoXsttBu1oN2oBe1GLWg3akG7UQvajVqp3Sh3UkjtRrm9FtqNWsndKCf30G7UgnajFrQbtaDdqAXtRi1oN2pBu1ErtRvlTgqp3Si310K7USu5G+XkHtqNWtBu1IJ2oxa0G7Wg3agF7UYtaDdqpXaj3EkhtRvl9lpoN2old6Oc3EO7UQvajVrQbtSCdqMWtBu1oN2oBe1GrdRulDsppHaj3F4L7Uat5G6Uk3toN2pBu1EL2o1a0G7UgnajFrQbtaDdqJXajXInhdRulNtrod2oldyN8nIP3Wuh3agF7UYtaDdqQbtRC9qNWtBu1ErtRrmTQmo3yu210G7USu5GebmH7rXQbtSCdqMWtBu1oN2oDe1GbWg3aqd2o7xJYad2o7xeu1+5e6139ci9dkO7URvajdrQbtSGdqM2tBu1od2oDe1G7dRulDsppHaj3F4L7Ubt5G6Ul3voXgvtRm1oN2pDu1Eb2o3a0G7Uhnajdmo3yp0UUrtRbq+FdqN2cjfKyz10r4V2oza0G7Wh3agN7UZtaDdqQ7tRO7Ub5U4Kqd0ot9dCu1E7uRvl5R6610K7URvajdrQbtSGdqM2tBu1od2ondqNcieF1G6U22uh3aid3I1ycg/tRm1oN2pDu1Eb2o3a0G7UhnajNrQbtVO7Ue6kkNqNcnsttBu1k7tRTu6h3agN7UZtaDdqQ7tRG9qN2tBu1IZ2o3ZqN8qdFFK7UW6vhXajdnI3ysk9tBu1od2oDe1GbWg3akO7URvajdrQbtRO7Ua5k0JqN8rttdBu1E7uRjm5h3ajNrQbtaHdqA3tRm1oN2pDu1Eb2o3aqd0od1JI7Ua5vRbajdrJ3Sgv99C9FtqN2tBu1IZ2oza0G7Wh3agD7Uad1G6UNymc1G6U12sPtBt1Xsi99kC7UQfajTrQbtSBdqMOtBt1oN2oA+1GndRulDsppHaj3F4L7Uad5G6Ul3voXgvtRh1oN+pAu1EH2o060G7UgXajTmo3yp0UUrtRbq+FdqNOcjfKyz10r4V2ow60G3Wg3agD7UYdaDfqQLtRJ7Ub5U4Kqd0ot9dCu1EnuRvl5R6610K7UQfajTrQbtSBdqMOtBt1oN2ok9qNcieF1G6U22uh3aiT3I3ycg/da6HdqAPtRh1oN+pAu1EH2o060G7USe1GuZNCajfK7bXQbtRJ7kY5uYd2ow60G3Wg3agD7UYdaDfqQLtRB9qNOqndKHdSSO1Gub0W2o06yd0oJ/fQbtSBdqMOtBt1oN2oA+1GHWg36kC7USe1G+VOCqndKLfXQrtRJ7kb5eQe2o060G7UgXajDrQbdaDdqAPtRh1oN+qkdqPcSSG1G+X2Wmg36iR3o5zcQ7tRB9qNOtBu1IF2ow60G3Wg3aiD7EbtV2o3ypkUrqsH7rXX1QO7UdfVA/fa6+qBe+119cC99rp64F57XT1wr72uHrjXXlcP3WuR3ajr6oGNxuvqoXstsht1XT10r0V2o66rh+61yG7UdfXQvRbZjdovZDfqunrgf6+9rh7YaLyuHrrXIrtR19VD91pkN+q6euhei+xGXVcP3WuR3ajr6qF7LbIbdV09sNF4XT10r0V2o66rh+61yG7UdfXQvRbZjdovZDfqunroXovsRl1XD/3vtandKHdSSO1Gub0W2Y26rh661yK7UdfVQ/daZDfqunroXovsRl1XD91rkd2o6+qBjcbr6qF7LbIbdV09dK9FdqP2C9mNuq4eutciu1HX1UP3WmQ36rp66H+vTe1GuZNCajfK7bXIbtR19dC9FtmNuq4eutciu1HX1UP3WmQ36rp66F6L7EZdVw9sNF5XD91rkd2o/UruRjm5R3ajrquH7rXIbtR19dC9FtmNuq4eutciu1HX1QMbjdfVQ/daZDfqunroXovsRl1XD91rkd2o6+qhey2yG3VdPXSvRXajrqsHNhp3Se1Geb22QLtRJbkb9T73BdqNKi/kXlug3agC7UYVaDeqQLtRBdqNKqndKHdSSO1Gub0W2o0qyd0oL/fQvRbajSrQblSBdqMKtBtVoN2oAu1GldRulDsppHaj3F4L7UaV5G6Ul3voXgvtRhVoN6pAu1EF2o0q0G5UgXajSmo3yp0UUrtRbq+FdqNKcjfKyz10r4V2owq0G1Wg3agC7UYVaDeqQLtRJbUb5U4Kqd0ot9dCu1EluRvl5R6610K7UQXajSrQblSBdqMKtBtVoN2oktqNcieF1G6U22uh3aiS3I3ycg/da6HdqALtRhVoN6pAu1EF2o0q0G5USe1GuZNCajfK7bXQblRJ7kZ5uYfutdBuVIF2owq0G1Wg3agC7UYVaDeqpHaj3EkhtRvl9lpoN6okd6Oc3EO7UQXajSrQblSBdqMKtBtVoN2oAu1GldRulDsppHaj3F4L7UaV5G6Uk3toN6pAu1EF2o0q0G5UgXajCrQbVaDdqJLajXInhdRulNdrK7QbVZO7Ue9zX6HdqArtRtUXcq+t0G5UhXajKrQbVaHdqJrajfImhZrajXJ7LbQbVZO7UU7uod2oCu1GVWg3qkK7URXajarQblSFdqNqajfKnRRSu1Fur4V2o2pyN8rLPXSvhXajKrQbVaHdqArtRlVoN6pCu1E1tRvlTgqp3Si310K7UTW5G+XlHrrXQrtRFdqNqtBuVIV2oyq0G1Wh3aia2o1yJ4XUbpTba6HdqJrcjfJyD91rod2oCu1GVWg3qkK7URXajarQblRN7Ua5k0JqN8rttdBuVE3uRnm5h+610G5UhXajKrQbVaHdqArtRlVoN6qmdqPcSSG1G+X2Wmg3qiZ3o7zcQ/daaDeqQrtRFdqNqtBuVIV2oyq0G1VTu1HupJDajXJ7LbQbVZO7UV7uoXsttBtVod2oCu1GVWg3qkK7URXajaqp3Sh3UkjtRrm9FtqNqsndKCf30G5UhXajKrQbVaHdqArtRlVoN6pCu1E1tRvlTgqp3Si310K7US25G/U+9w3ajWrQblSDdqPaC7nXNmg3qkG7UQ3ajWqp3ShvUmip3Si310K7US25G+XkHtqNatBuVIN2oxq0G9Wg3agG7UY1aDeqpXaj3EkhtRvl9lpoN6old6Oc3EO7UQ3ajWrQblSDdqMatBvVoN2oBu1GtdRulDsppHaj3F4L7Ua15G6Ul3voXgvtRjVoN6pBu1EN2o1q0G5Ug3ajWmo3yp0UUrtRbq+FdqNacjfKyz10r4V2oxq0G9Wg3agG7UY1aDeqQbtRLbUb5U4Kqd0ot9dCu1EtuRvl5R6610K7UQ3ajWrQblSDdqMatBvVoN2oltqNcieF1G6U22uh3aiW3I3ycg/da6HdqAbtRjVoN6pBu1EN2o1q0G5US+1GuZNCajfK7bXQblRL7kZ5uYfutdBuVIN2oxq0G9Wg3agG7UY1aDeqpXaj3EkhtRvl9lpoN6old6O83EP3Wmg3qkG7UQ3ajWrQblSDdqMatBvVUrtR7qSQ2o1yey20G9WSu1Hvc9+h3agO7UZ1aDeqQ7tR/YXcazu0G9Wh3aie2o3yJoWe2o3yem2HdqN6cjfKyT20G9Wh3agO7UZ1aDeqQ7tRHdqN6tBuVE/tRrmTQmo3yu210G5UT+5GObmHdqM6tBvVod2oDu1GdWg3qkO7UR3ajeqp3Sh3UkjtRrm9FtqN6sndKCf30G5Uh3ajOrQb1aHdqA7tRnVoN6pDu1E9tRvlTgqp3Si310K7UT25G+XlHrrXQrtRHdqN6tBuVId2ozq0G9Wh3aie2o1yJ4XUbpTba6HdqJ7cjfJyD91rod2oDu1GdWg3qkO7UR3ajerQblRP7Ua5k0JqN8rttdBuVE/uRnm5h+610G5Uh3ajOrQb1aHdqA7tRnVoN6qndqPcSSG1G+X2Wmg3qid3o7zcQ/daaDeqQ7tRHdqN6tBuVId2ozq0G9VTu1HupJDajXJ7LbQb1ZO7UV7uoXsttBvVod2oDu1GdWg3qkO7UR3ajeqp3Sh3UkjtRrm9FtqN6sndKC/3yL12QLtRA9qNGtBu1IB2o8YLudcOaDdqpHajvElhpHajvF47oN2okdyNcnIP7UYNaDdqQLtRA9qNGtBu1IB2owa0GzVSu1HupJDajXJ7LbQbNZK7UU7uod2oAe1GDWg3akC7UQPajRrQbtSAdqNGajfKnRRSu1Fur4V2o0ZyN8rJPbQbNaDdqAHtRg1oN2pAu1ED2o0a0G7USO1GuZNCajfK7bXQbtRI7kY5uYd2owa0GzWg3agB7UYNaDdqQLtRA9qNGqndKHdSSO1Gub0W2o0ayd0oL/fQvRbajRrQbtSAdqMGtBs1oN2oAe1GjdRulDsppHaj3F4L7UaN5G6Ul3voXgvtRg1oN2pAu1ED2o0a0G7UgHajRmo3yp0UUrtRbq+FdqNGcjfKyz10r4V2owa0GzWg3agB7UYNaDdqQLtRI7Ub5U4Kqd0ot9dCu1EjuRvl5R6610K7UQPajRrQbtSAdqMGtBs1oN2okdqNcieF1G6U22uh3aiR3I3ycg/da6HdqAntRk1oN2pCu1ET2o2ar8y91r96ZKNxpnajvF47od2omdyN8nIP3Wuh3agJ7UZNaDdqQrtRE9qNmtBu1EztRrmTQmo3yu210G7UTO5GObmHdqMmtBs1od2oCe1GTWg3akK7URPajZqp3Sh3UkjtRrm9FtqNmsndKCf30G7UhHajJrQbNaHdqAntRk1oN2pCu1EztRvlTgqp3Si310K7UTO5G+XkHtqNmtBu1IR2oya0GzWh3agJ7UZNaDdqpnaj3EkhtRvl9lpoN2omd6Oc3EO7URPajZrQbtSEdqMmtBs1od2oCe1GzdRulDsppHaj3F4L7UbN5G6Ul3voXgvtRk1oN2pCu1ET2o2a0G7UhHajZmo3yp0UUrtRbq+FdqNmcjfKyz10r4V2oya0GzWh3agJ7UZNaDdqQrtRM7Ub5U4Kqd0ot9dCu1EzuRvl5R6610K7URPajZrQbtSEdqMmtBs1od2omdqNcieF1G6U22uh3aiZ3I3ycg/da6HdqAntRi1oN2pBu1EL2o1a0G7UemXutd6ksFK7UV6vXdBu1EruRnm5R+61C9qNWtBu1IJ2oxa0G7Wg3agF7Uat1G6UOymkdqPcXgvtRq3kbpSXe+heC+1GLWg3akG7UQvajVrQbtSCdqNWajfKnRRSu1Fur4V2o1ZyN8rJPbQbtaDdqAXtRi1oN2pBu1EL2o1a0G7USu1GuZNCajfK7bXQbtRK7kY5uYd2oxa0G7Wg3agF7UYtaDdqQbtRC9qNWqndKHdSSO1Gub0W2o1ayd0oJ/fQbtSCdqMWtBu1oN2oBe1GLWg3akG7USu1G+VOCqndKLfXQrtRK7kb5eQe2o1a0G7UgnajFrQbtaDdqAXtRi1oN2qldqPcSSG1G+X2Wmg3aiV3o7zcQ/daaDdqQbtRC9qNWtBu1IJ2oxa0G7VSu1HupJDajXJ7LbQbtZK7UV7uoXsttBu1oN2oBe1GLWg3akG7UQvajVqp3Sh3UkjtRrm9FtqNWsndKC/30L0W2o1a0G7UgnajNrQbtaHdqA3tRu3UbpQ3KewXcq/d0G7UTu5GeblH7rUb2o3a0G7UhnajNrQbtaHdqA3tRu3UbpQ7KaR2o9xeC+1G7eRulJd76F4L7UZtaDdqQ7tRG9qN2tBu1IZ2o3ZqN8qdFFK7UW6vhXajdnI3yss9dK+FdqM2tBu1od2oDe1GbWg3akO7UTu1G+VOCqndKLfXQrtRO7kb5eQe2o3a0G7UhnajNrQbtaHdqA3tRm1oN2qndqPcSSG1G+X2Wmg3aid3o5zcQ7tRG9qN2tBu1IZ2oza0G7Wh3agN7Ubt1G6UOymkdqPcXgvtRu3kbpSTe2g3akO7URvajdrQbtSGdqM2tBu1od2ondqNcieF1G6U22uh3aid3I1ycg/tRm1oN2pDu1Eb2o3a0G7UhnajNrQbtVO7Ue6kkNqNcnsttBu1k7tRXu6hey20G7Wh3agN7UZtaDdqQ7tRG9qN2qndKHdSSO1Gub0W2o3ayd0oL/fQvRbajdrQbtSGdqM2tBt1oN2oA+1GndRulDcpnNRulNdrzyt3r/WuHrnXHmg36kC7UQfajTrQbtSBdqMOtBt1oN2ok9qNcieF1G6U22uh3aiT3I3ycg/da6HdqAPtRh1oN+pAu1EH2o060G7USe1GuZNCajfK7bXQbtRJ7kZ5uYfutdBu1IF2ow60G3Wg3agD7UYdaDfqpHaj3EkhtRvl9lpoN+okd6O83EP3Wmg36kC7UQfajTrQbtSBdqMOtBt1UrtR7qSQ2o1yey20G3WSu1FO7qHdqAPtRh1oN+pAu1EH2o060G7UgXajTmo3yp0UUrtRbq+FdqNOcjfKyT20G3Wg3agD7UYdaDfqQLtRB9qNOtBu1EntRrmTQmo3yu210G7USe5GObmHdqMOtBt1oN2oA+1GHWg36kC7UQfajTqp3Sh3UkjtRrm9FtqNOsndKCf30G7UgXajDrQbdaDdqAPtRh1oN+pAu1EntRvlTgqp3Si310K7USe5G+XlHrrXQrtRB9qNOtBu1IF2ow6yG3VeyG7UdfXARuN19cC99rp6YDfqunrgXntdPXCvva4euNdeVw/ca6+rB+6119VD91pkN+q6euB/r72uHthovK4eutciu1HX1UP3WmQ36rp66F6L7EZdVw/da5HdqOvqoXstsht1XT2w0XhdPXSvRXajrquH7rXIbtR19dC9FtmNOi9kN+q6euhei+xGXVcP/O+119Vn7rXupJDajXJ7LbIbdV09dK9FdqOuq4futchu1HX10L0W2Y26rh661yK7UdfVAxuN19VD91pkN+q6euhei+xGXf816F6L7EZd/zXoXovsRl3/Nehei+xGXf81YKPx+q9B91pkN+r6r0H3WmQ36rp66F6L7EZdVw/da5HdqOvqoXstsht1XT2w0XhdPXSvRXajrv8EdK9FdqOu/wR0r0V2o67/BHSvRXajvv4T0FcP/e+1qd0od1JI7Ua5vRbZjbquHrrXIrtR19VD91pkN+q6euhei+xGXVcP3WuR3ajr6oGNxvNK7Ua5vRbZjbquHrrXIrtR19VD91pkN+q6euhei+xGXVcP3Wuh3aiS2o3yJoWS2o3yem2BdqNKcjfKyz1yry3QblSBdqMKtBtVoN2oAu1GFWg3qqR2o9xJIbUb1Uv/vvo+fqp95l7rX33mXtv6/Ofq/52cH358lH+OySjtn+tev+81c2eOvtfMfTz6XjN3/eh7zTwj/Md7bbN932tbP9xr5oki+F5TW1rR95p5Wom+18yzTfS9Zp6Eou+1E93rXzQ3uff6F81N7r3+RXOTe69Ec1Nq6Sz4XlO7aNH3SjQ3pTbXou+VaG5K7blF3yvR3JTaiou+V6K5KbVDF32vRHNTauMu+l6J5qbUfl70vRLNTaltvuh7JZqbUrt/0fdKNDelNgWj75VobkrtFUbfK9HclNpCjL5XorkptbMYfa9Ec1NqwzH6XonmptQ+ZPS9Es1Nqe3J6HslmptSu5bR90o0N6U2M6PvlWhuSu1xRt8r0dyU2vqMvleiuSm1Ixp9r0RzU2qjNPpeieam1P5p9L0SzU2pbdXoeyWam1K7rdH3SjQ3pTZho++VaG5K7c1G3yvR3JTaso2+V6K5KbWTG32vRHNTaoM3+l6J5qbUvm/0vRLNTant4Oh7JZqbUrvE0fdKNDelNo+j75VobkrtKUffK8/cVFNbzdH3yjM31dQOdPS98sxN9dWJ7pVnbqqp/eroe+WZm2pqGzv6XonmptTudvS9Es1NqU3v6Hslmpv+Ji/cvVeiuelv8sLdeyWam4i88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhTciL7wReeGNyAtvRF54e3Wie+WZmxqRF96IvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnhjcgL70ReeCfywjuRF96JvPD+6kT3yjM3dSIvvBN54Z3IC+9EXngn8sI7kRfeibzwTuSFdyIvvBN54Z3IC+9EXngn8sI7kRfeibzwTuSFdyIvvBN54Z3IC+9EXngn8sI7kRfeibzwTuSFdyIvvBN54Z3IC+9EXngn8sI7kRfeibzwTuSFdyIvvBN54Z3IC+9EXngn8sI7kRfeibzwTuSFdyIvvBN54Z3IC+9EXngn8sI7kRfeibzwTuSFdyIvvBN54Z3IC+9EXngn8sI7kRfeibzwTuSFdyIvvBN54Z3IC+9EXngn8sI7kRfeibzwTuSFdyIvvBN54Z3IC+9EXngn8sI7kRfeibzwTuSFdyIvvBN54Z3IC+9EXngn8sI7kRfeibzwTuSFdyIvvBN54Z3IC+9EXngn8sI7kRfeibzwTuSFdyIvvBN54Z3IC+9EXngn8sI7kRc+iLzwQeSFDyIvfBB54ePVie6VZ24aRF74IPLCB5EXPoi88EHkhQ8iL3wQeeGDyAsfRF74IPLCB5EXPoi88EHkhQ8iL3wQeeGDyAsfRF74IPLCB5EXPoi88EHkhQ8iL3wQeeGDyAsfRF74IPLCB5EXPoi88EHkhQ8iL3wQeeGDyAsfRF74IPLCB5EXPoi88EHkhQ8iL3wQeeGDyAsfRF74IPLCB5EXPoi88EHkhQ8iL3wQeeGDyAsfRF74IPLCB5EXPoi88EHkhQ8iL3wQeeGDyAsfRF74IPLCB5EXPoi88EHkhQ8iL3wQeeGDyAsfRF74IPLCB5EXPoi88EHkhQ8iL3wQeeGDyAsfRF74IPLCB5EXPoi88EHkhQ8iL3wQeeGDyAsfRF74IPLCB5EXPoi88EHkhQ8iL3wQeeGDyAsfRF74IPLCB5EXPoi88EHkhQ8iL3wSeeGTyAufRF74JPLC56sT3SvP3DSJvPBJ5IVPIi98Ennhk8gLn0Re+CTywieRFz6JvPBJ5IVPIi98Ennhk8gLn0Re+CTywieRFz6JvPBJ5IVPIi98Ennhk8gLn0Re+CTywieRFz6JvPBJ5IVPIi98Ennhk8gLn0Re+CTywieRFz6JvPBJ5IVPIi98Ennhk8gLn0Re+CTywieRFz6JvPBJ5IVPIi98Ennhk8gLn0Re+CTywieRFz6JvPBJ5IVPIi98Ennhk8gLn0Re+CTywieRFz6JvPBJ5IVPIi98Ennhk8gLn0Re+CTywieRFz6JvPBJ5IVPIi98Ennhk8gLn0Re+CTywieRFz6JvPBJ5IVPIi98Ennhk8gLn0Re+CTywieRFz6JvPBJ5IVPIi98Ennhk8gLn0Re+CTywieRFz6JvPBJ5IVPIi98Ennhk8gLn0Re+CLywheRF76IvPBF5IWvVye6V565aRF54YvIC19EXvgi8sIXkRe+iLzwReSFLyIvfBF54YvIC19EXvgi8sIXkRe+iLzwReSFLyIvfBF54YvIC19EXvgi8sIXkRe+iLzwReSFLyIvfBF54YvIC19EXvgi8sIXkRe+iLzwReSFLyIvfBF54YvIC19EXvgi8sIXkRe+iLzwReSFLyIvfBF54YvIC19EXvgi8sIXkRe+iLzwReSFLyIvfBF54YvIC19EXvgi8sIXkRe+iLzwReSFLyIvfBF54YvIC19EXvgi8sIXkRe+iLzwReSFLyIvfBF54YvIC19EXvgi8sIXkRe+iLzwReSFLyIvfBF54YvIC19EXvgi8sIXkRe+iLzwReSFLyIvfBF54YvIC19EXvgi8sIXkRe+iLzwReSFLyIvfBF54YvIC19EXvgi8sIXkRe+iLzwTeSFbyIvfBN54ZvIC9+vTnSvPHPTJvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGHyAs/RF74IfLCD5EXfl6d6F555qZD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+KHxwuvrReOFf90ry9z0da8sc9PXvbLMTV/32onulWVu+rpXlrnp615Z5qave2WZm77ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWhuovHCv+6VaG6i8cK/7pVobqLxwr/ulWduKkReeCHywguRF16IvPDy6kT3yjM3FSIvvBB54YXICy9EXngh8sILkRdeiLzwQuSFFyIvvBB54YXICy9EXngh8sILkRdeiLzwQuSFFyIvvBB54YXICy9EXngh8sILkRdeiLzwQuSFFyIvvBB54YXICy9EXngh8sILkRdeiLzwQuSFFyIvvBB54YXICy9EXngh8sILkRdeiLzwQuSFFyIvvBB54YXICy9EXngh8sILkRdeiLzwQuSFFyIvvBB54YXICy9EXngh8sILkRdeiLzwQuSFFyIvvBB54YXICy9EXngh8sILkRdeiLzwQuSFFyIvvBB54YXICy9EXngh8sILkRdeiLzwQuSFFyIvvBB54YXICy9EXngh8sILkRdeiLzwQuSFFyIvvBB54YXICy9EXngh8sILkRdeiLzwQuSFFyIvvBB54YXICy9EXngh8sILkRdeibzwSuSFVyIvvBJ54fXVie6VZ26qRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wSeeGVyAuvRF54JfLCK5EXXom88ErkhVciL7wReeGNyAtvRF54I/LC26sT3SvP3NSIvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnhjcgLb0ReeCPywhuRF96IvPBG5IU3Ii+8EXnh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eeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAvfRF74JvLCN5EXvom88E3khW8iL3wTeeGbyAs/RF74IfLCD5EXfoi88PPqRPfKMzcdIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+RF36IvPBD5IUfIi/8EHnhh8gLP0Re+CHywg+PF15ePF74da80c9N1rzRz03WvNHPTda+d6F5p5qbrXmnmputeaeam615p5qbrXonmJh4v/LpXormJxwu/7pVobuLxwq97JZqbeLzw616J5iYeL/y6V6K5iccLv+6VaG7i8cKveyWam3i88OteieYmHi/8uleiuYnHC7/ulWhu4vHCr3slmpt4vPDrXonmJh4v/LpXormJxwu/7pVobuLxwq97JZqbeLzw616J5iYeL/y6V6K5iccLv+6VaG7i8cKveyWam3i88OteieYmHi/8uleiuYnHC7/ulWhu4vHCr3slmpt4vPDrXonmJh4v/LpXormJxwu/7pVobuLxwq97JZqbeLzw616J5iYeL/y6V6K5iccLv+6VaG7i8cKveyWam3i88OteieYmHi/8uleiuYnHC7/ulWhu4vHCr3slmpt4vPDrXonmJh4v/LpXormJxwu/7pVobuLxwq97JZqbeLzw616J5iYeL/y6V6K5iccLv+6VaG7i8cKveyWam3i88OteieYmHi/8uleeuakQeeGFyAsvRF54IfLCy6sT3SvP3FSIvPBC5IUXIi+8EHnhhcgLL0ReeCHywguRF16IvPBC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IgDviSUC8J5YIgDviSUC2j0xaffEpN0Tk3ZPXLR74qLdExftnrho98Tzu36MJqDdExftnrho98RFuycu2j1x1e6Jq3ZPXLV74qrdE89vrzOagHZPXLV74qrdE1ftnrhq98RNuydu2j1x0+6Jm3ZPPL8ly2gC2j1x0+6Jm3ZP3LR74qbcE3un3BN7p9wTe6fcE3un3BN7p9wTe6fcE3un3BN7p9wTe6fcE3un3RN77Z7Ya/fEXrsn9to98fwmK6MJaPfEXrsn9to9sdfuib12Txy0e+Kg3RMH7Z44aPfE81uyjCag3RMH7Z44aPfEQbsnDto9cdTuiaN2Txy1e+Ko3RPPb8kymoB2Txy1e+Ko3RNH7Z44avfESbsnTto9cdLuiZN2Tzy/s9VoAto9cdLuiZN2TwzfY0skoN0T4/fYkgho98T4PbYkAto9MX6PLYmAdk+svceW195jy2vvseW199jy2ntsee09trz2Hltee48tr73HltfeY8tr77HltffY8tp7bHntPba89h5bXnuPLa+9x5bX3mPLa++x5bX32PLae2x57T22vPYeW157jy2vvceW195jy2vvseW199jy2ntsee09trz2Hltee48tr73HltfeY8tr77HltffY8tp7bHntPba89h5bXnuPLa+9x5bX3mPLa++x5bX32Arae2wF7T22gvYeW0F7j63glHvioL3HVtDeYyto77EVtPfYCtp7bAXtPbaC9h5bQXuPraC9x1bQ3mMraO+xFbT32Arae2wF7T22gvYeW0F7j62gvcdW0N5jK2jvsRW099gK2ntsBe09toL2HltBe4+toL3HVtDeYyto77EVtPfYCtp7bAXtPbaC9h5bQXuPraC9x1bQ3mMraO+xFbT32Arae2wF7T22gvYeW0F7j62gvcdW0N5jK2jvsRW099gK2ntsBe09toL2HltBe4+toL3HVtDeYyto77EVtPfYCtp7bAXtPbaC9h5bQXuPraC9x1bQ3mMraO+xFbT32Arae2wF7T22gvYeW0F7j62gvcdW0N5jK2jvsRW099gK2ntsBe09toL2HltBe4+toL3HVoDvL5RC/iSQKHQIoL8DlOmTAJXcIQD1DnxAgnqqPyBBRYwfkKBiwP+BhNUl5gMSVJz2AWm+zcv189+u5J1gMnKN5c+njz/rV5PxQCeXwQSSdgJZOwHSTqBo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","file_map":{"6":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: StructDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: StructDefinition) -> Quoted {\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> std::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == std::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = std::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, quote { Ord }, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use crate::cmp::{max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0 as u64, 1 as u64), 0);\n        assert_eq(min(0 as u64, 0 as u64), 0);\n        assert_eq(min(1 as u64, 1 as u64), 1);\n        assert_eq(min(255 as u8, 0 as u8), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0 as u64, 1 as u64), 1);\n        assert_eq(max(0 as u64, 0 as u64), 0);\n        assert_eq(max(1 as u64, 1 as u64), 1);\n        assert_eq(max(255 as u8, 0 as u8), 255);\n    }\n}\n","path":"std/cmp.nr"},"7":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"18":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    /// Safety: borrow is enforced to be boolean due to its type.\n    /// if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    /// if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        /// Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            /// Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        /// Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"19":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        /// Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"62":{"source":"use jwt::JWT;\n\nfn main(\n    data: BoundedVec<u8, 512>,\n    base64_decode_offset: u32,\n    pubkey_modulus_limbs: [Field; 18],\n    redc_params_limbs: [Field; 18],\n    signature_limbs: [Field; 18],\n) -> pub BoundedVec<u8, 100> {\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let claim: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n\n    jwt.assert_claim_string(\n        \"iss\".as_bytes(),\n        BoundedVec::<u8, 50>::from_array(\"http://test.com\".as_bytes()),\n    );\n\n    claim\n}","path":"/home/david/dev/trifecta/dpp_circuit/src/main.nr"},"63":{"source":"use base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse rsa::{rsa::verify_sha256_pkcs1v15, types::RBN2048};\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\nuse zkemail::partial_hash::partial_sha256_var_end;\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [Field; 18],\n    redc_params_limbs: [Field; 18],\n    signature_limbs: [Field; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [Field; 18],\n        redc_params_limbs: [Field; 18],\n        signature_limbs: [Field; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [Field; 18],\n        redc_params_limbs: [Field; 18],\n        signature_limbs: [Field; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature: RBN2048 = RuntimeBigNum::from_array(params, self.signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle: SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/root/nargo/github.com/zkemail/noir-jwt/v0.4.3/src/lib.nr"},"65":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let r = unsafe {\n        //@safety r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n        __boundary_check(limit)\n    };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir_base64/v0.4.0/src/boundary_check.nr"},"66":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[input_byte]\n                } else {\n                    BASE64_DECODE_BE_TABLE[input_byte]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[input_byte]\n            } else {\n                BASE64_DECODE_BE_TABLE[input_byte]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        unsafe {\n            //@safety get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n            // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                unsafe {\n                    //@safety get a sensible error message out if the decoding is invalid.\n                    // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                    // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                    // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                    // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            unsafe {\n                //@safety get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    assert_eq(\n        has_first_padding_byte_claim,\n        has_second_padding_byte_claim * has_first_padding_byte_claim,\n        \"if first byte contains padding so must the second\",\n    );\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/root/nargo/github.com/noir-lang/noir_base64/v0.4.0/src/decoder.nr"},"103":{"source":"use crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_120: Field = 0x1000000000000000000000000000000;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> Field {\n    let TWO_POW_120 = 0x1000000000000000000000000000000;\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0]\n    } else if N == 2 {\n        validate_in_range::<N, MOD_BITS>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        limbs[0] + limbs[1] * TWO_POW_120 + limbs[2] * TWO_POW_120 * TWO_POW_120\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [Field; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result = unsafe { __from_field::<N>(field) };\n\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n\n        let TWO_POW_120 = 0x1000000000000000000000000000000;\n        // validate that the last limb is less than the modulus\n        if N > 2 {\n            // validate that the result is less than the modulus\n            let mut grumpkin_modulus = [0; N];\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n            // validate that the limbs are in range\n            validate_in_range::<N, MOD_BITS>(result);\n        }\n        // validate the limbs sum up to the field value\n        let field_val = if N < 2 {\n            result[0]\n        } else if N == 2 {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120\n        } else {\n            validate_in_range::<N, MOD_BITS>(result);\n            result[0] + result[1] * TWO_POW_120 + result[2] * TWO_POW_120 * TWO_POW_120\n        };\n        assert(field_val == field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        std::hash::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = std::hash::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[Field; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [Field; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n        let mut num_remaining_limbs =\n            (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n        let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n        let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n            + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n        for j in 0..num_limbs_in_bigfield {\n            let mut limb: Field = 0;\n            for _ in 0..15 {\n                let need_more_bytes = (byte_ptr < num_bytes);\n                let mut byte = hash_buffer[byte_ptr];\n                limb *= (256 * need_more_bytes as Field + (1 - need_more_bytes as Field));\n                limb += byte as Field * need_more_bytes as Field;\n                byte_ptr += need_more_bytes as u32;\n            }\n            bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n        }\n        bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n    }\n\n    let mut bigfield_rhs_limbs: [Field; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [Field; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n    result\n}\n\n/**\n* @brief conditional_select given the value of `predicate` return either `self` (if 0) or `other` (if 1)\n* @description should be cheaper than using an IF statement (TODO: check!)\n**/\npub(crate) fn conditional_select<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n    predicate: bool,\n) -> [Field; N] {\n    let mut result: [Field; N] = lhs;\n    for i in 0..N {\n        result[i] = (lhs[i] - rhs[i]) * predicate as Field + rhs[i];\n    }\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120;\n        r *= TWO_POW_120;\n        modulus_mod_n *= TWO_POW_120;\n        l += lhs[N - i - 1];\n        r += rhs[N - i - 1];\n        modulus_mod_n += params.modulus[N - i - 1];\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [Field; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [Field; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = modulus[i] - val[i];\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += borrow_flags[0] as Field * TWO_POW_120;\n    for i in 1..N - 1 {\n        p_minus_self[i] += (borrow_flags[i] as Field * TWO_POW_120 - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= borrow_flags[N - 2] as Field;\n    validate_in_range::<_, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N - 1) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [Field; N]) {\n    for i in 0..(N) {\n        limbs[i].assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    limbs[N - 1].assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [Field; N], rhs: [Field; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (result, carry_flags, borrow_flags) = unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, MOD_BITS>(result);\n\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] - 1\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] - rhs[N - 1] + addend[N - 1]\n        - result[N - 1]\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params, val) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb =\n            modulus[0] - val[0] - result[0] + (borrow_flags[0] as Field * TWO_POW_120);\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] - val[i] - result[i] - borrow_flags[i - 1] as Field\n                + (borrow_flags[i] as Field * TWO_POW_120);\n            assert(result_limb == 0);\n        }\n        let result_limb =\n            modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __add(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [Field; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb =\n            lhs[0] + rhs[0] - subtrahend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] + rhs[i] - subtrahend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] + rhs[N - 1] - subtrahend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params, lhs, rhs) };\n        validate_in_range::<_, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [Field; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] - rhs[0] + addend[0] - result[0] + borrow_sub_carry * TWO_POW_120;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] - rhs[i] + addend[i] - result[i] - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb =\n            lhs[N - 1] - rhs[N - 1] + addend[N - 1] - result[N - 1] - borrow_sub_carry;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/constrained_ops.nr"},"104":{"source":"use crate::utils::split_bits;\n\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n * In this file:\n *\n * __compute_quadratic_expression_with_borrow_flags\n * __add_linear_expression\n * __compute_quadratic_expression_product\n * __compute_quadratic_expression\n * evaluate_quadratic_expression\n */\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\nunconstrained fn __compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N], [Field; 2 * N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let modulus: [Field; N] = params.modulus;\n    let modulus_bits = MOD_BITS;\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        modulus_bits,\n        modulus,\n        params.modulus_u60_x4,\n    );\n    assert(remainder == [0; N]);\n\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] * modulus[j];\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N] = [0; 2 * N];\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    let two_pow_120: Field = 0x1000000000000000000000000000000;\n    let downshift: Field = 1 / two_pow_120;\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits = (mulout_p[0] - mulout_n[0] + (borrow_flags[0] * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n    flags: [bool; M],\n) -> ([Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [Field; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [Field; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + modulus2[j] - x[i][j];\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn __compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut add: [Field; N] = [0; N];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [Field; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] * rhs[k][j]);\n            }\n        }\n        mulout[i] += add[i];\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see __compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([Field; N], [Field; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout = __compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [Field; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) = __barrett_reduction(\n        relation_result,\n        params.redc_param,\n        k,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[Field; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[Field; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[Field; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([Field; N], [Field; N], [Field; 2 * N]) = unsafe {\n        __compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [Field; N] = params.double_modulus;\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i];\n                    t0[k][i] += double_modulus[i];\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i];\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i];\n                    t1[k][i] += double_modulus[i];\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i];\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i];\n                t4[i] += double_modulus[i];\n            } else {\n                t4[i] += linear_terms[j][i];\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term = t0[k][i] * t1[k][j] - quotient[i] * params.modulus[j];\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j];\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] * params.modulus[j];\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/expressions.nr"},"106":{"source":"/**\n* @brief construct a BigNum instance out of an array of bytes in BIG ENDIAN format\n* @description: each 120-bit limb represents 15 bytes, we require that the size of the byte array\n*               is precisely large enough to cover MOD_BITS\n* @param x: input byte array\n**/\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    x: [u8; NBytes],\n) -> [Field; N] {\n    let num_bits = NBytes * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result = [0; N];\n\n    let excess_bytes = N * 15 - NBytes;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    result[N - 1] = limb;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        result[N - i - 1] = limb;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - (NBytes * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32, let NBytes: u32>(\n    val: [Field; N],\n) -> [u8; NBytes] {\n    let nbytes = (MOD_BITS / 8) + (MOD_BITS % 8 != 0) as u32;\n    assert(nbytes <= NBytes);\n\n    let mut result: [u8; NBytes] = [0; NBytes];\n    for i in 0..N - 1 {\n        let limb_bytes: [u8; 15] = val[i].to_le_bytes();\n        for j in 0..15 {\n            result[i * 15 + j] = limb_bytes[j];\n        }\n    }\n    let last_limb_bytes: [u8; 15] = val[N - 1].to_le_bytes();\n    let num_last_bytes = (NBytes - (N - 1) * 15);\n    for i in 0..num_last_bytes {\n        result[(N - 1) * 15 + i] = last_limb_bytes[i];\n    }\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/serialization.nr"},"107":{"source":"use crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\nuse crate::fns::unconstrained_ops::{__add, __eq, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\n\nglobal TWO_POW_60: u64 = 0x1000000000000000;\n\n/**\n * In this file:\n *\n * __validate_in_field_compute_borrow_flags\n * __validate_gt_remainder\n * __neg_with_flags\n * __add_with_flags\n * __sub_with_flags\n * __barrett_reduction\n * __tonelli_shanks_sqrt\n */\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [Field; N] {\n    // cast the field to a u60 representation\n    let res_u60: U60Repr<N, 2> = U60Repr::from_field(field);\n    let result: [Field; N] = U60Repr::into(res_u60);\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [Field; N] = params.modulus;\n    flags[0] = modulus[0].lt(val[0]);\n    for i in 1..N - 1 {\n        flags[i] = modulus[i].lt(val[i] + flags[i - 1] as Field);\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N]) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let mut b_u60: U60Repr<N, 2> = From::from(rhs);\n\n    let underflow = b_u60.gte(a_u60);\n    b_u60 += U60Repr::one();\n    assert(underflow == false, \"BigNum::validate_gt check fails\");\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> ([Field; N], [bool; N]) {\n    let x_u60: U60Repr<N, 2> = From::from(val);\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut borrow_in: u64 = 0;\n\n    let mut borrow_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let sub_term = x_u60.limbs[i] + borrow_in;\n        let borrow = (sub_term > params.modulus_u60.limbs[i]) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + params.modulus_u60.limbs[i] - sub_term;\n\n        borrow_in = borrow;\n        if ((i & 1) == 1) {\n            borrow_flags[i / 2] = borrow as bool;\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = From::from(lhs);\n    let b_u60: U60Repr<N, 2> = From::from(rhs);\n    let add_u60 = a_u60 + b_u60;\n\n    let overflow = add_u60.gte(params.modulus_u60);\n\n    let mut subtrahend_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    if overflow {\n        subtrahend_u60 = params.modulus_u60;\n    }\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + b_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = subtrahend_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                let idx = (i - 1) / 2;\n                carry_flags[idx] = carry as bool;\n                borrow_flags[idx] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [bool; N], [bool; N], bool) {\n    let a_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let b_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let underflow = b_u60.gte(a_u60 + U60Repr::one());\n\n    let addend_u60: U60Repr<N, 2> = if underflow {\n        params.modulus_u60\n    } else {\n        U60Repr { limbs: [0; 2 * N] }\n    };\n    let mut result_u60: U60Repr<N, 2> = U60Repr { limbs: [0; 2 * N] };\n\n    let mut carry_in: u64 = 0;\n    let mut borrow_in: u64 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..2 * N {\n        let mut add_term: u64 = a_u60.limbs[i] + addend_u60.limbs[i] + carry_in;\n        let mut carry = (add_term >= TWO_POW_60) as u64;\n        add_term -= carry * TWO_POW_60;\n        carry_in = carry;\n\n        let sub_term = b_u60.limbs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u64;\n        result_u60.limbs[i] = borrow * TWO_POW_60 + add_term - sub_term;\n        borrow_in = borrow;\n\n        if ((i & 1) == 1) {\n            // Only set `borrow` and `carry` if they differ\n            if (carry != borrow) {\n                carry_flags[i / 2] = carry as bool;\n                borrow_flags[i / 2] = borrow as bool;\n            }\n        }\n    }\n    let result = U60Repr::into(result_u60);\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [Field; 2 * N],\n    redc_param: [Field; N],\n    k: u32,\n    modulus: [Field; N],\n    modulus_u60: U60Repr<N, 4>,\n) -> ([Field; N], [Field; N]) {\n    // for each i in 0..(N + N), adds x[i] * redc_param[j] to mulout[i + j] for each j in 0..N\n    let mut mulout: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout[i + j] += x[i] * redc_param[j];\n        }\n    }\n\n    mulout = split_bits::__normalize_limbs(mulout, 3 * N - 1);\n    let mulout_u60: U60Repr<N, 6> = U60Repr::new(mulout);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient_u60 = mulout_u60.shr((k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = quotient_u60.into_field_array();\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] += partial_quotient_full[i] * modulus[j];\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    for i in 0..(N + N) {\n        let (lo, hi) = split_bits::split_120_bits(quotient_mul_modulus_normalized[i]);\n        quotient_mul_modulus_normalized[i] = lo;\n\n        // Propagate higher bits to the next index\n        // TODO: what is faster, leaving this if statement in or out?\n        // (array is size-1 too large so we can tolerate adding 0 into max element)\n        if (i + 1 < N + N) {\n            quotient_mul_modulus_normalized[i + 1] += hi;\n        }\n    }\n\n    let quotient_mul_modulus_u60: U60Repr<N, 4> = U60Repr::new(quotient_mul_modulus_normalized);\n    // convert the input into U60Repr\n    let x_u60: U60Repr<N, 4> = U60Repr::new(x);\n    let mut remainder_u60 = x_u60 - quotient_mul_modulus_u60;\n    // barrett reduction is quirky so might need to remove a few modulus_u60 from the remainder\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n    if (remainder_u60.gte(modulus_u60)) {\n        remainder_u60 = remainder_u60 - modulus_u60;\n        quotient_u60.increment();\n    }\n\n    let q: [Field; N] = U60Repr::into(quotient_u60);\n    let r: [Field; N] = U60Repr::into(remainder_u60);\n\n    (q, r)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut target: U60Repr<N, 2> = params.modulus_u60 - U60Repr::one();\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target.limbs[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target.shr1();\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [Field; N],\n    p_minus_one_over_two: [Field; N],\n) -> (bool, [Field; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [Field; N] = __one();\n    let neg_one = __neg(params, one);\n    let found = __eq(exped, neg_one);\n    let mut result: (bool, [Field; N]) = (found, target);\n    if (!found) {\n        let _target = __add(params, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [Field; N] {\n    let mut target: [Field; N] = __one();\n    let p_minus_one_over_two: U60Repr<N, 2> = (params.modulus_u60 - U60Repr::one()).shr(1);\n    let p_minus_one_over_two: [Field; N] = U60Repr::into(p_minus_one_over_two);\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [Field; N],\n    i: u32,\n) -> u32 {\n    let one: [Field; N] = __one();\n    let is_one = __eq(t2m, one);\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_helpers.nr"},"108":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __multiplicative_generator, __primitive_root_log_size,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse crate::utils::u60_representation::U60Repr;\n\n/**\n * In this file:\n *\n * __one\n * __derive_from_seed\n * __eq\n * __is_zero\n * __neg\n * __add\n * __sub\n * __mul_with_quotient\n * __mul\n * __div\n * __udiv_mod\n * __invmod\n * __pow\n * __batch_invert\n * __batch_invert_slice\n */\n\npub(crate) unconstrained fn __one<let N: u32>() -> [Field; N] {\n    let mut limbs: [Field; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [Field; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [Field; N], rhs: [Field; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [Field; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    limbs: [Field; N],\n) -> [Field; N] {\n    let f: [Field; N] = limbs;\n    let x_u60: U60Repr<N, 2> = U60Repr::from(f);\n    U60Repr::into(params.modulus_u60 - x_u60)\n}\n\npub(crate) unconstrained fn __add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let x_u60: U60Repr<N, 2> = U60Repr::from(lhs);\n    let y_u60: U60Repr<N, 2> = U60Repr::from(rhs);\n\n    let mut z_u60 = x_u60 + y_u60;\n\n    if z_u60.gte(params.modulus_u60) {\n        z_u60 = z_u60 - params.modulus_u60;\n    }\n    U60Repr::into(z_u60)\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    __add(params, lhs, __neg(params, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += lhs[i] * rhs[j];\n        }\n    }\n    let to_reduce = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(\n        to_reduce,\n        params.redc_param,\n        MOD_BITS,\n        params.modulus,\n        params.modulus_u60_x4,\n    );\n\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [Field; N],\n    rhs: [Field; N],\n) -> [Field; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> [Field; N] {\n    let inv_divisor = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [Field; N],\n    divisor: [Field; N],\n) -> ([Field; N], [Field; N]) {\n    let mut quotient_u60: U60Repr<N, 2> = U60Repr::from([0; N]);\n    let mut remainder_u60: U60Repr<N, 2> = U60Repr::from(numerator);\n\n    let mut divisor_u60: U60Repr<N, 2> = U60Repr::from(divisor);\n    let b = divisor_u60;\n\n    let mut bit_difference = remainder_u60.get_msb() - divisor_u60.get_msb();\n\n    let mut accumulator_u60: U60Repr<N, 2> = U60Repr::one();\n    divisor_u60 = divisor_u60.shl(bit_difference);\n    accumulator_u60 = accumulator_u60.shl(bit_difference);\n\n    if (divisor_u60.gte(remainder_u60 + U60Repr::one())) {\n        divisor_u60.shr1();\n        accumulator_u60.shr1();\n    }\n    for _ in 0..(N * 120) {\n        if (remainder_u60.gte(b) == false) {\n            break;\n        }\n\n        // we've shunted 'divisor' up to have the same bit length as our remainder.\n        // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n        if (remainder_u60.gte(divisor_u60)) {\n            remainder_u60 -= divisor_u60;\n            // we can use OR here instead of +, as\n            // accumulator is always a nice power of two\n            quotient_u60 = quotient_u60 + accumulator_u60;\n        }\n        divisor_u60.shr1(); // >>= 1;\n        accumulator_u60.shr1(); //  >>= 1;\n    }\n\n    (U60Repr::into(quotient_u60), U60Repr::into(remainder_u60))\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n) -> [Field; N] {\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let exp_u60 = params.modulus_u60 - (one_u60 + one_u60);\n    let exp = U60Repr::into(exp_u60);\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [Field; N],\n    exponent: [Field; N],\n) -> [Field; N] {\n    let x: U60Repr<N, 2> = U60Repr::from(exponent);\n\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [Field; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if x.get_bit(num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]; M],\n) -> [[Field; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]; M] = std::mem::zeroed();\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[Field; N]],\n) -> [[Field; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [Field; N] = __one::<N>();\n    let mut temporaries: [[Field; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[Field; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [Field; N],\n) -> std::option::Option<[Field; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one_u60: U60Repr<N, 2> = U60Repr::one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let mut Q = (params.modulus_u60 - one_u60).shr(primitive_root_log_size - 1);\n    let Q_minus_one_over_two_u60 = (Q - one_u60).shr(2);\n    let Q_minus_one_over_two: [Field; N] = U60Repr::into(Q_minus_one_over_two_u60);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [Field; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    let one: [Field; N] = __one::<N>();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/fns/unconstrained_ops.nr"},"110":{"source":"use crate::utils::u60_representation::U60Repr;\n\npub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [Field; N],\n\n    // @brief modulus but represented in a U60Repr form\n    pub modulus_u60: U60Repr<N, 2>,\n    pub modulus_u60_x4: U60Repr<N, 4>,\n\n    // @brief double_modulus: used when performing negations and subtractions\n    pub double_modulus: [Field; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [Field; N],\n}\n\n// To be implemented by the user for any BigNum they define, or within the predefined BigNums in the `fields/` dir.\npub trait BigNumParamsGetter<let N: u32, let MOD_BITS: u32> {\n    fn get_params() -> BigNumParams<N, MOD_BITS>;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [Field; N],\n        redc_param: [Field; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            modulus_u60: U60Repr::from(modulus),\n            modulus_u60_x4: U60Repr::from(modulus),\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.modulus_u60 == other.modulus_u60)\n            & (self.modulus_u60_x4 == other.modulus_u60_x4)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [Field; N]) -> [Field; N] {\n    let TWO_POW_120: Field = 0x1000000000000000000000000000000;\n    let m: U60Repr<N, 2> = U60Repr::from(modulus);\n    let mut result: [Field; N] = U60Repr::into(m + m);\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/params.nr"},"111":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, conditional_select, derive_from_seed, div, eq, is_zero, mul, neg,\n        sub, udiv, udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    expressions::{__compute_quadratic_expression, evaluate_quadratic_expression},\n    serialization::{from_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __batch_invert, __batch_invert_slice, __derive_from_seed, __div, __eq, __invmod,\n        __is_zero, __mul, __neg, __pow, __sub, __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::ops::{Add, Div, Mul, Neg, Sub};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [Field; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\npub(crate) trait RuntimeBigNumTrait<let N: u32, let MOD_BITS: u32>: Neg + Add + Sub + Mul + Div + Eq {\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self;\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self;\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self;\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self;\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self;\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes];\n\n    fn modulus(self) -> Self;\n    fn modulus_bits() -> u32;\n    fn num_limbs() -> u32;\n    // pub fn get(self) -> [Field];\n    fn get_limbs(self) -> [Field; N];\n    fn get_limb(self, idx: u32) -> Field;\n    fn set_limb(&mut self, idx: u32, value: Field);\n\n    unconstrained fn __eq(self, other: Self) -> bool;\n    unconstrained fn __is_zero(self) -> bool;\n\n    // unconstrained\n    fn __neg(self) -> Self;\n    // unconstrained\n    fn __add(self, other: Self) -> Self;\n    // unconstrained\n    fn __sub(self, other: Self) -> Self;\n    // unconstrained\n    fn __mul(self, other: Self) -> Self;\n    // unconstrained\n    fn __div(self, other: Self) -> Self;\n    // unconstrained\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self);\n    // unconstrained\n    fn __invmod(self) -> Self;\n    // unconstrained\n    fn __pow(self, exponent: Self) -> Self;\n\n    // unconstrained\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M];\n    unconstrained fn __batch_invert_slice<let M: u32>(to_invert: [Self]) -> [Self];\n\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self>;\n\n    // unconstrained\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self);\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    );\n\n    fn eq(lhs: Self, rhs: Self) -> bool {\n        lhs == rhs\n    }\n    fn assert_is_not_equal(self, other: Self);\n    fn validate_in_field(self);\n    fn validate_in_range(self);\n    // pub fn validate_gt(self, lhs: Self, rhs: Self);\n\n    fn udiv_mod(numerator: Self, divisor: Self) -> (Self, Self);\n    fn udiv(numerator: Self, divisor: Self) -> Self;\n    fn umod(numerator: Self, divisor: Self) -> Self;\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self;\n    fn is_zero(self) -> bool;\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNumTrait<N, MOD_BITS> for RuntimeBigNum<N, MOD_BITS> {\n\n    fn new(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [Field; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::new(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [Field]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [Field; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    fn from_be_bytes<let NBytes: u32>(params: BigNumParams<N, MOD_BITS>, x: [u8; NBytes]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS, _>(x), params }\n    }\n\n    fn to_le_bytes<let NBytes: u32>(self) -> [u8; NBytes] {\n        to_le_bytes::<_, MOD_BITS, _>(self.limbs)\n    }\n\n    fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    fn get_limbs(self) -> [Field; N] {\n        self.limbs\n    }\n\n    fn get_limb(self, idx: u32) -> Field {\n        self.limbs[idx]\n    }\n\n    fn set_limb(&mut self, idx: u32, value: Field) {\n        self.limbs[idx] = value;\n    }\n\n    unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __batch_invert<let M: u32>(x: [Self; M]) -> [Self; M] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs =\n            unsafe { __batch_invert::<_, MOD_BITS, _>(params, x.map(|bn| Self::get_limbs(bn))) };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // Note: can't return a slice from this unconstrained to a constrained function.\n    unconstrained fn __batch_invert_slice<let M: u32>(x: [Self]) -> [Self] {\n        let params = x[0].params;\n        assert(params.has_multiplicative_inverse);\n        let all_limbs = {\n            let inv_slice =\n                __batch_invert_slice::<_, MOD_BITS>(params, x.map(|bn| Self::get_limbs(bn)));\n            inv_slice.as_array()\n        };\n        all_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    fn __compute_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) -> (Self, Self) {\n        let (q_limbs, r_limbs) = unsafe {\n            __compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n                params,\n                map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                lhs_flags,\n                map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n                rhs_flags,\n                map(linear_terms, |bn| Self::get_limbs(bn)),\n                linear_flags,\n            )\n        };\n        (Self { limbs: q_limbs, params }, Self { limbs: r_limbs, params })\n    }\n\n    fn evaluate_quadratic_expression<let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        lhs_terms: [[Self; LHS_N]; NUM_PRODUCTS],\n        lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n        rhs_terms: [[Self; RHS_N]; NUM_PRODUCTS],\n        rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n        linear_terms: [Self; ADD_N],\n        linear_flags: [bool; ADD_N],\n    ) {\n        evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| Self::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| Self::get_limbs(bn)),\n            linear_flags,\n        )\n    }\n\n    fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    fn validate_in_range(self) {\n        validate_in_range::<_, MOD_BITS>(self.limbs);\n    }\n\n    fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    fn conditional_select(lhs: Self, rhs: Self, predicate: bool) -> Self {\n        let params = lhs.params;\n        assert(params == rhs.params);\n        Self { limbs: conditional_select(lhs.limbs, rhs.limbs, predicate), params }\n    }\n\n    fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/runtime_bignum.nr"},"118":{"source":"global TWO_POW_56: u64 = 0x100000000000000;\npub(crate) global TWO_POW_60: u64 = 0x1000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n//fields to u60rep conversion\n// field elements are 254 bits\n// so there will be 5 limbs\npub(crate) unconstrained fn field_to_u60rep(mut x: Field) -> (u64, u64, u64, u64, u64) {\n    // get the first 60 bits by casting to u64 and then taking the lower 60 bits\n    // we use the fact that this casting drops everything above 64 bits\n    let x_first_u64 = (x as u64);\n    let first: u64 = x_first_u64 % TWO_POW_60;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_60 as Field);\n    let x_second_u64 = (x as u64);\n    let second = x_second_u64 % TWO_POW_60;\n    x = (x - (second as Field)) / (TWO_POW_60 as Field);\n    let x_third_u64 = (x as u64);\n    let third = x_third_u64 % TWO_POW_60;\n    x = (x - (third as Field)) / (TWO_POW_60 as Field);\n    let x_fourth_u64 = (x as u64);\n    let fourth = x_fourth_u64 % TWO_POW_60;\n    x = (x - (fourth as Field)) / (TWO_POW_60 as Field);\n    let x_fifth_u64 = (x as u64);\n    let fifth = x_fifth_u64 % TWO_POW_60;\n    (first, second, third, fourth, fifth)\n}\n\n// Decomposes a single field into two 120 bit fields\npub unconstrained fn split_120_bits(mut x: Field) -> (Field, Field) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_56 = ((x as u64) % TWO_POW_56) as Field;\n\n    let low = low_lower_64 + TWO_POW_64 * low_upper_56;\n    let high = (x - low_upper_56) / TWO_POW_56 as Field;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\nunconstrained fn __split_60_bits(x: Field) -> (u64, u64) {\n    // Here we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let x_lower_64 = (x as u64);\n    let low = x_lower_64 % TWO_POW_60;\n    let high = ((x - (low as Field)) / TWO_POW_60 as Field) as u64;\n\n    (low, high)\n}\n\n/// Decomposes a single field into two 60 bit fields\n///\n/// Expects the input limb to be in the range [0, ..., 2^{120 - 1}]\npub fn split_60_bits(x: Field) -> (u64, u64) {\n    // We assert that the two returned limbs fit within 60 bits each\n    // and reconstruct `x` when added together.\n    let (lo, hi) = unsafe { __split_60_bits(x) };\n    if !std::runtime::is_unconstrained() {\n        let lo_field = lo as Field;\n        let hi_field = hi as Field;\n        lo_field.assert_max_bit_size::<60>();\n        hi_field.assert_max_bit_size::<60>();\n        assert_eq(lo_field + (TWO_POW_60 as Field) * hi_field, x);\n    }\n\n    (lo, hi)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [Field; N] {\n    let mut normalized: [Field; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[i] = lo;\n        next = input[i + 1] + hi;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n        normalized[range - 1] = lo;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/split_bits.nr"},"119":{"source":"use crate::utils::msb::get_msb64;\nuse crate::utils::split_bits;\nuse crate::utils::split_bits::{field_to_u60rep, TWO_POW_60};\n\n/**\n * @brief U60Repr represents a BigNum element as a sequence of 60-bit unsigned integers.\n *\n * @description: used in unconstrained functions when computing witness values.\n * It is helpful to use u60 types when evaluating addition operations that can overflow the field modulus,\n * as well as when performing bit shifts.\n */\npub struct U60Repr<let N: u32, let NumSegments: u32> {\n    pub(crate) limbs: [u64; N * NumSegments],\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Add for U60Repr<N, NumSegments> {\n    fn add(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut carry: u64 = 0;\n        for i in 0..N * NumSegments {\n            let mut add: u64 = self.limbs[i] + b.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            result.limbs[i] = add;\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::ops::Sub for U60Repr<N, NumSegments> {\n    fn sub(self, b: Self) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let mut borrow: u64 = 0;\n        let mut borrow_in: u64 = 0;\n\n        for i in 0..N * NumSegments {\n            borrow = ((b.limbs[i] + borrow_in) > self.limbs[i]) as u64;\n            let sub = (borrow << 60) + self.limbs[i] - b.limbs[i] - borrow_in;\n            result.limbs[i] = sub;\n            borrow_in = borrow;\n        }\n\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::convert::From<[Field; N]> for U60Repr<N, NumSegments> {\n    fn from(input: [Field; N]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..N {\n            let (lo, hi) = split_bits::split_60_bits(input[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n}\n\n// impl<let N: u32, let NumSegments: u32> std::convert::From<Field> for U60Repr<N, NumSegments> {\n//     fn from(input: Field) -> Self {\n//        let (low, mid, high) =  unsafe { field_to_u60rep(input) } ;\n//         let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n//         let N_u60: u32 = N * NumSegments;\n//         assert(N_u60 >=1, \"N must be at least 1\");\n//         if N_u60 == 1 {\n//             assert((mid ==0) & (high == 0), \"input field is too large to fit in a single limb\");\n//             result.limbs[0] = low;\n//         }\n//         else if N_u60 == 2{\n//             assert(high == 0, \"input field is too large to fit in two limbs\");\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//         }else{\n//             result.limbs[0] = low;\n//             result.limbs[1] = mid;\n//             result.limbs[2] = high;\n//         }\n//         result\n//     }\n// }\n\nimpl<let N: u32, let NumSegments: u32> std::convert::Into<[Field; N]> for U60Repr<N, NumSegments> {\n    fn into(x: U60Repr<N, NumSegments>) -> [Field; N] {\n        let mut result: [Field; N] = [0; N];\n        let two_pow_60: Field = 0x1000000000000000;\n        for i in 0..N {\n            result[i] = x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * two_pow_60);\n        }\n        result\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> std::cmp::Eq for U60Repr<N, NumSegments> {\n    fn eq(self, other: Self) -> bool {\n        self.limbs == other.limbs\n    }\n}\n\nimpl<let N: u32, let NumSegments: u32> U60Repr<N, NumSegments> {\n\n    pub(crate) fn new<let NumFieldSegments: u32>(x: [Field; N * NumFieldSegments]) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        for i in 0..(N * NumFieldSegments) {\n            let (lo, hi) = split_bits::split_60_bits(x[i]);\n            result.limbs[2 * i] = lo;\n            result.limbs[2 * i + 1] = hi;\n        }\n        result\n    }\n\n    pub(crate) fn one() -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub(crate) unconstrained fn from_field(input: Field) -> Self {\n        let (first, second, third, fourth, fifth) = field_to_u60rep(input);\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n        let N_u60: u32 = N * NumSegments;\n        assert(N_u60 >= 1, \"N must be at least 1\");\n        if N_u60 == 1 {\n            assert(\n                (second == 0) & (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in a single limb\",\n            );\n            result.limbs[0] = first;\n        } else if N_u60 == 2 {\n            assert(\n                (third == 0) & (fourth == 0) & (fifth == 0),\n                \"input field is too large to fit in two limbs\",\n            );\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n        } else if N_u60 == 3 {\n            assert((fourth == 0) & (fifth == 0), \"input field is too large to fit in three limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n        } else if N_u60 == 4 {\n            assert((fifth == 0), \"input field is too large to fit in four limbs\");\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n        } else {\n            result.limbs[0] = first;\n            result.limbs[1] = second;\n            result.limbs[2] = third;\n            result.limbs[3] = fourth;\n            result.limbs[4] = fifth;\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn into_field_array(\n        x: U60Repr<N, NumSegments>,\n    ) -> [Field; N * NumSegments / 2] {\n        let mut result: [Field; N * NumSegments / 2] = [0; N * NumSegments / 2];\n        for i in 0..(N * NumSegments / 2) {\n            result[i] =\n                x.limbs[2 * i] as Field + (x.limbs[2 * i + 1] as Field * TWO_POW_60 as Field);\n        }\n        result\n    }\n\n    pub(crate) unconstrained fn gte(self, b: Self) -> bool {\n        let mut result = false;\n        let mut early_exit = false;\n        for i in 0..(N * NumSegments) {\n            let idx = (N * NumSegments) - 1 - i;\n            if (b.limbs[idx] == self.limbs[idx]) {\n                continue;\n            }\n\n            result = b.limbs[idx] < self.limbs[idx];\n            early_exit = true;\n            break;\n        }\n        if early_exit {\n            result\n        } else {\n            self.limbs[0] == b.limbs[0]\n        }\n    }\n\n    pub(crate) fn get_bit(self, bit: u32) -> bool {\n        let segment_index = bit / 60;\n        let uint_index = bit % 60;\n\n        let limb: u64 = self.limbs[segment_index];\n        let value = (limb >> uint_index as u8) & 1;\n        value == 1\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; N * NumSegments] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift = (60 - limb_shift) as u8;\n        let mask: u64 = (((1 as u64) << limb_shift) - 1) << remainder_shift;\n        result.limbs[0] = (self.limbs[0 + num_shifted_limbs] >> limb_shift);\n\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i + num_shifted_limbs];\n            result.limbs[i] = value >> limb_shift;\n            let remainder: u64 = (value << remainder_shift) & mask;\n            result.limbs[i - 1] = result.limbs[i - 1] + remainder;\n        }\n        result\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shr1(&mut self) {\n        let value = self.limbs[NumSegments * N - 1];\n        self.limbs[NumSegments * N - 1] = value >> 1;\n\n        let mut remainder = (value & 1) << 59;\n\n        for i in 0..N * NumSegments {\n            let value = self.limbs[N * NumSegments - 1 - i];\n            self.limbs[N * NumSegments - 1 - i] = (value >> 1) + remainder;\n            remainder = (value << 59) & 0x800000000000000;\n        }\n    }\n\n    // note: shr cannot satisfy `Shr` Trait due to `shift` parameter being u64 and not u8 (shift value might be greater than 255)\n    pub(crate) fn shl(self, shift: u32) -> Self {\n        let mut result: Self = U60Repr { limbs: [0; NumSegments * N] };\n\n        let num_shifted_limbs = shift / 60;\n        let limb_shift = (shift % 60) as u8;\n        let remainder_shift: u8 = 60 - limb_shift as u8;\n\n        // 83\n        // limb shift = 1\n        // inside shift = 19 bits to the left\n        // meaning we have 19 carry bits and 41 remainder bits\n        let mask: u64 = (1 as u64 << 60) - 1;\n        //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n        let value = self.limbs[0];\n\n        let mut remainder = (value >> remainder_shift);\n        result.limbs[num_shifted_limbs] = (value << limb_shift) & mask;\n\n        // shift 84. num shifted = 1\n        for i in 1..((N * NumSegments) - num_shifted_limbs) {\n            let value = self.limbs[i];\n            let upshift = ((value << limb_shift) + remainder) & mask;\n            result.limbs[i + num_shifted_limbs] = upshift;\n            remainder = (value >> remainder_shift);\n            // let remainder: u64 = (self.limbs.get(i + num_shifted_limbs as u64) << remainder_shift as u8) & mask;\n            // result.limbs.set(i - 1, result.limbs.get(i - 1) + remainder);\n        }\n        result\n    }\n\n    pub(crate) fn increment(&mut self) {\n        let mut carry: u64 = 0;\n\n        let mut add: u64 = self.limbs[0] + 1;\n        carry = add >> 60;\n        add = add - (carry << 60);\n        self.limbs[0] = add;\n\n        for i in 1..NumSegments * N {\n            let mut add: u64 = self.limbs[i] + carry;\n            carry = add >> 60;\n            add = add - (carry << 60);\n            self.limbs[i] = add;\n        }\n    }\n\n    pub(crate) unconstrained fn get_msb(val: Self) -> u32 {\n        let mut count = 0;\n        for i in 0..N * NumSegments {\n            let v = val.limbs[((N * NumSegments) - 1 - i)];\n            if (v > 0) {\n                count = 60 * ((N * NumSegments) - 1 - i) + get_msb64(v);\n                break;\n            }\n        }\n        count\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir-bignum/v0.5.4/src/utils/u60_representation.nr"},"130":{"source":"use dep::bignum::{params::BigNumParams, RuntimeBigNum};\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme.\n * @note The `exponent` can be either 65537 or 3 (i.e. the most common values in use for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    assert((exponent == 3) | (exponent == 65537), \"Exponent must be 65537 or 3\");\n    let mut exponentiated = sig * sig; // sig^2\n    if exponent == 65537 {\n        // e = 65537 = 1 0000 0000 0000 0001\n        exponentiated = exponentiated * exponentiated; // sig^4\n        exponentiated = exponentiated * exponentiated; // sig^8\n        exponentiated = exponentiated * exponentiated; // sig^16\n        exponentiated = exponentiated * exponentiated; // sig^32\n        exponentiated = exponentiated * exponentiated; // sig^64\n        exponentiated = exponentiated * exponentiated; // sig^128\n        exponentiated = exponentiated * exponentiated; // sig^256\n        exponentiated = exponentiated * exponentiated; // sig^512\n        exponentiated = exponentiated * exponentiated; // sig^1024\n        exponentiated = exponentiated * exponentiated; // sig^2048\n        exponentiated = exponentiated * exponentiated; // sig^4096\n        exponentiated = exponentiated * exponentiated; // sig^8192\n        exponentiated = exponentiated * exponentiated; // sig^16384\n        exponentiated = exponentiated * exponentiated; // sig^32768\n        exponentiated = exponentiated * exponentiated; // sig^65536\n    }\n    // otherwise, e = 3 = 11\n    exponentiated = exponentiated * sig; // either sig^2 * sig = sig^3 or sig^65536 * sig = sig^65537\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_1024() {\n    // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world! test#123\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170,\n                193, 96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n            ],\n    );\n\n    let params: BigNumParams<9, 1024> = BigNumParams::new(\n        false,\n        [\n            0xab238ad9cb37979a43aefbf10be8fb,\n            0x31347febe45fe8c2dac1dd30900704,\n            0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n            0x5eac6390f7873fe97ff9bb14a173ea,\n            0xbc41f700c91fd733a2c63177bbdbd4,\n            0x41442bd58769a3595b659a2ec9c6be,\n            0x4ddc91395f330382aa2e2d3fbe147,\n            0x3d008ff255a0bc71c7887f5728ba1,\n            0xb640c3a8f511c64e,\n        ],\n        [\n            0x5d53d2634c6a0918266043968ce263,\n            0x5dd4be3dce0323a492ee9340aec4db,\n            0xf82d0e2e5c8319f01a460c72c01854,\n            0x236e6fc6e62e8a1d522acda5fb3892,\n            0xdaf755619d66e580901aa224d03174,\n            0x8366291616480e7e1f202dbcedda87,\n            0x40ba1202537d1e94561ccc05265586,\n            0x69b993d857ba89ea5de9822aeb4b93,\n            0x167968c0000761a273,\n        ],\n    );\n\n    let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xc3850e84ea02da3f028ff422f4d6a9,\n            0x9761f0bd9021f76d45c60df0670a19,\n            0xc1ede421a43607ab623ed4d5a17fc8,\n            0x86197b4315206f4d53200b42555831,\n            0xe95783b69db28c26a83706f39d04cd,\n            0x18b178dc1a9ec76fb22b57e4dfa703,\n            0xdd0e19cd5a09ab48e7af4d0e3470e3,\n            0x10004dfab1cf91304e80e6baa4dfc7,\n            0x241c3fd77b90adef,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048() {\n    // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"Hello World! This is Noir-RSA\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131,\n                166, 79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n            0xbfb937fc4d3cf02cc0af780f3cab44,\n            0xd20637ef7adcf5d238ee87bccc9bca,\n            0xb9db4f2663108e2f8b673f7612ae8b,\n            0x85f894ef669b36bfd3d86b0a28873,\n            0xdcc70e1884e38b8229cce3b884121d,\n            0x35488d1138e0b03e1676f7f5d8a5b3,\n            0xe1a97820e7dcbb4eab35c9b71bb273,\n            0x97d19eb3c63249ddbfcff915863f54,\n            0x3a78c7af6da0f6af0d67b1ca4b6065,\n            0xd7a3c433c020f624821e5e678c7d69,\n            0x52d5b53240feae82ffea3d2a3d9b09,\n            0xb8aad5e19e2163f68997c6fdd71906,\n            0x5db432d06e8b0bf59511100c7894e2,\n            0xadc0bbc4c54da10d1cc88438ea3127,\n            0xece1cf6a1501109cd2734d5893c8d9,\n            0x7196b90acdf06c31b1288064fd0c27,\n            0xc8,\n        ],\n        [\n            0x1b1deccf4dbde852c34a5d6908a0f,\n            0xbc9e5bdab22f023fbcca58692bccf5,\n            0x1f65439685623e45396ff55751c3bf,\n            0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n            0x5ca2e8e3048243c16c708a8030ab0d,\n            0x30079bfeb1fa51e5501581173ca19c,\n            0xff8d5f6bea485fdcc2716327f69ab4,\n            0x36b599d81589416b5b5f037986b999,\n            0x75612e34a4ff29f0a19a7823512f58,\n            0x288b6897929b54c3b26a5faa07c00f,\n            0x4b5675fa13ab7444f1f047d3eb1bbe,\n            0x6ba0ac610ef9f267ab30fe25bb1c84,\n            0xa386b48ee03168d5cea3ecb9dc901f,\n            0xacf1a01f7dba44e050c976142fb1f6,\n            0x97a63b5cb7efc60d3502946aec63cf,\n            0x12cc1d5cab10a1e9e2398d29b9e3ef,\n            0x4635cf25c66e76bba8034df46204fb,\n            0x146f,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xad29e07d16a278de49a371b9760a27,\n            0x86311920cc0e17a3c20cdff4c56dbb,\n            0x863556c6c5247dd83668dd825716ae,\n            0xc247c960945f4485b46c33b87425ca,\n            0x7326463c5c4cd5b08e21b938d9ed9a,\n            0x4f89fe0c82da08a0259eddb34d0da1,\n            0x43a74e76d4e1bd2666f1591889af0d,\n            0x240f7b80f0ff29f4253ee3019f832d,\n            0xc6edd131fbaaf725fd423dac52b362,\n            0x85f9732679242163e8afff44f6104d,\n            0xd3c3bbcb1757013fd6fb80f31dd9a6,\n            0x9008633f15df440e6df6d21ee585a2,\n            0x324df3425ed256e283be5b6b761741,\n            0xc60c1302929bd0e07caa4aeff4e8fd,\n            0x600d804ff13ba8d0e1bc9508714212,\n            0x50f7e75e5751d7edd61167027926be,\n            0x0db41d39442023e1420a8a84fe81d9,\n            0xab,\n        ],\n    };\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n}\n\n#[test]\nfn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n    // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n    let sha256_hash: [u8; 32] = dep::std::hash::sha256(\"hello world\".as_bytes());\n    assert(\n        sha256_hash\n            == [\n                185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132,\n                239, 227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n            ],\n    );\n\n    let params: BigNumParams<18, 2048> = BigNumParams::new(\n        false,\n        [\n            0xe40ee47801326543c8e84b85d567c1,\n            0x5b54ea87f0ce29de1995697b0696fd,\n            0x457078f8fdce68b437cac0970b2452,\n            0x473ec776fee3731b6ab06e35875ddc,\n            0x62dedd594e5f12c80c3ccb5791a6cd,\n            0xecb934b9d8272c5e3a418145345499,\n            0xd1af643b3d785470ed0c6cd633f706,\n            0xb58a57b9e96eccbdfc7c17f0333d4,\n            0x2ebd34b5039fc596504927c282c60d,\n            0x3a44928a74f25fc1043bb37ce4dfa8,\n            0x91448459f9617fac33a2816162ac9e,\n            0x70cb910d9f3e1a78864640ec6c8240,\n            0x9aed33f6b31f1c9de67248a98c180,\n            0x7f1416e032c79488c94b311e87bd9c,\n            0x7191b4ebb1b3fffa949fa48ed01e5,\n            0x350a75cbaeca6bfdd71ca83cdbcae9,\n            0xfb1d274fa207457c6814d42c09f9cf,\n            0xd4,\n        ],\n        [\n            0x803bf4d38110a7d37fdd05f590dee9,\n            0xa68d317c933f37cab5ab4e7c00a3b9,\n            0x476a05a536bf5f2aa1b8850146cba7,\n            0xca297ea8b5528d91d4836ff27c30ab,\n            0x75cf2eaab76eefa12bbd570f1aea9f,\n            0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n            0xd497db1f6ebe83decacaa647fabea6,\n            0x686b27ca330e25e7a7cf197f6433ef,\n            0xfde04d2225c8308b07580af0058a0f,\n            0xa29fb69777c0e916976243b2b09855,\n            0xf983592285852e7e1c2cb3ae968323,\n            0x673608017f9f5acf67a01b73728d70,\n            0xeeff82521c0bc432a05f4b7444fac0,\n            0x85a89c4d229f60aaa3aa7ac7dac1e2,\n            0xcfecff93bc9fbfe0d6dff6091f2db8,\n            0xf20f047dcb224b4447bd098c07f8c2,\n            0x554bb53cadeb3eaab911a189f90227,\n            0x133b,\n        ],\n    );\n\n    let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n        params,\n        limbs: [\n            0xa250eff812c63eaaeaa3f04641c05f,\n            0xecc09613cb8b289c1f37c8f92e6a05,\n            0x2c0a0510058360c07af65d46f594fd,\n            0x943d67513363d3de430c94a1dafe7c,\n            0x511ec8e9b10bc6c6ff0d6c232ccf92,\n            0x50ffd07b3c093b3f5fc027de847731,\n            0xc268e1489449943fdafdf89ff168c3,\n            0x0b8b7f9f49b492f78fda58d252f23a,\n            0x491c6c4ef836a6a8730b7bf81e865e,\n            0x8746c75fb079d014e419543f56d7f0,\n            0x65804c417d6168a8bc0025d255cebf,\n            0xf695e91b77890b8e3fd775fa56e627,\n            0x5e90001c0218550f4083ae28025a2f,\n            0x526bd4eff34f25f62a698f0470e0a6,\n            0x7f224306a7d9daf536b1559434c6c6,\n            0x88809f16fe1fcea3c87511d9319735,\n            0x7694685fee0bfab4a9196b92ec6f2e,\n            0xa7,\n        ],\n    };\n\n    assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n}\n","path":"/root/nargo/github.com/noir-lang/noir_rsa/v0.6.0/lib/src/rsa.nr"},"135":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\nmod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = INITIAL_STATE;\n        // Pointer into msg_block on a 64 byte scale\n        let mut msg_byte_ptr = 0;\n        let num_blocks = N / BLOCK_SIZE;\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n\n            // If the block is filled, compress it.\n            // An un-filled block is handled after this loop.\n            if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n                h = sha256_compression(msg_block, h);\n            }\n        }\n\n        let modulo = N % BLOCK_SIZE;\n        // Handle setup of the final msg block.\n        // This case is only hit if the msg is less than the block size,\n        // or our message cannot be evenly split into blocks.\n        if modulo != 0 {\n            let msg_start = BLOCK_SIZE * num_blocks;\n            let (new_msg_block, new_msg_byte_ptr) =\n                unsafe { build_msg_block(msg, message_size, msg_start) };\n\n            if msg_start < message_size {\n                msg_block = new_msg_block;\n            }\n\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        }\n\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        if msg_byte_ptr == BLOCK_SIZE {\n            msg_byte_ptr = 0;\n        }\n\n        // Pad the rest such that we have a [u32; 2] block at the end representing the length\n        // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n        // Here we rely on the fact that everything beyond the available input is set to 0.\n        let index = msg_byte_ptr / INT_SIZE;\n        msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n        msg_byte_ptr = msg_byte_ptr + 1;\n        let last_block = msg_block;\n\n        // If we don't have room to write the size, compress the block and reset it.\n        if msg_byte_ptr > MSG_SIZE_PTR {\n            h = sha256_compression(msg_block, h);\n            // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n            msg_byte_ptr = 0;\n        }\n\n        msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n        hash_final_block(msg_block, h)\n    }\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = INITIAL_STATE;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/sha256/v0.1.2/src/sha256.nr"},"136":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine, lt_f};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: Field,\n        body_chunk_offset: Field,\n        num_full_chunks: Field,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: Field) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: Field) -> u8 {\n        self.body[idx as u32]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: Field,\n        starting_haystack_chunk: Field,\n        num_full_chunks: Field,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte as Field + (i as Field * 31) + j as Field;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate: Field = lt_f(i as Field, num_full_chunks) as Field;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as Field * (i as Field + starting_haystack_chunk)];\n            assert(predicate * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: Field = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: Field = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks =\n            lt_f(substring_length as Field, num_bytes_in_first_chunk as Field);\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks as Field * 31 + num_bytes_in_first_chunk as Field;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks as Field + chunk_index as Field + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index as Field;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: Field = chunk_offset as Field;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: Field = i as Field;\n            let predicate: Field = lt_f(i as Field, offset_to_first_needle_byte_in_chunk) as Field;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = (1 - predicate) * (idx - offset_to_first_needle_byte_in_chunk);\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index: Field =\n                starting_needle_byte_index_of_final_chunk as Field + i as Field;\n            let predicate = lt_f(lhs_index, substring_length as Field);\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as Field) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset: Field = chunk_index as Field + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk as Field,\n            body_chunk_offset,\n            num_full_chunks as Field,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/root/nargo/github.com/noir-lang/noir_string_search/v0.3.2/src/lib.nr"},"137":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub unconstrained fn get_lt_predicate_f(x: Field, y: Field) -> bool {\n    let a = x as u32;\n    let b = y as u32;\n    a < b\n}\n\npub fn lt_f(x: Field, y: Field) -> bool {\n    // Safety: As `x` and `y` are known to be valid `u32`s, this function reimplements the\n    // compiler's internal implementation of `lt`\n    unsafe {\n        let predicate = get_lt_predicate_f(x, y);\n        let delta = y as Field - x as Field;\n        let lt_parameter = 2 * (predicate as Field) * delta - predicate as Field - delta;\n        lt_parameter.assert_max_bit_size::<32>();\n\n        predicate\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/root/nargo/github.com/noir-lang/noir_string_search/v0.3.2/src/utils.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","__split_60_bits","__mul","__compute_quadratic_expression_with_borrow_flags","extract_claim_unconstrained","__boundary_check","__validate_decoded","search","get_lt_predicate_f","extract_claim_unconstrained","extract_claim_unconstrained","directive_integer_quotient","directive_invert","directive_to_radix"]}